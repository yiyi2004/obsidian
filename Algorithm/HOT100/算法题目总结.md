- 原则是穷尽算法的所有知识点和解法

## 哈希

### 1. 两数之和

- target - cur_num 是否在 map 中存在

### 49. 字母异位词分组

- sort.Slice 对 []byte 进行排序
- 使用 map 接收

### 128. 最长连续序列

- 使用 map 记录数值是否存在
- 记录 maxlong

## 双指针

### 283. 移动零

- make([]int, len(nums)) + 赋值

### 11. 盛最多水的容器

> 双指针的解题思路是什么
> 1. 当满足某一条件的时候，移动一个指针
> 2. 只遍历一次数组  
> 解题技巧
> 3. 可以夸大化数据，比如长板为 999999，短板为 10. 这样大概率就知道移动那个板子了。

- 移动短板

### 15. 三数之和

- 固定一个位置，然后使用双指针。
- 处理特殊情况 000 —— 似乎只有这一种情况。

### 42. 接雨水

- 这道题有多种解法：技巧、动态规划、双指针方法。

解法一：更偏向于技巧

- 前后遍历两次数组，由这两个最大值数组找到**封顶数组**。
- 用封顶数组减去原始数组中墙的高度。

## 滑动窗口

- 滑动窗口本质上也是双指针，不过是同向还是双向的区别。—— 我的理解是这样的。

### 3. 无重复字符的最长子串

- 要区分子序列和子串的概念。
- 右指针不断向右移动，检查 set 中是否存在当前右指针指向的字符，如果不存在，放入 set。
- 如果存在，弹出左指针指向的字符，直到右指针指向的字符在 set 中不存在。
- 将右指针指向的字符添加进 set。

### 438. 找到字符串中所有字母异位词

- 参数可能无限大也可能无限小 —— 做这样的假定，然后考虑时间和空间复杂度。
- 26 个字母是可固定的空间，所以类似 bitmap 那种处理方案。只要包含的字符相同，就是“异位词”。

## 子串

### 560. 和为 K 的子数组

- 脑子开始不转了，去做点其他事情吧。

### 239. 滑动窗口最大值

- `pre[i] - pre[j] = k`
- 如果 `pre[cur - k]` 存在，那么 `pre[cur] - pre[cur - k] == k`
- 滚动数组 + 前缀数组
- pre 记录到当前为止数组中所有数据的和
- map 记录某一个前缀和是否存在

### 76. 最小覆盖子串

- 滑动窗口 + 26 位数组对比

## 普通数组

### 53. 最大子数组和

条件判断的动态规划

- 动态规划 + 重复利用子数字
- 需要考虑初始化的问题
- 不是严格意义上的动态规

### 56. 合并区间

- 排序 + 分类讨论
- 最后位置即 intervals[len(intervals) - 1] 需要进行特殊讨论

### 189. 轮转数组

- 通过模运算操作 + helpArray

### 238. 除自身以外数组的乘积

- 0 的个数 2 个 | 1 个
- 比较简单，关键在于考虑是否完备

### 41. 缺失的第一个正数

- 通过 map 解决，但是性能很差
- 排序 + 二分查找
- 置换的算法 O(N) O(1)
- 原来的方法相等的时候会陷入无限的循环
- 因此判断条件应该是 nums[i] != nums[nums[i]-1] 先对 nums[i] 进行范围判断

## 矩阵

### 73. 矩阵置零

- 方法一：用 hash 表记录行列是否存在 0
- 优化方法二：用第一行和第一列标记矩阵右下侧 0 的位置

---

- 实现还是挺简单的
- 但是方法一确实有更好的效果啊。

### 54. 螺旋矩阵

- [一入循环深似海 | LeetCode：59.螺旋矩阵II_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1SL4y1N7mV/?spm_id_from=333.337.search-card.all.click&vd_source=25509bb582bc4a25d86d871d5cdffca3)

---

难点：处理的边界条件比较多

- 循环不变量
- 可是使用 offset 进行优化
- top, bottom, left, right 去解决

### 48. 旋转图像

- 左上角位单位，一次翻转 4 个位置
- n / 2 和 (n+1)/2 保证不重复和不漏掉元素

### 240. 搜索二维矩阵 II

- 遍历 + 二分查找

## 链表

### 160. 相交链表

- 通过哈希表解决
- 通过双指针解决

### 206. 反转链表

- 原地反转，并没有什么困难的

### 141. 环形链表

- 通过快慢指针解决问题

### 142. 环形链表 II

- 可以通过快慢指针解决，但是感觉没有必要。
- 我是通过哈希表实现的。

### 21. 合并两个有序链表

- 通过迭代实现

### 2. 两数相加

- 通过模拟实现，要注意一个链比较长的情况。

### 19. 删除链表的倒数第 N 个结点

- 方法一：计算长度，然后删除对应节点
- **快慢指针**到底是什么方法，为什么这么多链表的问题都能解决。

### 24. 两两交换链表中的节点

- 通过模拟的方式实现的 | 在于让别人信任你。

### 25. K 个一组翻转链表

- 困难
- 方法一：模拟 + reverse + 处理特殊情况

### 138. 随机链表的复制（忘记了，未完全解决）

- 深拷贝重新构建，可以通过 map 去记录 random 的节点，然后重新构建。

### 148. 排序链表

- 归并排序排序链表，不要投机取巧用数组排序。
- 但是问题出在哪里了呢？head.Next = nil 去掉后面的节点，方便归并排序的时候进行判断。

### 23. 合并 K 个升序链表

- 归并排序的策略，先合并两个。

### 146. LRU 缓存

- 代码封装的很好
- initDLinkedNode
- addToHead
- removeNode
- moveToHead
- removeTail

## 二叉树

### 94. 二叉树的中序遍历

- 递归实现

### 104. 二叉树的最大深度

- 递归实现，二叉 DP 问题

### 26. 翻转二叉树

- 递归实现，先交换再递归

### 101. 对称二叉树

- 深度优先遍历
- `return dfs(left.Left, right.Right) && dfs(left.Right, right.Left)`

### 543. 二叉树的直径

- 二叉 dp 问题，套路解决

### 102. 二叉树的层序遍历

- 封装队列数据结构，然后很轻松就能解决问题
- **队列中的节点就是上一层中所有的节点。**

### 108. 将有序数组转换为二叉搜索树

- 递归构建，并没有什么困难的。

### 98. 验证二叉搜索树

- **套路解决**，递归实现

### 230. 二叉搜索树中第 K 小的元素

- **中序遍历**解决问题

### 199. 二叉树的右视图

- dfs 解决
- 右侧优先
- 从 0 开始找到 depth == 1 ---> depth == n 的节点，用数组收集值，用数组的长度作为 depth 的判定条件

```go
func rightSideView(root *TreeNode) []int {

    if root == nil {

        return nil

    }

    // 层序遍历中每一层最后一个元素

    var dfs func(node *TreeNode, depth int)

    res := make([]int, 0)

    dfs = func(node *TreeNode, depth int) {

        if node == nil {

            return

        }

        if depth == len(res) {

            res = append(res, node.Val)

        }

        dfs(node.Right, depth+1)

        dfs(node.Left, depth+1)

    }

    dfs(root, 0)

    return res

}
```

### 114. 二叉树展开为链表

- 我的解法：先序遍历收集值，然后重新构建 (时间和空间复杂度都不理想)
- **将右子树迁移到左子树上面**
- 这道题的解法和**二叉 dp 的题目有些类似**，都是假设左子树和右子树已经处理好了，然后进行进一步的处理。

### 105. 从前序与中序遍历序列构造二叉树

- 通过**下标**的方式计算实在是**太傻了**
- **递归**实现的代码非常简洁，**缩小规模**很重要

### 437. 路径总和 III

- 定义两个函数
	- 从 root 出发，路径和为 target 的路径总数
	- root 节点下的路径和总数 ---> 题目中定义的函数

### 236. 二叉树的最近公共祖先

- 一个节点如果能**找到左节点和右节点**，那么这个节点就是最近公共祖先

### 124. 二叉树中的最大路径和

- 方法一：二叉 dp 递归套路

## 图论

### 200. 岛屿数量

### 994. 腐烂的橘子

## 回溯

### 46. 全排列

- 回溯算法 + onPath map[i]bool

### 78. 子集

## 二分查找

## 栈

### 739. 每日温度

- 通过单调栈解决问题，< == > 三种情况

## 堆

## 贪心算法

## 动态规划

## 多维动态规划

## 技巧
