- 原则是穷尽算法的所有知识点和解法

## 哈希

### 1. 两数之和

- target - cur_num 是否在 map 中存在

### 49. 字母异位词分组

- sort.Slice 对 []byte 进行排序
- 使用 map 接收

### 128. 最长连续序列

- 使用 map 记录数值是否存在
- 记录 maxlong

## 双指针

### 283. 移动零

- make([]int, len(nums)) + 赋值

### 11. 盛最多水的容器

> 双指针的解题思路是什么
> 1. 当满足某一条件的时候，移动一个指针
> 2. 只遍历一次数组  
> 解题技巧
> 3. 可以夸大化数据，比如长板为 999999，短板为 10. 这样大概率就知道移动那个板子了。

- 移动短板

### 15. 三数之和

- 固定一个位置，然后使用双指针。
- 处理特殊情况 000 —— 似乎只有这一种情况。

### 42. 接雨水

- 这道题有多种解法：技巧、动态规划、双指针方法。

解法一：更偏向于技巧

- 前后遍历两次数组，由这两个最大值数组找到**封顶数组**。
- 用封顶数组减去原始数组中墙的高度。

## 滑动窗口

- 滑动窗口本质上也是双指针，不过是同向还是双向的区别。—— 我的理解是这样的。

### 3. 无重复字符的最长子串

- 要区分子序列和子串的概念。
- 右指针不断向右移动，检查 set 中是否存在当前右指针指向的字符，如果不存在，放入 set。
- 如果存在，弹出左指针指向的字符，直到右指针指向的字符在 set 中不存在。
- 将右指针指向的字符添加进 set。

### 438. 找到字符串中所有字母异位词

- 参数可能无限大也可能无限小 —— 做这样的假定，然后考虑时间和空间复杂度。
- 26 个字母是可固定的空间，所以类似 bitmap 那种处理方案。只要包含的字符相同，就是“异位词”。

## 子串

### 560. 和为 K 的子数组

- 脑子开始不转了，去做点其他事情吧。

### 239. 滑动窗口最大值

- `pre[i] - pre[j] = k`
- 如果 `pre[cur - k]` 存在，那么 `pre[cur] - pre[cur - k] == k`
- 滚动数组 + 前缀数组
- pre 记录到当前为止数组中所有数据的和
- map 记录某一个前缀和是否存在

### 76. 最小覆盖子串

- 滑动窗口 + 26 位数组对比

## 普通数组

### 53. 最大子数组和

条件判断的动态规划

- 动态规划 + 重复利用子数字
- 需要考虑初始化的问题
- 不是严格意义上的动态规

### 56. 合并区间

- 排序 + 分类讨论
- 最后位置即 intervals[len(intervals) - 1] 需要进行特殊讨论

### 189. 轮转数组

- 通过模运算操作 + helpArray

### 238. 除自身以外数组的乘积

- 0 的个数 2 个 | 1 个
- 比较简单，关键在于考虑是否完备

### 41. 缺失的第一个正数

- 通过 map 解决，但是性能很差
- 排序 + 二分查找
- 置换的算法 O(N) O(1)
- 原来的方法相等的时候会陷入无限的循环
- 因此判断条件应该是 nums[i] != nums[nums[i]-1] 先对 nums[i] 进行范围判断

## 矩阵

### 73. 矩阵置零

- 方法一：用 hash 表记录行列是否存在 0
- 优化方法二：用第一行和第一列标记矩阵右下侧 0 的位置

---

- 实现还是挺简单的
- 但是方法一确实有更好的效果啊。

### 54. 螺旋矩阵

- [一入循环深似海 | LeetCode：59.螺旋矩阵II_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1SL4y1N7mV/?spm_id_from=333.337.search-card.all.click&vd_source=25509bb582bc4a25d86d871d5cdffca3)

---

难点：处理的边界条件比较多

- 循环不变量
- 可是使用 offset 进行优化
- top, bottom, left, right 去解决

### 48. 旋转图像

- 左上角位单位，一次翻转 4 个位置
- n / 2 和 (n+1)/2 保证不重复和不漏掉元素

### 240. 搜索二维矩阵 II

- 遍历 + 二分查找

## 链表

### 160. 相交链表

- 通过哈希表解决
- 通过双指针解决

### 206. 反转链表

- 原地反转，并没有什么困难的

### 141. 环形链表

- 通过快慢指针解决问题

### 142. 环形链表 II

- 可以通过快慢指针解决，但是感觉没有必要。
- 我是通过哈希表实现的。

### 21. 合并两个有序链表

- 通过迭代实现

### 2. 两数相加

- 通过模拟实现，要注意一个链比较长的情况。

### 19. 删除链表的倒数第 N 个结点

- 方法一：计算长度，然后删除对应节点
- **快慢指针**到底是什么方法，为什么这么多链表的问题都能解决。

### 24. 两两交换链表中的节点

- 通过模拟的方式实现的 | 在于让别人信任你。

### 25. K 个一组翻转链表

- 困难
- 方法一：模拟 + reverse + 处理特殊情况

### 138. 随机链表的复制（忘记了，未完全解决）

- 深拷贝重新构建，可以通过 map 去记录 random 的节点，然后重新构建。

## 二叉树

## 图论

## 回溯

## 二分查找

## 栈

### 739. 每日温度

- 通过单调栈解决问题，< == > 三种情况

## 堆

## 贪心算法

## 动态规划

## 多维动态规划

## 技巧
