1. 笔试
2. 自我介绍
3. 项目介绍
	1. 介绍项目的具体详情，为什么要写这个项目，具体是怎么实现的
	2. 挑一个项目详细介绍一下 背景、遇到了什么问题、你是怎么解决的
	3. 说一下你觉得你项目中的难点，或者最有价值的东西
	4. 主要工作，遇到的困难
	5. 一些细节问题，改进方案
	6. 代理服务的默认端口？（第一次听说代理还有默认端口）
	7. 页面解析用的什么？
	8. 爬虫比较困难的场景？
	9. 纯 js 渲染的页面怎么爬？

## 深维智讯 2.27（OC 已拒）

笔试 1h：逻辑题、语言特性、三大件、算法题  
面试 1h：  
自我介绍  
项目选一个介绍  
项目提问

**MySQL 事务隔离级别**  

- 未提交读
- 已提交读 RC
- 不可重复读 RR
- 串行化

**覆盖索引**

- 覆盖索引指的是命中的索引是联合索引，不需要回表进行查询。这样可以减少一次回表，性能更高。

**SQL 执行慢，如何排查**

- 可以通过通过开启慢查询日志查询
- 可以通过 explain 看 SQL 的执行计划、是否命中索引、是否全表烧苗、各个操作的成本估算。

当遇到 SQL 查询执行缓慢的问题时，可以采取以下步骤进行排查和优化：

1. **检查查询计划**：
   - 使用 `EXPLAIN` 或者 `EXPLAIN ANALYZE` 命令查看 SQL 查询的执行计划。这可以帮助你理解数据库如何执行你的查询，包括它是如何使用索引的，是否有全表扫描，以及各个操作的成本估算。
2. **优化查询语句**：
   - **简化查询**：尝试简化查询逻辑，避免复杂的子查询，可以考虑将复杂查询拆分成多个简单查询。
   - **减少数据量**：尽量减少查询返回的数据量，比如通过具体的条件过滤不必要的记录，使用 LIMIT 限制返回的行数。
   - **使用索引**：确保你的查询能够有效地利用索引。没有被索引的列在进行搜索时会导致全表扫描，极大地影响性能。
3. **数据库索引优化**：
   - **添加或调整索引**：根据查询计划中的信息，确定是否需要为某些列添加索引。同时，注意不要过度索引，因为这会增加写操作的成本。
   - **索引维护**：定期维护索引，比如重建或重新组织索引，以确保查询效率。
4. **服务器和硬件资源检查**：
   - **资源瓶颈**：检查数据库服务器的 CPU、内存、磁盘 I/O 是否有瓶颈。高负载或资源饱和可能会导致查询执行缓慢。
   - **配置优化**：调整数据库服务器的配置设置，如内存分配、缓存大小等，以适应实际的工作负载。
5. **查询分析器和监控工具**：
   - 使用数据库提供的查询分析器和监控工具来收集和分析性能数据。这些工具可以帮助你发现慢查询，分析数据库的性能瓶颈。
6. **数据库表结构优化**：
   - **归档旧数据**：定期清理或归档旧数据，减少表的大小，可以提升查询性能。
   - **表分区**：对于非常大的表，考虑使用分区技术，将数据分布到多个物理分区中，以提高查询效率。
7. **避免锁争用**：
   - 确保查询不会因为与其他事务的锁争用而被阻塞。分析和优化事务的设计，减少长事务，合理使用事务隔离级别。

**B+ 树和跳表的查询的时间复杂度**

O(logn)

**Redis 持久化** #不懂

1024&1023

**三次握手四次挥手**

在面试中解释 TCP 的三次握手和四次挥手时，你可以按照以下结构进行回答：

TCP 三次握手（连接建立）

三次握手（Three-way Handshake）的目的是可靠地建立两个 TCP 主机之间的连接。它包括以下步骤：

1. **SYN**：客户端发送一个 SYN（同步序列编号）报文到服务器，并进入 SYN_SEND 状态，等待服务器确认。
2. **SYN-ACK**：服务器接收到客户端的 SYN 报文，回送一个 SYN-ACK（同步确认应答）报文，确认收到了客户端的 SYN。同时，服务器将自己的 SYN 报文发送给客户端。服务器进入 SYN_RECV 状态。
3. **ACK**：客户端收到服务器的 SYN-ACK 报文后，会发送一个 ACK（确认）报文，当服务器接收到这个 ACK 报文时，连接建立成功。

这个过程主要是为了确认双方的接收和发送能力都是正常的。

TCP 四次挥手（连接释放）

四次挥手（Four-way Handshake）的目的是可靠地关闭两个 TCP 主机之间的连接。它包括以下步骤：

1. **FIN**：当主机完成数据发送后，会发送一个 FIN（结束）报文给对方，并进入 FIN_WAIT_1 状态。
2. **ACK**：接收方收到 FIN 报文后，会发送一个 ACK 报文给发送方，并进入 CLOSE_WAIT 状态。发送方收到 ACK 后，进入 FIN_WAIT_2 状态。
3. **FIN**：接收方准备好关闭连接时，发送一个 FIN 报文给发送方，并进入 LAST_ACK 状态。
4. **ACK**：发送方收到这个 FIN 后，发送一个 ACK 报文给接收方，然后进入 TIME_WAIT 状态。经过一段时间后，确保对方收到 ACK 报文，发送方关闭连接。接收方收到 ACK 后立即关闭连接。

这个过程中涉及四次挥手是因为 TCP 是全双工模式，双方都需要单独关闭自己的发送和接收通道。

补充说明

- 在三次握手中，第三次握手是确认双方的接收能力和发送能力都正常。
- 在四次挥手中，需要四步是因为当一方完成数据发送后，还需要确保对方所有的数据都接收完毕才能完全关闭连接，而且 TCP 连接是全双工的，每个方向都必须单独进行关闭。

正确理解并能够清晰表述这两个过程对于理解 TCP 协议的可靠性机制非常重要。

**Time-Wait 和 Closed-Wait**

在 TCP 协议中，`TIME-WAIT` 和 `CLOSE-WAIT` 是两种不同的状态，它们出现在 TCP 连接的生命周期中的不同阶段，主要涉及连接的终止过程。下面是这两个状态的详细解释：

**TIME-WAIT** 状态

- **定义**：`TIME-WAIT` 状态发生在 TCP 四次挥手过程的最后阶段。当一个 TCP 连接正在关闭，并且主动关闭连接的一方（通常是客户端）发送了最后一个 ACK 响应后，它会进入 `TIME-WAIT` 状态。
  
- **目的**：
  - 确保最后一个 ACK 报文能够到达对方。如果对方没有收到这个 ACK，它会重新发送 FIN 报文，`TIME-WAIT` 状态的一方应该对此做出响应。
  - 允许旧的重复分段在网络中消失。这样可以避免在新的连接中出现旧连接的数据包，确保下一个连接是干净的。
- **持续时间**：这个状态通常会持续 2 倍的 MSL（Maximum Segment Lifetime，最大报文生存时间），MSL 通常假定为 2 分钟，因此 `TIME-WAIT` 状态通常持续 4 分钟。

**CLOSE-WAIT** 状态

- **定义**：在 TCP 四次挥手过程中，当被动关闭连接的一方（通常是服务器）收到对方发送的 FIN 报文，确认对方要求关闭连接后，它会发送 ACK 响应并进入 `CLOSE-WAIT` 状态。
- **目的**：`CLOSE-WAIT` 状态表示等待本地应用程序关闭连接。在这个状态下，TCP 连接的这一端知道对方想要关闭连接，但在它可以发送自己的 FIN 报文之前，需要等待本地应用程序决定完成剩余的数据发送并正式关闭连接。
- **行为**：在 `CLOSE-WAIT` 状态下，应用程序应该**继续读取**任何到达的数据，并最终**调用关闭连接**的操作。完成这些操作后，它会发送 FIN 报文给对方并进入 `LAST-ACK` 状态，等待对方的最后一个 ACK 响应。

区别总结

- `TIME-WAIT` 是主动关闭连接方的一个状态，保证连接被平滑地关闭，避免在网络中的旧数据包影响新连接。
- `CLOSE-WAIT` 是被动关闭连接方的状态，**等待本地应用程序关闭连接**。

正确管理这些状态对于维护 TCP 连接的可靠性和性能至关重要。尤其是在高性能网络应用中，理解这些状态如何影响资源利用和连接管理非常重要。

**chmod751**

Owner Group Others  
读 写 执行

## 螣龙安科 2.28（OC 已拒）

**Redis string 底层** #不懂

**Gin 特性**

Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。它是一个类似于 martini 但拥有更好性能的 API 框架，由于使用了 **httprouter**，性能提升显著。Gin 是处理高性能请求的理想选择。以下是 Gin 的一些显著特性：

1. **快速**：Gin 使用了自定义的 HTTP 路由器，它比 Go 的标准库、mux 和其他路由器更快。其性能接近原生 HTTP 处理。
2. **轻量级**：Gin 提供了最基础的、核心的功能，避免了额外的库和依赖，使得框架保持简洁和轻量。
3. **中间件支持**：Gin 支持中间件，允许用户在处理请求和响应之前或之后执行代码，非常适合处理日志、用户认证、数据校验等任务。
4. **错误管理**：Gin 提供了一种便捷的方式来集中处理请求过程中发生的错误。
5. **路由分组**：支持路由分组功能，能够共享相同的路径前缀、中间件等，这对于构建具有共同 URL 前缀的路由集合非常有用，例如 API 版本管理。
6. **JSON 验证**：Gin 提供了结构体绑定和验证的功能，支持绑定 JSON、XML 和标准表单值等数据，并且可以对绑定的数据进行验证。
7. **模板渲染**：内置模板渲染功能，支持 HTML、XML、JSON 等格式的响应，方便构建不同的 Web 应用。
8. **高度可定制**：Gin 的设计允许高度的定制，包括自定义中间件、绑定器、渲染等。
9. **强大的性能与内存优化**：Gin 经过了精心优化，旨在减少内存分配，提高处理速度，使其成为构建高性能应用的理想选择。
10. **社区支持**：Gin 拥有活跃的社区和大量的外部库，方便开发者扩展功能和解决问题。

Gin 通过提供简洁的 API、出色的性能和高度的可扩展性，成为了 Go 开发者构建 web 应用和微服务的热门选择。

**sync.map** [[../../../Coding/Go/深入理解go/Go Map 原理|Go Map 原理]]

**JWT 单点登录**  

[[../../../Course/极客时间/初级 Golang 工程师/03 Session 和 JWT|03 Session 和 JWT]]

**Slice 并发访问**

**Slice 扩容**

**map 底层实现 B 的作用** [[go map]]

**MySQL 事务**

事务提及如何保证一致性

BufferPool

口述算法：

**三数之和**

**最长回文子串**

## 好未来 2.28 一面

mysql：

事务隔离级别、索引优化、查看 SQL 使用索引 (explain)

redis：

数据类型

String 和 Hash 区别

过期策略

如何让一个 key 过期

主要结合项目拷打 redis、mysql

作者：池敖池恩  
链接：[https://www.nowcoder.com/discuss/593098900697788416?sourceSSR=post](https://www.nowcoder.com/discuss/593098900697788416?sourceSSR=post)  
来源：牛客网

## 好未来 Go 实习面经 （挂）

处女面，双非 无实习 区域铜。2.29 技术面主管面 hr 面。3.4 挂。  
无项目问题（6.824，简单微服务，xv6），无算法问题，这是 kpi 吗？kpi 为啥还有 hr 面。  

1. map 是否线程安全  
2. **gin 框架大致原理**   
3. 进程线程协程，如何实现协程  
4. mysql 事务隔离级别  
5. 可重复读和读已提交差别，举例说明，简单讲了 mvcc  
6. 可重复读不适用场景  
7. 幻读问题  
8. 联合索引  

场景题：  

1. 分数和年龄两个字段，联合索引顺序。  
2. redis 排行榜

作者：haria_  
链接：[https://www.nowcoder.com/feed/main/detail/8156f85cafb44b97b8b7fe65732f09b9?sourceSSR=search](https://www.nowcoder.com/feed/main/detail/8156f85cafb44b97b8b7fe65732f09b9?sourceSSR=search)  
来源：牛客网

本人 25 届，目前收到快手电商 Java 实习的正式 offer，base 杭州。百度网盘商业化 Golang 实习口头 offer（开始走流程），base 北京。本人是 Java 技术栈为主，觉得以后秋招也是以 Java 技术栈为主，但是感觉百度的 title 会不会更好一些。想听听各位牛友的建议  

作者：junzuoguan  
链接：[https://www.nowcoder.com/feed/main/detail/a740c67812094f588d9977dbbcc3e54a?anchorPoint=comment](https://www.nowcoder.com/feed/main/detail/a740c67812094f588d9977dbbcc3e54a?anchorPoint=comment)  
来源：牛客网

## 滴滴地图三面速通

一面：  
实习项目  
**go 的 gin？go 服务？**  
连数据库用的哪个库  
**MySQL 的数据库的锁**  
锁触发条件/情况  
**go 的 GPM 模型简单介绍**  
**go 的垃圾回收**  
**进程和线程的区别**  
**进程间通信方式**  
**线程间通信方式**  
**常用的 Linux 命令**  

在 Linux 操作系统中，有许多常用的命令可以帮助您完成日常的文件管理、系统维护、网络配置、程序运行等各种任务。以下是一些最基础且常用的 Linux 命令及其简单描述：

1. **目录和文件操作命令：**
   - `cd`：改变当前工作目录。
   - `ls`：列出目录内容。
   - `pwd`：打印当前工作目录的绝对路径。
   - `mkdir`：创建新的目录。
   - `rmdir`：删除空目录。
   - `rm`：删除文件或目录（使用 `-rf` 参数可递归删除非空目录）。
   - `cp`：复制文件或目录。
   - `mv`：移动或重命名文件和目录。
   - `touch`：创建新文件或更新已有文件的访问和修改时间。
   - `ln`：创建硬链接或符号链接。

2. **文件内容查看和编辑：**
   - `cat`：合并并打印文件内容到标准输出。
   - `less` 或 `more`：分页查看文件内容。
   - `head`：查看文件开头部分内容。
   - `tail`：查看文件结尾部分内容，`tail -f` 实时跟踪文件末尾变化。
   - `vim` 或 `nano` 或 `emacs`：文本编辑器，用于编辑文件内容。

3. **文件权限和所有权管理：**
   - `chmod`：更改文件或目录的权限。
   - `chown`：更改文件或目录的所有者。
   - `chgrp`：更改文件或目录所属的组。

4. **系统信息查询：**
   - `uname`：显示系统信息，如内核名称、版本等。
   - `uptime`：查看系统运行时间和负载情况。
   - `top` 或 `htop`：实时显示系统状态和进程资源占用情况。
   - `free`：查看内存使用情况。
   - `df`：报告文件系统的磁盘空间使用情况。
   - `du`：估算文件或目录所占磁盘空间大小。

5. **搜索文件和内容：**
   - `find`：根据名称、类型、大小、时间等条件搜索文件。
   - `grep`：在文件中搜索符合模式的行。

6. **压缩和解压缩：**
   - `gzip`、`gunzip` 或 `zcat`：gzip 压缩和解压。
   - `bzip2`、`bunzip2` 或 `bzcat`：bzip2 压缩和解压。
   - `tar`：打包和解包文件，支持多种压缩格式。

7. **网络和通信：**
   - `ping`：测试网络连通性。
   - `ifconfig`（旧版）或 `ip`（新版）：查看和配置网络接口。
   - `netstat`（旧版）或 `ss`（新版）：显示网络连接、路由表等信息。
   - `curl` 或 `wget`：从互联网下载文件。

8. **进程控制：**
   - `ps`：报告当前系统中进程的状态。
   - `top` 或 `htop`（增强版）：动态查看和管理进程。
   - `kill` 或 `pkill`：结束进程。
   - `jobs`：查看当前 shell 环境下已启动的任务列表。
   - `fg` 或 `bg`：将后台任务调至前台运行或恢复后台运行。

9. **软件安装和包管理：**
   - 在 Debian/Ubuntu 系列中：`apt-get` 或 `apt`。
   - 在 CentOS/RHEL/Fedora 系列中：`yum` 或 `dnf`。

10. **其他常用命令：**
    - `man`：查看命令的手册页。
    - `history`：查看历史命令记录。
    - `clear` 或 `Ctrl + L`：清屏。
    - `echo`：输出字符串或变量值。
    - `alias`：设置命令别名。

以上只列举了一部分常见命令，实际使用的命令远不止这些，具体使用时可根据需要查阅更详细的命令手册。

**队列和栈的区别**  
图的了解  
图上两点的最小距离何种算法  

- Dijkstra 算法和 Floyd 算法

goroutine 中有哪几种锁  

**手撕：快排**  

二面：  
论文项目介绍  
实习项目介绍  
更新缓存数据场景的应对  
**go 中多态的实现**  
定位是偏网络 数据库 还是 Web  
Web 框架的使用  
**gin 对于用户登录态的处理**  

在 Gin 框架中，处理用户登录态通常涉及到 session 或者 token 的管理。以下是一种基于 JWT（JSON Web Tokens）的处理方式：

1. 用户登录时，验证用户名和密码是否正确。如果正确，服务器生成一个 JWT，这个 JWT 包含了用户的唯一标识符以及其他可能需要的信息，并且设置了过期时间。然后将 JWT 通过 HTTP Header 或 Cookie 返回给客户端。

```go
import (
    "github.com/gin-gonic/gin"
    "github.com/dgrijalva/jwt-go"
)

func login(c *gin.Context) {
    var user User // 假设 User 是你的用户模型结构体
    if err := c.ShouldBind(&user); err == nil {
        // 验证用户名和密码逻辑...
        if ok := validate(user.Username, user.Password); ok {
            token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "username": user.Username,
                "exp":      time.Now().Add(time.Hour * 24).Unix(), // 设置 token 过期时间为24小时
            })
            tokenString, _ := token.SignedString([]byte("your_secret_key")) // 签名并生成 token 字符串
            c.JSON(200, gin.H{
                "token": tokenString,
            })
        } else {
            c.JSON(401, gin.H{"error": "Invalid username or password"})
        }
    } else {
        c.JSON(400, gin.H{"error": "Invalid request body"})
    }
}
```

1. 客户端在后续请求中，将 JWT 放在 Authorization 请求头中（通常是 Bearer 模式），发送给服务器。
2. 服务器在每个受保护的路由中间件中，解析并验证 JWT，验证通过则继续执行后续操作，否则返回未授权错误。

```go
func authenticateMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.AbortWithStatusJSON(401, gin.H{"error": "Unauthorized"})
            return
        }

        tokenString := strings.Replace(authHeader, "Bearer ", "", 1)
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
            if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
                return nil, fmt.Errorf("Unexpected signing method: %v", token.Header["alg"])
            }
            return []byte("your_secret_key"), nil // 这里应使用与签发时相同的密钥
        })

        if err != nil {
            c.AbortWithStatusJSON(401, gin.H{"error": "Unauthorized"})
            return
        }

        if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
            // 获取到的 claims 可以用于获取用户信息或进行其他权限校验
            username := claims["username"].(string)
            // ...
        } else {
            c.AbortWithStatusJSON(401, gin.H{"error": "Unauthorized"})
        }
        
        c.Next()
    }
}

// 使用中间件
router.GET("/protected", authenticateMiddleware(), func(c *gin.Context) {
    // ...
})
```

注意：上述代码仅作示例用途，请根据实际需求调整并确保安全性，如对 secret key 的安全存储和使用等。同时，JWT 不适合存储过于敏感的数据，因为它在传输过程中是明文的，尽管可以被签名但不能被加密。对于非常敏感的信息，建议结合 HTTPS 和后端数据库一同处理。

用户态的管理，用户登录态的保持  
多个进程（含同名进程）全部杀掉的 Linux 命令  

三面：  
**项目中遇到的一个有挑战的技术问题，如何解决的，解决思路**  

- 索引优化、性能优化等等功能，高并发的场景

**B+ 树索引**  

B+ 树（B-plus Tree）是一种广泛应用于数据库和文件系统中用于索引的数据结构，尤其在关系型数据库管理系统如 MySQL 中扮演着关键角色，它优化了磁盘 I/O 密集型环境下的数据检索性能。  

**B+ 树的主要特点**

1. **层级结构**：B+ 树是一个自平衡的多路搜索树，它的每个节点包含多个键和对应数量的指针。B+ 树的阶表示每个节点最多有多少个孩子，它决定了树的扇出度（即每个节点可以有多少个子节点）。相比 B 树，B+ 树的每个节点通常能存储更多的键值对和指针，从而使得树的高度更低，减少了磁盘 I/O 次数。
2. **叶节点存储数据**：在 B+ 树中，所有的数据都存储在叶子节点上，而非叶子节点仅存储索引（键值对），并不直接保存实际的数据行。并且，所有叶子节点形成了一个有序链表，这样有利于范围查询和全表扫描。
3. **高扇出性**：B+ 树的节点具有较高的扇出性，这意味着在一个节点内可以存储大量的键值和指针，从而保证即使数据量很大，树的高度也能维持在较低水平，通常在 2 到 4 层之间，这对于减少磁盘寻址的 I/O 次数至关重要。
4. **聚簇索引与辅助索引**：
   - **聚簇索引**（Clustered Index）：在 InnoDB 存储引擎中，主键索引采用的就是聚簇索引，数据行的实际内容就储存在叶子节点上，按照主键的顺序排列。因此，一张表只有一个聚簇索引，它决定数据行的物理存储顺序。
   - **辅助索引**（Secondary Index，又称非聚集索引）：除了主键索引外的其他索引都是辅助索引，它们的叶子节点存储的是相应键值以及对应的主键值，而不是实际的行数据。
5. **范围查询友好**：由于所有叶子节点形成连续的有序链表，对于需要范围查询的情况，B+ 树只需要沿着叶子节点的链表顺序扫描即可，无需像 B 树那样回溯父节点，大大提高了效率。

总结来说，B+ 树索引的设计理念是为了最大化地利用外部存储（如磁盘）的特点，通过合理的数据分布和组织形式，使得数据读取更加高效，尤其适合大量数据和频繁的查询操作场景。  

wgs84  

WGS84（World Geodetic System 1984）是一种全球大地坐标系标准，由美国国防部研制并在 1984 年确定，被广泛应用于地理信息系统、航空航海、测绘、GPS 全球定位系统等领域。它是目前国际上公认并普遍采用的地心坐标系统之一。

在 WGS84 坐标系中，主要特点包括：

- 原点位于地球质心。
- Z 轴指向国际时间局（BIH）在 1984.0 定义的协议地球极（CTP）方向，即地球自转轴在某一特定时刻的方向。
- X 轴指向 BIH1984.0 的零度子午面（Prime Meridian）和 CTP 赤道的交点，也即是国际本初子午线穿过赤道的地方。
- Y 轴通过右手定则确定，从而构成右手直角坐标系。

WGS84 还包括了一个地球参考椭球体模型，用来逼近地球的形状，并提供了精确的参数来描述地球表面的几何特征。这一模型被用于计算地理位置的经纬度坐标、海拔高度以及相关空间位置的转换。

随着时间的推移，WGS84 经历了多次修订，以改进其精度，每一次修订都会产生一个新的版本，例如通过 GPS 卫星网络收集数据来进行细微修正。由于其与 GPS 系统的紧密联系，WGS84 成为现代导航、定位和遥感应用的基础坐标框架。

**谷歌卫星影像数据的组织形式，如何覆盖一个地球以及缩放**  
**缓存预热方案的背景与解决方案**  

所谓缓存预热，就是提前把数据库里的数据刷到缓存里，通常有这些方法：

1. 直接写个缓存刷新页面或者接口，上线时手动操作
2. 数据量不大，可以在项目启动的时候自动进行加载
3. 定时任务刷新缓存

缓存预热（Cache Priming）是在缓存系统中的一种策略，主要是指在应用程序启动之初或者在服务可用之前，预先将一些重要的、经常访问的数据加载到缓存系统中，以便当用户发起请求时可以直接从缓存中获取数据，而不是等到有请求到达时才触发缓存填充，这样可以显著提升系统的响应速度和服务质量。

背景：

- **性能优化**：对于依赖缓存提供高性能的服务而言，首次请求时如果数据不在缓存中，就需要从持久化存储（如数据库）中加载，这通常比从缓存中读取慢得多，可能导致延迟增加和系统负载突增。
- **高峰时段应对**：在高峰期到来之前进行缓存预热，可以防止大量并发请求在同一时间尝试加载相同数据而造成的“缓存雪崩”现象，保证服务稳定性。
- **热点数据**：对于那些访问频度极高或者重要性极强的热点数据，必须确保它们始终存在于缓存中，以提供近乎实时的服务体验。

解决方案：

1. **手动预热**：开发人员编写专门的脚本或页面，在服务部署或重启后手动触发加载关键数据到缓存。
2. **自动预热**：
   - **项目启动时预加载**：应用程序初始化阶段，可以通过监听启动事件，自动化加载高频访问的数据到缓存中。
   - **定时任务**：设定定时任务，在固定时间段或周期性地将预期会访问的数据加载到缓存。
   - **事件驱动**：基于业务逻辑，当发生某些事件（如数据库数据变更）时触发预热操作。
3. **增量预热**：只预热最近新增或更新的数据，而不是每次全部重新加载。
4. **全量预热**：适用于数据量相对较小的情况，在系统启动时一次性加载所有缓存数据。
5. **分布式缓存预热**：对于大型分布式系统，可能需要设计复杂的分布式缓存预热策略，确保多个节点上的缓存同步和有效预加载。
6. **API Gateway 预热**：在 API Gateway 层面设计预热策略，当流量入口感知到服务启动或配置变更时，主动发起预热请求。
7. **监控和智能预热**：结合监控工具和 AI 算法预测哪些数据可能会变成热点数据，并提前进行预热，实现智能化管理缓存。

总之，缓存预热的具体实现方式会根据应用场景、数据量、系统架构等因素的不同而有所差异，目标是让缓存系统能在真正开始服务时处于准备就绪的状态。

**Redis 数据如何做淘汰**  

Redis 数据淘汰策略（ eviction policy）是在 Redis 内存使用达到用户预设的 `maxmemory` 上限时触发的一种机制，用于在内存不足时自动删除部分数据以腾出空间。Redis 提供了多种淘汰策略供用户选择，以下是其中几种主要的淘汰策略：

1. **volatile-lru**：仅针对设置了过期时间（TTL）的键进行淘汰，通过 LRU（Least Recently Used）算法来选择最近最少使用的键进行删除。
2. **allkeys-lru**：对所有键（包括没有设置过期时间的键）使用 LRU 算法淘汰。
3. **volatile-lfu**：仅针对设置了过期时间的键，使用 LFU（Least Frequently Used）算法淘汰访问频率最低的键。
4. **allkeys-lfu**：对所有键使用 LFU 算法淘汰。
5. **volatile-random**：随机淘汰设置了过期时间的一个键。
6. **allkeys-random**：随机淘汰任意一个键，无论其是否有过期时间。
7. **volatile-ttl**：优先淘汰即将过期的键，也就是说，根据键的剩余生存时间（TTL）进行淘汰，生存时间越短的键越先被淘汰。
8. **noeviction**（默认策略）：不允许任何数据被驱逐，当内存满时，所有引起更多内存分配的操作都会返回错误，除非是 DEL 或者 UNLINK 这样的删除操作。

选择合适的淘汰策略需要根据您的应用特性和数据访问模式来决定。在 Redis 配置文件中（如 redis.conf），通过设置 `maxmemory-policy` 参数来指定使用哪种淘汰策略。一旦达到 `maxmemory` 限制，Redis 就会依据所选策略开始淘汰数据。

**Redis 中的 Key 如何设计**

在 Redis 中设计 Key 是至关重要的，因为良好的 Key 设计可以提升数据查询效率、节省存储空间并简化维护。以下是一些建议和最佳实践：

1. **命名规范**：
   - **简洁明确**：Key 应该尽可能简短，减少网络传输开销，同时易于理解和记忆。例如，`user:1234:name` 表示用户 ID 为 1234 的用户名信息。
   - **有意义**：Key 应该能够表达其存储的内容，遵循一定的命名约定，例如使用冒号（:`）、破折号（-）或下划线（_）分隔字段，便于阅读和理解。
   - **统一前缀**：为不同类型的数据添加统一前缀，如 `user:`, `order:`, `session:` 等，方便分类管理和批量操作。
2. **结构化设计**：
   - **嵌套结构**：对于关联性强的数据，可以考虑使用 Hash 结构，比如 `user:1234` 作为一个 Hash 键，内部包含多个字段如 `name`, `email` 等。
   - **集合和列表**：若数据需要按集合或列表存储，如用户关注列表，可以设计为 `followers:1234`。
3. **过期时间**：
   - 对于临时或有生命周期的数据，如 Session、验证码等，设置合适的过期时间（TTL）非常重要，避免内存中积累大量无用数据。
4. **大小控制**：
   - 注意 BigKey 问题，避免单个 Key 的 Value 过大（例如大于几兆字节），以免影响 Redis 性能和网络带宽。
   - 使用合适的 Redis 数据结构（如 Set、Sorted Set 等）替代大体积的 String 类型，降低存储成本。
5. **扩容与分区**：
   - 如果应用需要横向扩展，考虑在 Key 设计时加入分片标识，使数据均匀分布在多个 Redis 实例中。
6. **避免热点 Key**：
   - 避免所有客户端都频繁访问同一 Key，如果不可避免，可以考虑使用 Lua 脚本减少网络往返次数。
7. **事务与批处理**：
   - 在设计 Key 时考虑到原子操作和批处理的需求，比如使用 pipeline 或 multi/exec 事务。
8. **冗余与一致性**：
   - 根据业务需求，可能需要设计带有备份或镜像功能的 Key，例如使用 Redis 主从复制或集群。
9. **删除策略**：
   - 适时地清理不再使用的 Key，尤其是在有限内存场景下，配合 Redis 的淘汰策略。

综上所述，设计 Redis Key 的关键是兼顾可读性、易维护性、性能优化及资源利用率。同时，还要结合具体的业务场景和技术要求做出合理的选择。

Redis 具体设计的原理  

Redis 的设计原理可以从以下几个核心方面进行详细说明：

1. **内存数据库**：
   - Redis 是一个纯内存数据库，它将所有数据存储在内存中，以此实现快速的数据读写操作。内存存储意味着读写速度接近于处理器的速度，相较于传统的硬盘存储，大幅度提升了性能。
2. **数据结构丰富**：
   - Redis 不仅仅是一个简单的键值存储系统，它支持五种基本数据结构：字符串（Strings）、列表（Lists）、集合（Sets）、有序集合（Sorted Sets）和哈希表（Hashes）。这些数据结构提供了丰富多样的操作，例如列表的 push/pop、集合的交并差运算、有序集合的范围查找等，满足多种业务场景需求。
3. **单线程模型**：
   - 采用了单线程事件驱动模型，所有客户端请求都在同一个线程中顺序执行。虽然看似单线程限制了并发能力，但由于数据在内存中，不存在传统数据库磁盘 I/O 瓶颈，所以单线程足以充分利用 CPU 并发处理网络请求。同时，单线程避免了锁竞争，简化了编程模型，提高了系统的稳定性和性能。Redis
4. **异步持久化**：
   - Redis 提供两种持久化机制，分别是 RDB（Redis Database）和 AOF（Append Only File）：
     - RDB：通过定时快照的方式将内存中的数据保存到磁盘上，是一种周期性全量持久化的方法，**适合灾难恢复场景**。
     - AOF：记录每一个写命令到日志文件中，当 Redis 重启时再重新执行这些命令来重建数据，支持多种不同的持久化策略和日志重写优化，可以实现更高的数据安全性。
5. **网络模型**：
   - Redis 使用了基于 Reactor 模式的网络库，如 **epoll**（Linux）或 kqueue（BSD/Mac OS X），能够高效地处理大量并发连接，支持非阻塞 I/O。
6. **复制与高可用**：
   - Redis 支持主从复制（Replication），主节点的数据会异步复制到从节点，从而实现数据的备份和故障转移。
   - Redis Sentinel（哨兵）系统提供了自动化的故障检测和恢复，能够选举新的主节点，保持 Redis 集群的高可用性。
   - Redis Cluster 则实现了数据的分布式存储和管理，通过分片（Sharding）技术分散数据压力，支持线性水平扩展。
7. **Lua 脚本与事务**：
   - Redis 支持在服务器端执行 Lua 脚本，可以在服务器端一次执行多个命令，保证原子性和减少网络延迟。
   - Redis 的事务支持多条命令的一次性执行，采用 Multi/Exec 模式，但需要注意的是 Redis 的事务不保证严格的 ACID 特性，而是提供一种简单的命令序列执行。
8. **性能优化**：
   - Redis 自身实现了多种优化技术，包括高效的内存管理、数据结构的紧凑存储、字典的渐进式 rehash 等，最大限度地减少内存消耗和 CPU 开销。

以上是 Redis 的几个主要设计原理，这些特性共同构成了 Redis 高性能、低延迟、持久化、高可用的 NoSQL 数据存储系统。

timeline:10.9 投递 -10.12 三面速通 -12.15OC-12.19offer

作者：99 小菜鸡  
链接：[https://www.nowcoder.com/feed/main/detail/10340b068c664dc7b4a6155609de5e72?sourceSSR=search](https://www.nowcoder.com/feed/main/detail/10340b068c664dc7b4a6155609de5e72?sourceSSR=search)  
来源：牛客网

## 简历怎么写

- [看看一份标杆简历的分析（建议收藏）_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/566984772325515264?sourceSSR=search)

## 寄了！，有请下一位天才中单

### 百度后端实习 一面凉经

15min

### 自我介绍 + 问项目

数据库表是怎么建的，数据读取流程是怎么样的

redis 用到了那些结构，是怎么保持数据一致性的

我看你有整合日志，你是怎么对日志分级的

怎么串联起日志的上下游（不会）

25 Min

### Golang 基础

**slice 和 array 的区别**

Go 语言中的数组（Array）和切片（Slice）都是用于存储一组元素的数据结构，但在很多方面有着明显的区别：

1. **固定长度 vs 动态长度**：
   - 数组：数组是具有固定长度的，一旦声明，其长度就不能改变。例如 `var arr [5]int` 表示一个包含 5 个整数的数组。
   - 切片：切片则是动态长度的，可以追加元素或者收缩容量，其内部实际上是对数组的一个引用窗口，可以自由改变切片的长度和容量。
2. **声明与初始化**：
   - 数组：在声明时必须指定长度，并且可以初始化所有元素，例如 `var arr [5]int = [5]int{1, 2, 3, 4, 5}`。
   - 切片：声明时不需指定长度，甚至可以不指定容量，例如 `var sli []int`。切片可以使用 make 函数创建，如 `sli := make([]int, 0, 5)`，这里创建了一个初始长度为 0，容量为 5 的切片。
3. **容量与增长**：
   - 数组：数组的容量就是它的长度，无法自动增长。
   - 切片：切片有一个长度和容量的概念，当向切片追加元素超出长度但未达到容量时，会自动增长（默认翻倍并预留一定数量的空间），可通过 `append` 函数实现。
4. **底层数据共享**：
   - 当切片是对数组的一部分引用时，两者共享同一段底层数组。对切片的修改会影响到原数组。
5. **赋值与传递**：
   - 数组赋值是值传递，意味着复制整个数组。
   - 切片赋值是引用传递，复制的是切片结构本身，但它们仍然共享相同的底层数组，因此修改其中一个切片可能会影响另一个。

总的来说，数组更适合知道确切大小且不需要动态增长或收缩的场合；而切片在大多数场景下更实用，尤其是需要动态操作序列长度的时候。

**slice 的扩容过程**

Go 语言中的切片（slice）在容量不足时会自动进行扩容。扩容的过程可以概括为以下几个步骤：

1. **判断是否需要扩容**：  
   当调用 `append` 函数尝试向切片追加元素，且当前切片的容量（cap）不足以容纳新元素时，Go 会触发扩容操作。
2. **计算新容量**：
   - 在旧容量（cap）小于等于 1024 个元素时，扩容后的容量一般会翻倍，也就是新容量为旧容量的 2 倍。
   - 当旧容量超过 1024 个元素时，扩容的增长因子变为大约 1.25 倍（实际上是 `oldCap * 2 / 3 + oldCap / 4`，也就是大约 1.5 倍，但实际比例略低于此）。
   - 新版本的 Go 可能会对扩容策略进行微调，具体细节需要查阅最新的官方文档或源代码。
3. **分配新内存**：  
   Go 运行时会分配一块新的、足够大的内存区域来存放扩容后的数据。
4. **复制旧数据**：  
   将旧切片中的元素复制到新分配的内存区域。
5. **更新切片元信息**：  
   更新切片结构（header）中的指针和容量信息，使其指向新的内存区域，并更新容量值。
6. **追加新元素**：  
   在扩容后的新内存区域追加新元素，此时切片的长度（len）会增加。

需要注意的是，扩容操作的目的是尽量避免频繁的内存分配和数据迁移，所以在实际扩容时会尽量增大新容量以适应未来可能的连续追加操作，同时也考虑到了内存分配的效率和内存浪费之间的平衡。随着 Go 语言的发展，其内部的扩容策略可能会有微调以优化性能表现。

**大切片和小切片的耗时是一样的吗**

在 Go 语言中，操作切片（不论是大切片还是小切片）的时间复杂度主要取决于操作本身的性质，而不是切片的大小。例如，遍历一个切片（无论是大是小）的时间复杂度通常是 O(n)，n 代表切片的长度。

**defer 的执行流程，顺序** defer 八股文 —— **课程中有的**

在 Go 语言中，`defer` 语句用于在函数执行完成后（无论是正常返回还是抛出异常）延后执行某个函数调用。`defer` 的执行流程和顺序遵循以下规则：

1. **注册顺序**： 当函数执行过程中遇到 `defer` 语句时，被 `defer` 修饰的函数会被压入一个延迟调用栈（Last In First Out，LIFO），也就是说，最后注册的 `defer` 语句首先被压入栈顶，最早注册的 `defer` 语句压在栈底。
2. **执行顺序**： 当函数即将返回时，不论函数是如何结束（无论是通过 `return` 语句、`panic` 引起的异常退出或是其他方式），都将按照栈底到栈顶的顺序，依次执行之前注册的 `defer` 函数。
3. **与 return 的关系**：
    - `return` 语句首先执行并计算返回值，但是实际的返回动作（即函数真正结束并返回给调用者）发生在所有 `defer` 函数执行完毕之后。
    - 即使在 `return` 语句之后还有 `defer` 函数，这些 `defer` 函数也会得到执行的机会。

### Mysql

**mysql 有哪些索引**  
**你项目里的 mysql 是怎么建索引的**  
**索引树的数据结构是什么样的**  
联合索引的流程，结构

联合索引（Composite Index 或 Multi-column Index）是数据库中对多个列同时建立的索引，它主要用于优化包含多个字段组合查询的性能。联合索引的流程和结构大致如下：

结构

联合索引的结构就像一个多维的有序数组或 B 树/B+ 树。以 MySQL 为例，假设我们有一个 `users` 表，包含 `first_name`、`last_name` 和 `age` 三个字段，并创建了一个联合索引 (`index_name`)，索引列顺序为 `(first_name, last_name, age)`：

1. **索引树结构**：
   - 联合索引的第一层根据 `first_name` 排序；
   - 第二层在相同 `first_name` 的情况下，根据 `last_name` 排序；
   - 第三层在相同 `first_name` 和 `last_name` 的情况下，根据 `age` 排序。

2. **索引键**：
   - 联合索引的键是由参与索引的所有列的值组成的，如 `(张, 三, 30)`。

流程

1. **创建联合索引**：

   ```sql
   CREATE INDEX index_name ON users (first_name, last_name, age);
   ```

2. **索引使用**：
   - 查询时，如果 WHERE 子句中包含了索引列的左边部分，那么数据库就可以有效地利用联合索引进行查询加速。例如：

     ```sql
     SELECT * FROM users WHERE first_name = '张' AND last_name = '三';
     ```

     此查询可以根据索引快速定位到结果。

3. **索引覆盖**：
   - 若查询涉及的所有列都在索引中，无需回表查询，这种现象称为索引覆盖。例如：

     ```sql
     SELECT first_name, last_name FROM users WHERE first_name = '张' AND last_name = '三';
     ```

4. **最左前缀原则**：
   - 联合索引的查询主要遵循最左前缀原则，即查询时至少要包含第一个索引列。例如，只查询 `last_name` 就无法利用此索引：

     ```sql
     SELECT * FROM users WHERE last_name = '三'; -- 无法利用索引
     ```

5. **索引优化**：
   - 在设计联合索引时，应当根据实际业务中查询的频繁程度和查询条件的组合来决定索引列的顺序。

**走索引和不走索引的流程**

在数据库查询过程中，走索引和不走索引的流程有所不同，以下是它们的基本流程对比：

走索引流程（使用索引查询）：

1. **查询阶段**：
   - 当查询条件中包含索引列时，数据库系统首先检查是否存在与查询条件相匹配的索引。
   - 如果找到相应的索引，数据库将通过索引树或索引表来查找数据，索引结构（如 B 树或 B+ 树）允许数据库系统快速定位到符合条件的数据所在的物理位置。
2. **索引查找**：
   - 根据索引的结构（如 B+ 树），数据库沿着索引树从根节点向下遍历，通过比较索引键值快速缩小搜索范围，最终找到匹配查询条件的索引记录。
   - 对于范围查询，数据库会在索引区间内进行遍历，而不是全表扫描。
3. **回表查询**（如果有需要）：
   - 如果索引是非覆盖索引（Index Scan without Covering），即查询结果需要包含索引之外的列，数据库在找到索引匹配项后，还需要回到主数据区（数据页）获取其他列的数据。
4. **返回结果**：
   - 数据库根据索引查找的结果，返回所需的记录集。

不走索引流程（全表扫描）：

1. **查询阶段**：
   - 当查询条件中没有合适的索引可用，或者数据库优化器判断全表扫描更为高效时，数据库将进行全表扫描操作。
2. **数据扫描**：
   - 数据库系统会逐行遍历表中的每一行记录，对每一行数据执行查询条件判断。
3. **筛选结果**：
   - 对每一行数据执行 WHERE 子句中的条件检查，保留符合查询条件的行。
4. **排序和分组（如有必要）**：
   - 如果查询中有 ORDER BY、GROUP BY 或 LIMIT 等子句，数据库需要对扫描得到的结果集进行排序或分组处理。
5. **返回结果**：
   - 数据库系统将过滤后的结果集返回给客户端。

总结

走索引的查询通常更快，因为它减少了需要处理的数据量，特别是在大数据表中。而不走索引的全表扫描效率较低，尤其是在数据量庞大的情况下，因为它需要遍历整个表的所有行。然而，数据库优化器会根据查询条件、表数据分布、索引的使用成本等因素综合决定是否使用索引。

mysql 的锁了解吗（只知道行锁）

MySQL 中的锁是数据库管理系统用于控制对数据并发访问的重要机制，旨在确保在多用户或多事务环境下数据的一致性和完整性。MySQL 支持多种类型的锁，主要包括以下几种：

1. **表级锁 (Table-level Locks)：**
   - **表锁**：锁定整个表，MyISAM 存储引擎默认采用表锁，开销小，加锁快，但并发能力较弱，不适合高并发写入的场景。
   - **意向锁 (Intent Locks)**：在 MySQL 中，对表加行锁前需要先获得意向锁，意向锁用来表明事务打算在表的某个部分（如行）上加锁。
2. **行级锁 (Row-level Locks)：**
   - **Record Locks**：锁定一行记录。
   - **Gap Locks**：锁定一个范围内的间隙，阻止其他事务在这个范围内插入新行。
   - **Next-Key Locks**：结合了 Record Locks 和 Gap Locks，锁定一个范围包括记录本身及其前面的间隙。
3. **页级锁 (Page-level Locks)**：
   - 有些存储引擎（如 InnoDB 在某些情况下）使用页级锁，锁定一个数据页内的所有记录。
4. **意向锁与其他类型的兼容性**：
   - 不同类型的锁之间有不同的兼容性，例如，多个事务可以同时获得表的意向读锁（意向共享锁，Intention Shared Lock, IS），但一个事务持有表的意向排他锁（意向独占锁，Intention Exclusive Lock, IX）时，其他事务不能获取表的任何其他锁。
5. **事务隔离级别与锁的关系**：
   - 不同的事务隔离级别（Read Uncommitted、Read Committed、Repeatable Read、Serializable）对锁的使用策略有所不同，尤其是 Repeatable Read 级别下，InnoDB 会默认使用 Next-Key Locks 来防止幻读。
6. **乐观锁 (Optimistic Locking) 与悲观锁 (Pessimistic Locking)**：
   - MySQL 还支持乐观锁策略，它不是真正的锁，**而是在数据版本**（如 MySQL 的 `SELECT … FOR UPDATE` 或 `SELECT … LOCK IN SHARE MODE`）或应用程序层面实现的一种并发控制机制。悲观锁则是事务在执行操作前就先锁定资源，防止其他事务干扰。
7. **自动增长 (Auto-Increment Locks)**：
   - 当插入新行并使用自动增长列时，会使用特殊的锁来保证序列值的唯一性和一致性。
8. **死锁检测与预防**：
   - MySQL 的 InnoDB 存储引擎具有死锁检测机制，当两个或多个事务相互等待对方持有的锁时，InnoDB 会识别并回滚一个事务以打破死锁循环。

通过合理使用和配置 MySQL 的各种锁机制，可以有效地管理并发事务间的冲突，确保数据在并发环境下的完整性和一致性。

行锁解决了哪些问题（不会）

行锁（Row-level Locks）主要解决以下在数据库并发访问中的问题：

1. **并发事务间的冲突**：
   - 多个事务同时更新同一条记录时，如果没有适当的锁机制，可能会导致数据不一致。例如，“丢失更新”（Lost Update）问题，其中一个事务对某行的修改可能会被另一个并发事务覆盖，破坏事务的隔离性。
   - 行锁确保当一个事务正在修改某行时，其他事务不能同时修改该行，从而避免了这类并发问题。
2. **避免长事务阻塞**：
   - 行锁相比于表锁，可以提供更细粒度的并发控制，减少锁的争抢。如果只是修改表中的个别行，行锁仅会阻塞对那些受影响行的访问，而不会阻塞对表中其他行的并发访问，降低了并发操作时的阻塞等待时间，提高了系统吞吐量。
3. **数据一致性**：
   - 行锁确保了事务在修改数据时，只有在锁释放后，其他事务才能看到修改的结果，这是事务 ACID 属性中的“隔离性”（Isolation）要求。通过行锁，可以实现可重复读（Repeatable Read）等事务隔离级别，避免了脏读（Dirty Reads）、不可重复读（Non-repeatable Reads）和幻读（Phantom Reads）等问题。
4. **提高并发性能**：
   - 在高并发环境下，行锁极大地提高了系统的并发处理能力，因为它允许多个事务同时处理不同的行数据，而不会互相阻塞。对于 OLTP（在线事务处理）系统，行锁的使用能够更好地满足频繁的小规模读写操作需求。

总之，行锁通过对数据库中最基本的数据单元——行进行锁定，能够在并发环境下保障数据的准确性和一致性，同时最大程度地减小了事务间的等待和冲突，提高了数据库系统的并发性能。

### Redis

**你项目里有用到 hash 吗，具体是什么样的**

Redis 的 Hash 是一种存储键值对的集合，它是 Redis 支持的五种主要数据类型之一。在 Hash 类型中，每个 Hash 可以存储多个键值对，其中每个键即为字段（Field），对应的值可以是字符串。这种数据结构特别适合用于存储对象或多个相关属性的集合。

Hash 使用场景

1. **对象存储**：最常见的使用场景是存储对象。例如，你可以使用 Hash 来存储用户的信息，如用户名、邮箱、密码等，其中 Hash 的键是用户的 ID，字段是属性名，字段值是属性值。
2. **避免多次访问 Redis**：相比于将对象的每个属性单独存储为 String 类型，使用 Hash 存储一个对象的所有属性可以减少与 Redis 的通信次数，因为你可以一次性读写对象的多个属性。
3. **节省空间**：对于拥有相同一组字段的多个对象，使用 Hash 比单独的字符串键占用更少的内存空间。Redis 内部对小于一定数量的小 Hashes 进行了特殊编码，使其占用的空间更少。
4. **计数器和统计**：Hash 还可以用于维护计数器和统计数据，比如社交媒体上的帖子的浏览量、点赞数等。通过字段进行累加或递减操作，既可以实现计数器的功能，又能保持数据的整洁。
5. **缓存数据结构**：当需要缓存复杂的数据结构时，如用户的购物车信息或临时的会话数据，Hash 类型提供了一种便捷的方式来存储和访问这些数据。

常用命令

- `HSET key field value`：向名为 key 的 Hash 中添加字段 field 的值为 value。
- `HGET key field`：获取名为 key 的 Hash 中字段 field 的值。
- `HMSET key field1 value1 [field2 value2 …]`：同时设置多个字段的值。
- `HMGET key field1 [field2 …]`：获取所有给定字段的值。
- `HGETALL key`：获取 Hash 中所有的字段和值。
- `HDEL key field1 [field2 …]`：删除一个或多个字段。
- `HINCRBY key field increment`：将 Hash 中指定字段的数值增加给定的数字。

Hash 类型是 Redis 提供的一个非常强大和灵活的数据结构，适用于各种不同的场景，特别是在需要存储和管理对象属性时。通过合理使用 Hash，可以提高数据操作的效率，同时优化内存的使用。

**hash 的底层数据结构是什么（不会）**

Redis 的 Hash 结构在底层实现上使用了两种不同的数据结构：压缩列表（ziplist）和哈希表（hashtable），具体使用哪种数据结构取决于 Hash 的大小以及 Redis 的配置。

1. **压缩列表（ziplist）**：当 Hash 包含的字段和字段值都相对较小，且数量不超过一定的阈值时，Redis 会使用压缩列表作为 Hash 的底层实现。压缩列表是一种为了节省空间而设计的紧凑的顺序数据结构，它将所有的元素紧密地排列在一起，没有任何间隙。这种结构非常适合存储少量的小数据。
2. **哈希表（hashtable）**：当 Hash 的字段数量增加或字段的大小增长到超过预设的阈值时，Redis 会自动将底层数据结构从压缩列表转换为哈希表。哈希表是一种典型的键值对集合，提供了非常快速的查找、添加和删除操作。在哈希表中，每个字段都被映射到哈希表的一个槽位中，从而能够快速地进行访问。

Redis 使用这两种数据结构的主要考虑是空间效率和操作效率之间的平衡。对于小的 Hash 结构，压缩列表可以显著减少内存使用，但是随着元素数量的增加，列表的操作效率会下降。此时转换为哈希表虽然会增加内存的使用，但能够保持操作的高效率，尤其是在进行频繁的读写操作时。

可以通过 Redis 配置文件中的 `hash-max-ziplist-entries` 和 `hash-max-ziplist-value` 两个参数来控制 Hash 使用压缩列表和哈希表的转换阈值。这两个参数分别表示压缩列表最多可以存储的元素数量和元素值的最大大小。

**string 的底层数据结构是什么**

Redis 的 String 类型是最简单也是最常用的数据类型之一，用于存储字符串值。尽管它被称为“String”，但实际上可以存储任何形式的数据，包括二进制数据。String 类型的底层数据结构有两种：简单动态字符串（Simple Dynamic String，SDS）和整数值（Integer）。

1. **简单动态字符串（SDS）**：SDS 是 Redis 用来实现 String 类型的主要数据结构。与传统的 C 字符串相比，SDS 有几个关键的优势：
   - **安全**：不会因为忘记空字符 '\0' 而导致的缓冲区溢出问题。
   - **效率**：增加或减少字符串长度时，SDS 可以更有效地进行内存的分配和释放。由于维护了字符串的实际长度，SDS 可以在 O(1) 时间复杂度内获取字符串长度，而 C 字符串需要遍历整个字符串计算长度，时间复杂度为 O(n)。
   - **灵活性**：SDS 支持二进制安全，意味着它们可以包含任何二进制数据，包括 '\0' 字符。
2. **整数值（Integer）**：当 String 类型的值可以表示为 64 位长整型数时，Redis 会优化存储方式，直接使用整数值来存储，而不是转换成字符串存储。这种优化可以减少内存的使用，同时加快操作速度。例如，如果你使用 String 类型存储数字 "100"，Redis 会将它存储为一个整数值而不是字符串。

Redis 会根据存储的内容自动选择最适合的底层实现，以达到高效存储和访问的目的。对于开发者而言，这些底层的优化是透明的，无需进行额外的配置或操作，你只需要按照 String 类型的接口来使用它即可。

**redis 的缓存策略有哪些 (内存淘汰策略)**

reids 的缓存开着和关着的时候对读写有什么影响吗（不会）——指的是持久化方案嘛？

**redis 过期删除策略有那些**

**用 redis 实现分布式锁的流程是什么样的**

使用 Redis 实现分布式锁是一种常见的做法，尤其适用于分布式系统中资源或操作需要同步访问的场景。这里介绍一个基本的流程来实现一个简单但有效的分布式锁：

获取锁

- 使用 `SET` 命令结合一些特定的参数来设置一个锁。这个命令的一种常见形式是 `SET lock_key random_value NX PX 30000`。这条命令的意思是：
  - `lock_key`：锁对应的键。
  - `random_value`：锁的值，这是一个随机生成的字符串，确保解锁操作的安全性，防止误解锁。
  - `NX`：仅当键不存在时设置键，确保锁的互斥性。
  - `PX 30000`：设置键的过期时间，例如这里是 30000 毫秒（30 秒），防止死锁。

锁定资源的操作

- 当客户端成功设置了锁键时（即 `SET` 操作返回 `OK`），它获得了锁，并可以执行被锁定资源的操作。

释放锁

- 完成资源操作后，客户端应该立即释放锁。由于只有持有锁的客户端知道 `random_value`，因此它可以通过 `random_value` 来验证并安全地释放锁。
- 释放锁一般通过一个 Lua 脚本来实现，这个脚本会检查 `lock_key` 的值是否与 `random_value` 相等，如果相等，则删除键，释放锁。这样做是为了确保操作的原子性，防止在检查和删除之间发生的状态变化导致误解锁。

注意事项和改进

- **锁的安全性**：为了防止释放由其他客户端获得的锁，使用 `random_value` 作为锁的值是非常重要的。
- **续租机制**：为了避免长时间运行的操作因锁过期而导致的问题，可以实现锁的续租机制，即在锁快要过期时自动延长其过期时间。
- **避免阻塞**：如果不能立即获得锁，客户端应该等待一段时间后重试。可以实现一个带有**超时的重试逻辑**，以避免无限等待。
- **使用 Redisson**：对于 Java 应用，可以考虑使用 Redisson 这样的库，它提供了更高级的分布式锁实现，包括自动续租、公平锁等特性。

使用 Redis 实现分布式锁虽然广泛，但需要仔细设计以避免死锁、锁提前过期和其他潜在问题。在实际应用中，还需要考虑网络延迟、客户端崩溃等因素对锁机制的影响。

**在分布式锁中怎么防止等待太久或者因为故障不能解锁**

在实现分布式锁时，确保锁机制既高效又安全是至关重要的。防止客户端等待时间过长或因为故障而不能正确解锁，需要采取一些策略和考虑以下几个关键点：

设置合理的锁超时时间

- **锁超时时间**是指锁自动释放的时间，应根据操作的预期执行时间来设置。这可以防止一个客户端在获得锁后因崩溃或其他原因未能释放锁，导致其他客户端永久等待的情况。
- 锁超时时间不应过长，以避免资源长时间不可用；同时也不应过短，以防锁在操作完成前过期。

锁续租

- 对于预计执行时间较长的操作，可以实现一个**锁续租**机制。客户端定期发送续租请求，以延长锁的超时时间，直至操作完成。
- 这要求客户端能够检测自身状态，一旦发现自己无法完成操作（比如因为崩溃或网络问题），就不再续租。

设置获取锁的超时时间

- 当一个客户端尝试获取锁时，应该设置一个合理的超时时间。如果在超时时间内未能获取锁，则放弃，这样可以避免无限等待。
- 超时时间的设定应根据业务场景和操作的紧急程度来决定。

使用心跳机制

- 类似于锁续租，心跳机制可以用来检测持有锁的客户端是否仍然活跃。客户端定期发送心跳信号，如果在预定时间内未收到心跳，系统可以认为客户端已经失效，自动释放锁。
- 心跳机制需要额外的机制来跟踪和管理心跳状态，可能会增加系统的复杂度。

采用现有的分布式锁实现

- 使用成熟的分布式锁库，如 Redisson（Java）、RedLock 等，这些库通常已经考虑了上述问题，并提供了解决方案。
- 这些实现通常包括锁的自动续租、锁获取超时、锁释放保证等特性，减少了开发和维护自定义解决方案的复杂度。

失败重试机制

- 对于因锁获取失败的操作，实现一个具有退避策略的重试机制，例如，使用指数退避策略逐渐增加重试间隔。
- 重试机制能够在不影响系统整体性能的前提下，提高资源利用率和操作成功率。

综上所述，设计一个既快速又安全的分布式锁机制，需要综合考虑锁的超时、续租、心跳和获取策略，同时利用现有的成熟实现可以大大减少开发的难度和潜在的风险。

**分布式锁解决了什么单机锁不能解决的问题**（没答到点上）

分布式锁解决了在分布式系统环境下资源访问冲突的问题，这是单机锁在分布式场景中无法解决的。以下是分布式锁能够解决的一些关键问题，而单机锁则不能：

1. 多进程/多服务实例之间的资源同步  
在分布式系统中，可能有多个进程或服务实例需要同时访问和修改共享资源（比如数据库记录或文件）。单机锁只能在单个进程或服务器上同步访问，而无法跨多个进程或多个服务器实例工作。分布式锁能够跨不同的进程和服务器实例提供一致的资源访问控制。

2. 故障容错和高可用性  
分布式系统设计时需要考虑节点故障的情况。单机锁无法处理节点故障后的锁恢复和转移问题。分布式锁通常结合分布式存储（如 Redis、Zookeeper 等）实现，能够保证即使某些节点发生故障，锁的状态也能够被其他节点访问和管理，从而提高了系统的可用性和容错性。

3. 分布式事务  
在处理分布式事务时，需要协调多个系统或服务之间的操作，以确保数据的一致性。分布式锁可以用来同步各个系统间的操作，确保在一个分布式事务中，相关的操作要么全部成功，要么全部失败，这是单机锁无法实现的。

4. 跨数据中心的资源同步

随着云计算的普及，应用可能部署在不同的数据中心或地理位置。分布式锁可以跨数据中心工作，确保全球范围内的应用实例能够安全地访问和修改共享资源。

1. 动态集群成员管理

分布式系统中的节点和服务实例可能会动态变化（例如，通过自动扩缩容）。分布式锁能够动态地适应这种变化，无需人工干预即可在新的节点间同步状态和数据。

总之，分布式锁通过在多节点、多服务实例间提供一致和同步的访问控制，解决了分布式环境中的并发和同步问题，提高了系统的稳定性和可靠性。这是在分布式系统架构中，单机锁所无法达到的。

**Redis Cluster**

### 数据结构

聊聊链表和二叉树的区别，插入，搜索方面

10min

### 算法

**一个二叉树从树的右边看，看到的值是哪些**

```go
		if depth == len(res) {
			res = append(res, node.Val)
		}
```

作者：lustresix  
链接：[https://www.nowcoder.com/discuss/567019741512990720?sourceSSR=search](https://www.nowcoder.com/discuss/567019741512990720?sourceSSR=search)  
来源：牛客网

## 滴滴 秋招 网约车 后端开发 一二面（凉经）

### 一面 10.12（43min）

- MySQL 性能慢的原因

MySQL 数据库性能问题可以由多种因素引起，通常涉及到查询效率、服务器配置、数据设计等多个层面。以下是一些常见的导致 MySQL 性能慢的原因：

1. 未优化的查询
- **复杂查询**：复杂的 SQL 语句或子查询可能会导致数据库执行缓慢。
- **没有使用索引**：未正确使用索引导致数据库进行全表扫描，大大增加了查询时间。
- **索引未命中**：即使创建了索引，也可能因为查询方式不当（如使用了前置通配符）导致索引未被有效利用。

1. 索引问题
- **索引过多**：过多的索引会增加写入操作的负担，因为每次写入都需要更新所有的索引。
- **索引设计不当**：不恰当的索引（如选择了错误的列作为索引）可能不会被查询有效利用。
- **未使用最合适的索引类型**：比如，在某些场景下前缀索引、全文索引或空间索引可能更适合。

1. 服务器配置不当
- **内存不足**：对于缓存、索引等内存使用不足，导致频繁的磁盘 I/O 操作。
- **配置参数不当**：如缓冲池大小（buffer pool）、线程数等未根据硬件和负载适当调整。

1. 数据库设计
- **表结构设计不合理**：如过度使用 NULL 字段、数据类型选择不当（例如，使用过大的数据类型）。
- **没有归档老旧数据**：随着数据量的增加，老旧数据如果不进行归档，会导致查询性能下降。

1. 服务器硬件限制
- **磁盘 I/O 瓶颈**：磁盘速度慢或磁盘 I/O 高，特别是在高并发写入时。
- **CPU 性能限制**：高复杂度查询或高并发请求导致 CPU 瓶颈。

1. 并发处理不当
- **锁竞争**：大量并发事务争抢锁资源，导致部分事务等待锁释放。
- **事务处理时间过长**：长事务不仅占用资源，还可能阻塞其他事务的执行。

1. 网络问题
- **网络延迟**：数据库服务器和应用服务器之间的网络延迟高，影响数据传输速度。

解决策略

- **优化 SQL 查询和索引**：定期审查和优化查询语句，合理设计和使用索引。
- **调整数据库配置**：根据具体的工作负载和硬件条件调整 MySQL 的配置。
- **硬件升级**：考虑升级硬件，如使用更快的磁盘、增加内存。
- **数据库归档和分片**：定期归档不常用的数据，考虑对大表进行分片处理，降低单个查询的数据量。
- **使用缓存**：对频繁读取但不经常更改的数据使用应用层缓存，如 Redis、Memcached 等。

通过综合分析和逐一排查这些潜在的问题点，可以有效地定位并解决 MySQL 性能慢的根本原因。

- **联合索引 (a, b, c)，where b = 1，能走吗，where a = 1，能走吗**
- **MySQL 索引原理**
- **B+ 树更扁 有什么好处**
- **InnoDB 默认隔离级别**
- **可重复读级别是怎么实现的**

在数据库事务中，可重复读（Repeatable Read）是一种隔离级别，旨在确保在同一事务内多次读取同一数据集时，结果保持一致，即使在这期间其他事务也在对数据进行修改。MySQL 的 InnoDB 存储引擎默认使用这个隔离级别。可重复读级别主要通过以下机制实现：

1. 多版本并发控制（MVCC）  
MVCC 是实现可重复读隔离级别的关键技术。它允许在不锁定整个表的情况下，执行读取操作，从而提高并发性。每当一个事务更新一行数据时，InnoDB 会保留原始数据的快照版本。当其他事务请求读取相同数据时，根据它们各自的事务版本号，InnoDB 能够提供一个一致的视图，即使数据已经被另一个事务更改。

2. 一致性读  
在可重复读隔离级别下，普通的 SELECT 操作执行的是一致性读。这意味着读取操作可以看到事务开始时刻的数据快照，并且这些读操作不会看到其他事务在此期间所做的更改。这种读取不会阻塞其他事务对这些数据行的写操作，也不会被其他事务的写操作阻塞。

3. Next-Key Locks  
为了防止幻读（即当一个事务在读取某个范围内的记录时，另一个事务插入了一个新的记录），InnoDB 在可重复读隔离级别下使用了 Next-Key Locks。Next-Key Locks 是记录锁（行锁）和间隙锁（防止其他事务插入或修改当前读取范围内的数据）的组合。这确保了在同一事务内，即使有新的数据插入，读取范围的结果也不会改变。

4. Undo 日志  
InnoDB 使用 Undo 日志来支持数据的旧版本。当事务需要读取的数据已经被其他事务修改时，它可以通过 Undo 日志来访问该数据的早期版本，以维持操作的一致性。

5. 锁定读  
在需要的情况下（如 SELECT FOR UPDATE），事务可以执行锁定读，这会对选定的数据行加上排他锁。虽然这与可重复读的非锁定原则相违背，但它提供了在需要时强制数据一致性的能力。

通过结合使用 MVCC、一致性读、Next-Key Locks 和 Undo 日志，可重复读隔离级别能够在允许高度并发的同时，确保数据的一致性和隔离性。然而，它也可能导致一些特定的问题，如事务依赖的历史数据量可能会增长，影响性能。因此，数据库的运维人员需要根据实际情况调整参数，以平衡一致性、隔离性和性能。

- 限流算法
- 手撕
    - **力扣 92.反转链表 II**
    - **力扣 53.最大子数组和**
- Redis 持久化
- **AOF 文件存储的是什么类型的数据**
- 反问

### 二面 10.12（50min）

- **Go 协程模型**
- 协程创建过程（启动 main 函数初始化，它会创建哪些协程、哪些 G、哪些 M、哪些 P、队列是什么时候创建的、全局队列是什么时候创建的）
    - 这块不会，跟面试官说我是主 Java 的，然后问了我线程池的创建过程

在 Go 语言中，协程（Goroutine）、线程（M）、调度器上下文（P）、以及各种队列的创建和初始化过程涉及 Go 运行时的内部机制。下面是这一过程的概述，包括在启动时发生的事情：

**启动过程**

当一个 Go 程序启动时，它会初始化运行时（runtime），这包括创建调度器（scheduler）的必要组件：M（OS 线程），P（处理器或调度器上下文），G（Goroutine）以及相关的队列。

1. **main Goroutine（G）**：程序开始运行时，首先会创建一个主 Goroutine 来执行 `main` 函数。
2. **M（机器或线程）**：运行主 Goroutine 的是一个操作系统线程，称为 M。在程序启动时，至少会有一个 M 被创建，它负责执行第一个 Goroutine。
3. **P（处理器）**：P 代表了运行时对操作系统线程的虚拟化，它包含了运行 Goroutines 所需的资源。在程序启动时，Go 运行时根据 `GOMAXPROCS` 的设置值初始化 P 的数量。默认情况下，`GOMAXPROCS` 的值是机器上的 CPU 核心数，但可以通过环境变量或在运行时通过调用 `runtime.GOMAXPROCS` 函数来修改。
4. **队列**：
   - **本地运行队列（Local Run Queue）**：每个 P 都有自己的本地运行队列，用于存储与这个 P 关联的 Goroutines。这些队列在 P 创建时初始化。
   - **全局运行队列（Global Run Queue）**：所有没有被分配给某个 P 的 Goroutines 会被放到全局运行队列中。这个队列在运行时初始化，并在必要时被 P 从中取出 Goroutines 来执行。
   - **Netpoller 队列**：用于等待网络 I/O 操作的 Goroutines。当 Goroutines 执行网络 I/O 操作且等待数据时，它们会被移到 Netpoller 队列。一旦 I/O 操作准备就绪，这些 Goroutines 会被移动回本地或全局运行队列，等待重新被调度。
5. **创建过程**：
   - 在程序初始化阶段，Go 运行时会设置初始的 M、P、全局队列，并创建主 Goroutine。
   - 主 Goroutine（执行 `main` 函数）开始在初始的 M 上执行。
   - 根据 `GOMAXPROCS` 的值，创建相应数量的 P，每个 P 都可以关联一个活跃的 M 来执行 Goroutine。
   - 全局运行队列和每个 P 的本地运行队列在这个过程中被初始化。  
**结论**

Go 程序的启动过程包括初始化运行时环境、创建主 Goroutine、分配初始的 M 和 P，以及初始化各种队列。这个过程设计到复杂的内部机制，使得 Go 程序能够高效地调度和执行数以千计的 Goroutines。通过运行时的调度器，Go 既支持了并发（concurrency）也支持了并行（parallelism），使得开发高效、可扩展的并发程序变得简单。

- 线程池中的线程，工作的时候是什么状态，不工作的时候是什么状态
- 线程在什么场景下会变为 `Blocked` 状态
- **线程 进程区别**
- **可达性分析算法**
- 除了可达性分析算法还有什么标记法
- TCP 怎么保证可靠性
- 超时重传，时间设置不当会有什么问题
- 滑动窗口 接收方窗口过大会有什么影响
- MySQL 事务，读已提交、可重复读
- 手撕
    - **力扣 33. 搜索旋转排序数组**
    - **力扣 300. 最长递增子序列**
- 反问

> 手撕最后一道没撕出来，直接秒挂了。写成了最长连续递增子序列，太扯淡了..

> 每轮面试 2 道手撕，没顶住呀。

作者：海苔 ___  
链接：[https://www.nowcoder.com/discuss/567296604001009664?sourceSSR=search](https://www.nowcoder.com/discuss/567296604001009664?sourceSSR=search)  
来源：牛客网

## 百度二面

百度实习二轮面试

好消息，一面过了，坏消息，二面更炸

### 纯聊天

5min

为什么来北京

未来职业规划

非常轻松

### Golang 相关

10min

GMP 的底层实现

map 的底层实现

扩容，缩容的流程（缩容不太懂）

锁的底层原理

设计一个并发安全的 map

你知道泛型吗，和 interface 的区别

你写 golang 的时候遇到什么坑吗

### 计算机网络

5min

从输入域名到返回页面的全部流程

负载均衡的策略（不会）

限流的例子

### 设计

5min

设计一个好友系统，要什么技术（答得非常不好）

如何保证 redis 双写一致

Gin 框架的底层实现是什么（只知道中间件和路由前缀树）

### 算法

5min

两数之和，共享屏幕在自己 idea 上写就行，非常尴尬我少了一个，l++，出了 bug 一次

### 反问

您觉得我还有什么不足，我现阶段学习的方向，面对生产环境怎么办之类的

### 总结

这次时间非常短，30 几分钟不到，面试官非常和气，我说不会都是笑着说没事可以学的那种，（但是估计心里想的是怎么会有这种 sb），虽然感觉又寄了但是面试体验很好，一点都不紧张，哎，只能说技不如人是这样的。二面项目完全没问，感觉就是层次上了一个台阶真正开始问素养方面了，，，还得多练

作者：lustresix  
链接：[https://www.nowcoder.com/discuss/567743711845560320?sourceSSR=search](https://www.nowcoder.com/discuss/567743711845560320?sourceSSR=search)  
来源：牛客网

## 字节暑期实习二面面经

1. **gc 垃圾回收算法**  
2. **Golang 设计模式: 举例说明** [[../../../Basic/设计模式/Go 设计模式/Go 设计模式索引|Go 设计模式索引]]
3. **手撕算法，需要手写输入输出实例**  
**字符串的最长不重复子串长度**  
(滑动窗口或者动态规划都可以实现)  
4. 你觉得秒杀有什么难解决的技术难点？  
(我没做过秒杀项目嘤嘤嘤不知道面试官为什么问秒杀相关 只蒙了应该有瞬间高并发问题和库存数据一致性的问题)  
5. 反问: 部门业务和技术栈

作者：重金属音乐爱好者  
链接：[https://www.nowcoder.com/feed/main/detail/007df2c150b84121b10d470de49ad3c8?sourceSSR=search](https://www.nowcoder.com/feed/main/detail/007df2c150b84121b10d470de49ad3c8?sourceSSR=search)  
来源：牛客网

## 京东 Golang 开发面经 （挂 Go 掌握程度不足）

### 一面 9.16 60min

- 数据结构
- go 语言的 map
- 拉链法的优缺点
- 拉链法如何优化
- 负载因子调到 1 会有什么后果
	- 空间利用率提高，但是发生冲突的可能性也增大了
- 数据库
- **数据库索引有哪些**
- sql 建表  
	设计一张字生表：表需求是可以记录学生姓名、出生日明、手机 号、是否在读。邮箱。家庭地址、生表现评价 常见查询条件为姓名、出生日期、手机号、是否在读
- 这个表有什么缺陷
- 新加一个学号字段要考虑什么
- **数据库四大特性**
- innodb 默认隔离级别
- **rr 是怎么实现的**
- 网络
- tcp 三次握手
- ip 位于哪层？icmp 位于哪层？ping 命令位于哪层？
	- ip 网络层，icmp 网络层，ping 应用层
- telnet 是什么操作？位于哪层？
	- telnet 测试映射端口或远程访问主机，应用层
- https 加密过程 (这个我不太清楚 如果有大佬知道 麻烦评论区指点一下)

### 二面 9.27 35mn

- 二面面试官：" 看你简历感觉你对 go 的接触程度不是特别深 你需要在接下来的过程中说服我
- 为什么很多大厂都用 go
- **说一说对 slice 的认识**
- slice 如何做深拷贝
- 数据库
- **如何避免回表**
- 标识性差的字段一定不能做索引列吗？
- 标识性差的字段为什么不能用来做索引列？
- **b 和 b+ 树的区别**
- **mysql 默认隔离级别**
- **rr 如何解决不可重复读**

" 已转推荐，待筛选 "

作者：留不住的四月  
链接：[https://www.nowcoder.com/discuss/353158536559534080](https://www.nowcoder.com/discuss/353158536559534080)  
来源：牛客网

## 字节飞书 Golang 二面实习面经 (已 OC)

(应该是 g 了,easy 算法没做出来)

1. **算法 (手里一副扑克牌, 第一张放在桌面上,第二张放回手牌底部, 重复第一步直到手里没牌. 根据桌子上的牌, 推出手里的牌)**
2. 一面试完下来就秒了, 面试半小时找规律, 结果发现做错了
3. 讲讲线程、协程、进程区别
4. 讲讲你最喜欢哪个语言,为什么 (ababa, 说了 go 比 java 以来管理简单,但是他说 maven 其实比 mod 强的不是一点)
5. 微服务的优点?对比单体的优点?(聊了十几分钟, 但是面试官都说这种单体其实也可以)
6. 每个业务单独开来,自己用自己的数据库, 高内聚 低耦合 服务分工明确 (那单体也可以划分模块呀?)
7. 可以实现多部署, 高可用 (单体也可以部署多个呀?)
8. 微服务, 如果一个服务挂了, 其余的服务还可以支持, 起码有容错 (我单体部署几百个,也可以呀?)
9. 分布式部署,对机器压力小 (我微服务分几个部署在我的机器上, 浪费资源不是更多吗?)
10. 其实如果真的服务器很少的话, 单体也可以, 看业务的体量和需求吧
11. 说到了负载均衡, 负载均衡有哪些技术?
12. RR
13. 哈希取模
14. 一致性哈希
15. 怎么实现负载均衡呢?
16. nginx
17. nginx 在哪里实现?
18. 网关服务
19. **nginx 在 osi 哪一层, 负载均衡在哪一层?**
20. 讲一下 golang 协程池, 作用是什么? (扯了 10 分钟, 感觉不符合面试官预期)
21. 资源复用 (但是 goroutine 本来就很轻, 感觉没有必要复用呀?)
22. 限制资源个数, 避免高并发过多 goroutine 冲垮服务器
23. 还有呢? 不知道了…
24. 输入 url 到渲染的总流程
25. 输出 10 分钟
26. 为什么二进制的文件到了客户端,浏览器可以看到多彩的画面
27. html?js?css?
28. **又给了一道巨简单的题目, 算是做出来了.**
29. **反问**
30. **学习的建议**
31. **和胜任字节实习生,能力 gap 多少, 需要从哪里改进**
32. **被发现套话了,他说第二个问题其实是想知道面试结果吧,我就回答第一个好了**…

哎, 头痛一整天, 算法脑子又宕机, 字节 886 😭

面试官还是很和蔼的 0.0

----

11.18 接好运, 2 面已过, 我是字节的🐶

作者：Lewy 华  
链接：[https://www.nowcoder.com/discuss/554371366380650496](https://www.nowcoder.com/discuss/554371366380650496)  
来源：牛客网

## 字节飞书后端实习 Golang 一面面经

1. 手写 LRU
2. **说一下 golang 协程调度**
3. 说一下如果你要设计一款 RPC 框架，你会如何设计
4. 看你说到了负载均衡，说一下一致性哈希
5. MySQL 的事务如何实现的
6. 看你会 Kitex，说一下这个你了解多少
7. 刚开你说到了 ZSet，底层是什么数据结构
8. 这个底层的 Hashtable 时间复杂度
9. 说一下项目里面的 Channel+Select 调度
10. 项目里的 Redis 限流
11. 反问：
12. 字节对实习生的期待
13. 对我的建议

作者：Lewy 华  
链接：[https://www.nowcoder.com/discuss/551074669743378432?sourceSSR=users](https://www.nowcoder.com/discuss/551074669743378432?sourceSSR=users)  
来源：牛客网

## 松鼠 Ai Golang 后端实习 一面面经

- **golang 的内存模型**
- **golang 垃圾回收**
- **golang 数组和切片的底层实现**
- 给你一个容量 15 的切片，截取他的 [2:20] 可以吗
- **mysql 底层数据结构**
- **b+ 树叶子结点的数据结构，怎么连接的**
- mysql 有很多种 int 类型，每种的大小多少
- tinyint 的范围是多少
- mysql 里面创建的时候 int1 int10 有啥区别
- 用户数据库分库分表，你会怎么分
- 那比如 1 亿个用户，你会通过那些字段来分
- **char varchar 区别**
- count * count 1 count 字段 的区别
- 那 count * count 字段的时候，某些字段有 null，那有啥区别？
- 看你项目有用 redis，说一下常用的数据结构
- 项目里怎么用的，zset 评论区怎么弄的
- 看你有用 redis 实现令牌桶，讲一下令牌桶的思想
- redis 用的什么数据结构实现的令牌桶
- 看你有用 rocketmq 做消息队列，为什么不用 redis 做呢？
- kafka 的 ack 机制了解吗？每个值对应哪种情况？
- 反问业务

作者：Lewy 华  
链接：[https://www.nowcoder.com/discuss/552458157377728512?sourceSSR=users](https://www.nowcoder.com/discuss/552458157377728512?sourceSSR=users)  
来源：牛客网

## 字节跳动 - 头条后端 (Go)- 暑期实习面经（已接 offer）

第一份实习，拿到 offer 才敢写面经系列…

面试经验总的来说：

- 心态一定要好，多和面试官交流，不要沉默，实在不会大方承认
- 简历上的项目一定要熟，项目用到的东西也要熟，用到 redis 必问
- 面试官喜欢问为什么，多查查，遇到了就能装 b
- 算法题需要亿点运气

### 一面（3.22）55min

面试官是个小姐姐，nice

1. **go 垃圾回收**
    - 不太熟，大概描述了一下，提了一嘴 Python（简历上写了熟悉 Python），小姐姐说没关系，说下 Python 是怎么做的
2. hashmap（说了 go 的 map 和 redis 的 hash 结构）
3. redis rehash 过程
4. rehash 过程中添加数据，查询数据怎么办？（就是问渐进式 rehash，刚好没看到，瞎猜了半天）
5. **hash 冲突用的什么方法解决的？查询时间？最坏时间？**
6. 你说链地址法冲突到一条链上会退化成 O(n)，它不好为什么要用？为什么不用其他的？
    - 没太明白她的意思，我只是说最坏情况可没说它不好。。然后只能说它们各有优缺点吧
    - 应该再说一下链地址法的主要优势的
7. 一道没见过的算法题

> 给出一个分子式，比如：HMg2(H2ON3)3N2，计算这个分子式中每个原子出现了多少次，输出一个 map，比如上面的分子式中：map[string]int {"H": 7, "Mg": 2,"O": 3, …}
> 1. 都以大写字母开头，后面跟 0 个或者 1 个小写字母，比如 Mg, H
> 2. 单个原子后面跟 0 个或者 1 个数字表示它出现的次数，比如 Mg2 表示 Mg 出现 2 次，数字范围 2-9
> 3. 分子式中可能有括号，括号后面可能跟 0 个或者 1 个数字表示整个括号内的原子出现的次数，比如 (N3Ag)2 表示 N 出现 6 次，Ag 出现 2 次 4. 括号可以嵌套
> 4. 输入是合法的

上来就遇到这么长的题让我很慌，加上之前 redis 被问到不会，这里感觉都要停止思考了。。看了半天说想办法从后往前把数字乘进去去掉括号再处理，问她思路有没有问题，得到肯定回答才松了一口气，然后说了下具体方法，理清之后面试官把括号去掉了，然后说时间不够了写下简化版代码吧

1. 反问

算法题写了有二三十分钟，感觉要凉了，没想到结束时面试官说先别走啊，我去喊一下二面面试官，瞬间复活

### 二面（3.22）1h

逐渐有状态了，二面还算轻松，全程在线，当时感觉过挺快，回头一听才发现问了这么多问题

1. **gmp**
2. 协程的优势
3. **进程线程区别**
4. 进程地址空间有哪些划分
5. **进程间通信**
6. 共享内存是怎么回事？映射到实际物理内存的虚拟地址在地址空间的哪一部分（我猜在堆区）
7. 虚拟内存
8. 页面置换算法（说了局部算法和全局算法）
9. LRU 实现思路
10. mysql 引擎，它们的区别
11. **innodb 辅助索引为什么存主键 id，回表不是要浪费时间？**
12. **b+ 树索引优势**
13. **acid**
14. **隔离级别，可重读是怎么实现的？幻读是怎么回事？间隙锁知道不？**
15. 读写锁互斥关系，其他分类的锁
16. 我看你项目用到了 redis 具体用到了哪些数据结构？（string，hash，zset）
17. zset 实现，跳表是怎么回事？高度？时间复杂度？为什么不用 b+ 树？
18. **redis 是单进程还是多进程？**
19. 扒项目（另一个爬虫项目）
20. （第一个项目）压测怎么做的？其他一些可以优化的点
21. **力扣原题，舒服：力扣 33. 搜索旋转排序数组**
22. 反问

二面面试官超级 nice，各种引导，问到我不会了就说 ok 没问题，全程给我信心，越面越顺

晚上另一个 hr 小哥哥加我微信约了三面时间，之前联系我的小姐姐不见了，唉

### 三面（3.25）30min

1. 扒项目（收获什么的）
2. 我看你项目用了 mongodb，mongodb 存储索引知道吗？和 mysql 比有哪些优势？（回答 mongodb 并不熟，只是毕设想用用新东西，优点就知道非结构化扩展容易，速度快）
3. mysql 存储引擎
4. 项目用到了 redis 哪些结构（zset，hash），说一说底层实现
5. zset 除了跳表 +hash 表外还有其他实现吗？
    - 才想起来数据量较小时会用压缩列表实现
    - 又问压缩列表实现的主要目的，答节省内存
6. **进程通信方式**
7. io 多路复用的几种方法（不熟，就提了下名字）
8. cookie session
9. 拥塞控制
10. **力扣原题，舒服：力扣 15. 三数之和**

三面面试官应该是某个部门老大，面相和蔼，问了 30 分钟就结束了，有点慌，没想到结束后 10 分钟 hr 就发来微信约 hr 面了

### Hr 面（3.29）15min

聊天，实习生都没啥好问的

面完晚上我等不及就微信问 hr 结果，说没问题，offer 在审批了，然后就是漫长的等待，中间还赶上清明假期，足足等了一周多才接到 offer，期待成为一名 ByteDancer

作者：两三点雨山前  
链接：[https://www.nowcoder.com/discuss/353157793744101376](https://www.nowcoder.com/discuss/353157793744101376)  
来源：牛客网

## 京东 Golang 开发工程师 校招三面面经，许愿 Offer

去年秋招的时候面试的这家公司，马上又要秋招了，给小伙伴们分享下作参考：

**一面（一个小时左右）**

1. 读写锁机制
2. **哈希的存储、查询和冲突**
3. Go map 的底层原理
4. Go sync.Map
5. 最后问了我能提前实习时间

**二面** **（20m)**

1. 自我介绍 + 深挖项目
2. 项目相关

**HR 面 (10 分钟左右，很快)**

- 自我介绍
- 深挖项目
- 对京东有什么了解
- 为什么选择这个岗位
- 职业规划

基本就是这些，有需要的小伙伴可以参考一下，也可以看看 **SSP 面试笔记** 上别人的面经；

希望大家的面试都能顺利通过！

## 面经

- [golang面试经验答案总结（一）分享一篇B站后端面经 哔哩哔哩_golang 2年经验面试-CSDN博客](https://blog.csdn.net/jinchenga/article/details/131500407?spm=1001.2014.3001.5502)
- [golang面试经验答案总结（二）字节跳动一面 golang_字节跳动go面试题-CSDN博客](https://blog.csdn.net/jinchenga/article/details/131502376?spm=1001.2014.3001.5502)
