1. 使用背景
	1. 第三方标记
2. 核心性质
	1. 独占性
	2. 健壮性：不能产生死锁
		1. 宕机导致不能主动释放锁
	3. 对称性
		1. 加锁和解锁是同一个人
	4. 高可用
3. 实现类别
	1. 主动轮询型 **自旋** + **CAS** 乐观锁
		1. 比较轻的操作 ![[Snipaste/Pasted image 20240129161532.png]]
	2. watch 监听回调型 阻塞 + 唤醒
		1. **建立回调机制**，当锁释放的时候会收到信号
	3. 分布式场景 监听回调，更少的 网络 IO，并发高的情况下 监听回调。并发比较轻，主动轮询型。
	4. etcd watch 回调机制 grpc 长连接。
	5. 惊群效应：大量锁的回调机制
4. 存在问题
5. 深度代码

- 单机锁的实现方式
	- 乐观锁 自选 + CAS
	- 悲观锁 监听回调机制

## 主动轮询型

1. Redis
	1. 基本流程 setnx
		1. setnx 保证原子性
			1. value 作为唯一表示 token
			2. 释放的时候进行比对
		2. 持有
		3. 业务逻辑
		4. 释放
	2. 技术选型
		1. Redis 常用
			1. 原子操作
			2. 基于内存
			3. set + 附加参数 | 推荐
		2. MySQL
	3. 解锁的对称性 (组合原子性操作)
		1. 检验 value
		2. 删除锁 ---> 解锁的语义
		3. 依赖 lua 脚本
2. MySQL
	1. 建立表 key + token
		1. 建立列，unique key
		2. 尝试插入数据
	2. 解锁
		1. 检验 + 解锁
		2. 利用事务是西安
3. 分布式环境下**死锁**的问题
	1. 设置过期时间解决 (根据经验，设计保守的时间) expire time 兜底方案
	2. setex
		1. 过期时间设置并不是精确的
		2. 性能上的问题
		3. 一锁多持：**因为 IO 超时、不合理的业务逻辑，过长的耗时 ---> 锁被释放了**
		4. redission 看门狗机制；租约和续约问题。
4. 数据弱一致问题 CAP 理论（分布式理论课）
	1. C 数据一致性 A 数据可用性 P 分区容错性。两两可以组合。
	2. raft 协议
	3. AP 的流派
	4. Redis 集群 ![[Snipaste/Pasted image 20240129163207.png]]
		1. 异步的进行同步，弱一致的。
		2. 哨兵机制
		3. 主节点挂了
	5. 解决方案
		1. **红锁**，多数派原则。数据强一致性。

## 主动轮询型分布式锁

1. 连接池
2. SETNX
3. 执行 lua 脚本，哥们你这个接口写的不是很好

key：进程 ID 拼接协程 ID

options

1. 阻塞时长
2. 阻塞模式
3. 非阻塞模式
	1. 尝试，比较轻的操作
	2. trylock
		1. 基于 redis 的 setnx + 过期时间
	3. 是否可重试 主动轮询模式
		1. 定时器，没 50 ms
		2. select 多路复用
			1. ctx.Done
			2. timeout
4. 阻塞时常
5. 过期时间
6. 解锁操作 ![[Snipaste/Pasted image 20240129164801.png]]

## 监听回调实现

## Reference

 - [Golang分布式锁技术攻略_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Pm4y1b76u/?spm_id_from=333.337.search-card.all.click&vd_source=25509bb582bc4a25d86d871d5cdffca3)
