# 结课作业
现在就差 KDF 的使用了。
- [ ] java 依赖的问题
- [ ] SM3 解决
- [ ] KDF
- [ ] 如何将 byte[] --> String --> List



报告方面
- [ ] 问题是什么
- [ ] SM3 算法
- [ ] KDF 扩展算法
- [ ] 随机性检测概述
- [ ] 随机性检测通过情况

你需要暂时蛰伏一段时间了。

努力的提升自己吧。

# 题目：随机性检测报告
对于SM3（我国hash），输入“Beijing University Posts and Telecommunications”，用15项测试方法检测其输出是否随机；

Beijing University of Posts and Telecommunications--转化为-->二进制序列-作为-->seed

SM3（seed）---输出 -->10^6 长的序列

测试一下哪些能通过检测

# 摘要
本实验主要是为了测试由 SM3 构造的随机数器生成的随机序列是否满足随机性测试规范。SM3 

SM3是中华人民共和国政府采用的一种密码散列函数标准，由国家密码管理局于2010年12月17日发布。相关标准为“GM/T 0004-2012 《SM3密码杂凑算法》”。
在商用密码体系中，SM3主要用于数字签名及验证、消息认证码生成及验证、随机数生成等，其算法公开。据国家密码管理局表示，其安全性及效率与SHA-256相当。

# 引言
介绍 SM3
随机性检测问题
随机性检测的意义

# 研究方法
本次实验采用 Java 实现检测方法，引用了 Github 上他人已经实现的 SM2、SM3 算法，并且用 SM2 中的 KDF 方法对 SM3 (256 bit)输出进行扩展，扩展为 10^6 的比特串，将比特串输入到测试程序，通过 P-Value 来观察是否通过随机性测试。

## KDF 实现
KDF 根据官方文档实现，算法描述如下：

KDF全称（Key derivation function） 密钥导出函数。密码学中，密钥导出函数是指使用伪随机函数从主密钥master_key中导出一个或多个密钥key。KDF 可用于将密钥扩展到更长的密钥或获得所需格式的密钥。密钥加密哈希函数是用于密钥推导的伪随机函数的流行示例。
《GMT 0003.4-2012 SM2椭圆曲线公钥密码算法 》中 关于 密钥派生函数的规定如下：
## 随机性检测方法
随机性检测方法具体参考《》其中包含 15 种随机性驾检测方法。分别是：


# 研究结果及分析结果

# 结论
实验证明，由 SM3 生成的随机序列可以通过 15 香随机性检测。

# 参考文献
- GM/T 0005-2012 随机性检测规范

# 附录
## KDF 代码
```java
public static byte[] KDF(byte[] Z, int klen) {  
   int ct = 1;  
   int end = (int) Math.ceil(klen * 1.0 / 32);  
   ByteArrayOutputStream baos = new ByteArrayOutputStream();  
   for (int i = 1; i < end; i++) {  
      baos.write(sm3hash(Z, SM3.toByteArray(ct)));  
      ct++;  
   }  
   byte[] last = sm3hash(Z, SM3.toByteArray(ct));  
   if (klen % 32 == 0) {  
      baos.write(last);  
   } else  
      baos.write(last, 0, klen % 32);  
  
   return baos.toByteArray();  
}
```

## 随机性检测代码

### 单比特频数检测

```java
public class MonobitFrequencyTest {  
    public static double run(List<Boolean> bits) {  
        if (bits.size() == 0) {  
            System.out.println("MonobitFrequencyTest:arg wrong");  
            return -1;  
        }  
        int n = bits.size();  
        int S = 0;  
        double V;  
        double P;  
        for (Boolean bit : bits) {  
            if (bit) {  
                S++;  
            } else {  
                S--;  
            }  
        }  
        V = abs(S) / sqrt(n);  
        P = erfc(V / sqrt(2));  
        if (P > 0.01){
	        return true;
        }else{
	        return false;
        }
	        
        
    }  
}
```


### 块内频数检测

```java
public class FrequencyTestWithinABlock {  
    public static double run(List<Boolean> bits) {  
        if (bits.size() == 0) {  
            System.out.println("FrequencyTestWithinABlock:args wrong");  
            return -1;  
        }  
        int m = Math.min(bits.size(), 100);  
        int n = bits.size();  
        int N = n / m;  
        double Pi;  
        double V = 0;  
        double P;  
  
        Iterator<Boolean> it = bits.iterator();  
  
        for (int i = 0; i < N; i++) {  
            Pi = 0;  
            for (int j = 0; j < m; j++) {  
                if (it.next()) {  
                    Pi++;  
                }  
            }  
            Pi /= m;  
            V += (Pi - 0.5) * (Pi - 0.5);  
        }  
        V *= 4.0 * m;  
        P = igamc(N / 2.0, V / 2.0);  
        return P;  
    }  
}
```

由于随机性检测算法的实现都比较类似，所以这里不过多列举。算法的实现实际上就是实现标准中描述的数学表达。

第一组数据
0.16031884956663012
0.7777369817489759
0.4548781170586511

0.5190653260715131
0.4050820571967399

0.779499165008029
0.08446273081384778
0.12738771956071715
0.5047706422439222
0.08470535334523122
0.8312572604148573
0.2291268168528609
0.6221547273395143
0.14190586320386298
0.7178881646798896
0.4210400081180039


第二组数据
0.1731978851167444
0.030242301181536913
0.3625755997071965

0.6004470302737115
0.9975405959960829

0.9186414674734548
0.8236349063177031
0.4629544726059801
0.3256057453474709
0.7994939882450168
0.9823729369434607
0.0940666427172473
0.7104933645043312
0.16355296438477082
0.2519327111376215
0.13729281831940443

第三组数据
0.7733467386671147
0.23416257730438905
0.2058360270452014
0.30894604275214865
0.28955842721839525
0.9617823431144534
0.5976716567397842
0.4258850703873618
0.4946053319916537
0.9601220695643019
0.42630516685572595
0.9542626896445381
0.4204550516637629
0.2676387158142031
0.569834339586356
0.10337589294463001

