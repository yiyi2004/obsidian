- 需求分析
	- 榜单模型
- 榜单设计与实现
	- 定时任务的基本思路
		- timer
		- cron 表达式
	- 服务接口设计与实现
	- 封装为 job
		- job 接口实现
		- 监控实现
	- 在 wire 里组装
- 查询接口
	- 本地缓存
	- 可用性措施
- 分布式定时任务
	- 使用分布式锁
- 基于 MySQl 设计分布式任务调度与实现

## 需求分析

1. 业务需求：展示一个热点榜单，展示五十条。
2. 从非功能性上来说，热榜功能通常是作为首页的一部分，或者至少是一个高频访问的页面，因此性能和可用性都要非常高。

问题关键点：

- 什么样的才算是热点？
- 如何计算热点？
- 热点必然带来高并发，那么怎么保证性能？
- 如果热点功能崩溃了，怎么样降低对整个系统的影响？

![[Snipaste/Pasted image 20240307151836.png]]

1. 综合考虑**用户的各种行为**
2. 综合考虑**时间**的衰减特性
3. **权重因子**

热点数据模型

1. Hacknews
2. Reddit

![[Snipaste/Pasted image 20240307152000.png]]

1. 得票数的重要性
2. 热度随时间衰减

![[Snipaste/Pasted image 20240307152911.png]]

技术选型的重要性

## 榜单设计与实现

是否需要实时计算？

- 实时计算难点：全表扫描 + 全局排序

![[Snipaste/Pasted image 20240307153130.png]]

解决方案：异步定时计算  
![[Snipaste/Pasted image 20240307153337.png]]

1. 时间间隔
2. 计算时间长度不能太长

进一步

1. 设计缓存，保证极好的查询性能
2. 保证可用性，任何时候都能拿到数据

实现：time.Ticker 定时器

![[Snipaste/Pasted image 20240307153530.png]]

- Context + Ticker 的解决方案

使用 cron 定时任务实现

![[Snipaste/Pasted image 20240307153701.png]]

- cron 表达式  

![[Snipaste/Pasted image 20240307153755.png]]

- 便捷使用方法

![[Snipaste/Pasted image 20240307154907.png]]

计算热榜的算法实现

![[Snipaste/Pasted image 20240307155117.png]]

- 实现一个 xxx 的网站
- 优先级队列

![[Snipaste/Pasted image 20240307155651.png]]

- 热榜实现 #不懂
- 构造第一个测试用例

![[Snipaste/Pasted image 20240307160215.png]]

实现方式 1  
![[Snipaste/Pasted image 20240307160239.png]]

1. 优先级队列
2. 实现逻辑比较简单

![[Snipaste/Pasted image 20240307160423.png]]

- 优化、中断条件。性能是更好的。

![[Snipaste/Pasted image 20240307160700.png]]

1. 加入缓存

![[Snipaste/Pasted image 20240307160836.png]]

![[Snipaste/Pasted image 20240307160937.png]]

坚持面向接口编程

![[Snipaste/Pasted image 20240307161042.png]]

日志采集，系统本身的监控，常见的命令行操作。

修改 wire 完成依赖注入

![[Snipaste/Pasted image 20240307161217.png]]

在 main 中启动

## 查询接口

查询接口的缓存方案

本地缓存实现

![[Snipaste/Pasted image 20240307163606.png]]

在 Repository 上组装

![[Snipaste/Pasted image 20240307163738.png]]

1. 需求分析
2. 业务逻辑
3. TDD 开发
	1. 接口
	2. domain
	3. 数据结构
	4. 多个层级

![[Snipaste/Pasted image 20240307163854.png]]

1. 正常情况下去本地缓存中获取，获取不到就回去 Redis 中获取
2. 可以在 Redis 崩溃的 hi 后，再次尝试从本地缓存获取，此时不会查本地缓存是否已经过期
3. 本地缓存的方案实现起来并不难哦

![[Snipaste/Pasted image 20240307164137.png]]

- fallover 策略

Redis 永不过期

![[Snipaste/Pasted image 20240307164201.png]]

1. 规避数据库故障引起的榜单问题

## 分布式定时任务

## 基于 MySQL 设计分布式任务调度与实现

## 面试指南

![[Snipaste/Pasted image 20240307164344.png]]

1. 极致性能的缓存方案：本地缓存 + Redis 缓存 + 数据库
	1. 查找：本地缓存 ---> Redis ---> 数据库
	2. 更新：数据库 ---> 本地缓存 ---> 最后更新 (或者删除)Redis，核心在于一点，本地缓存的操作几乎不可能的失败。
2. 高级的亮点
	1. 本地缓存可以预加载
	2. 本地缓存可以用作容错
		1. 部分场景可以考虑本地缓存永不过期，异步任务刷新本地缓存。

热榜的其他高并发思路

![[Snipaste/Pasted image 20240307164658.png]]

- 热榜高并发方案 #不懂

