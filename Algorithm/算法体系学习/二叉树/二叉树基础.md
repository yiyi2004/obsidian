- Time：2023-06-27 08:14
- Label： #algorithm #go #二叉树

## Abstract

- 现在从二叉树开始，前面的内容要进行复习
- 二叉树的定义 + 二叉树的遍历 (递归方式)

## Content

### 递归序

递归函数实现，**递归序**——二叉树的递归套路中非常重要

任何事情都开始于简单的事情，递归函数是非常强的，保证所有的函数都会**回到自己 3 次**。

you should know who you are, and be yourself.

第一次到自己就打印，这就是先序遍历，中序、后序同理。都是由递归序加工来的。

递归序非常强

![[Snipaste/Pasted image 20230627082446.png]]

这些两个集合的交集是且仅是 A 的祖先节点——证明这件事其实不难

1. 证明祖先节点在集合里面
2. 分两种情况讨论其他节点不在集合里面

- [ ] 那么交集的算法怎么写，可以复用嘛

### 非递归实现二叉树遍历

#### 先序遍历

![[Snipaste/Pasted image 20230627084538.png]]

1. 栈顶出来记为 current
2. 有右压入右，有左压入左 (先右再左)

#### 后续遍历

先序遍历 头左右 ---> 头右左 ---> 左右头 (后序遍历)

1. 出栈的时候不打印，将节点放入新的栈中。
2. 等所有的节点都入栈之后，再弹出新栈的所有节点

对象的复用，节省内存.算法之间是有联系的.

**如何使用一个栈实现后续遍历**——极客的写法

![[Snipaste/Pasted image 20230627090257.png]]

#### 中序遍历

中序改成非递归，如何成为一个极客，也就是最优的时间和空间复杂度，代码写的要优雅。

![[Snipaste/Pasted image 20230627091028.png]]

不能指望在工程中使用递归，因为递归栈是相对比较小的，很有可能回造成栈溢出。因此需要借用内存，内存是比较大的，所以不要使用系统栈作为递归的实现方案。

上线代码是不行的，递归 ---> 非递归是重要的工程能力。**限制层数的递归**

![[Snipaste/Pasted image 20230627091537.png]]

1. 两个循环退出条件 ---> stack empty or cur null
2. if cur != nil else …

解释：二叉树是可以由左边界划分

![[Snipaste/Pasted image 20230627092035.png]]

牛的，我已经比较理解了。左边界压入栈，所以出来的时候是逆序的。

都是先弄左边，然后弄自己，最后弄右树，是真的牛。

### 链表删除某个节点

1. 设计返回值的时候应该是 Node 类型，但是我认为在 Go 里面应该设计为 error 类型

不给头节点，删除链表中的元素，给出要删除节点的地址 (指针)，**但是有个问题就是如果找不到的节点，Java 的 GC 会把内存释放掉，所以根本就没有意义了**

1. nil 指向的是内存的某个独立的区域
2. 不能删除一个最后一个节点
	1. 其实是可以的 prepre and pre
3. 但是如果在工程的服务器上
	1. 数据迁移比较麻烦 ---> 不一定提供数据的拷贝
	2. 流量迁移费劲，因为找不到上一个节点
	3. 依赖没有迁移

**在面试中讲出一些存在问题也是非常重要的**

### 二叉树按层遍历

![[Snipaste/Pasted image 20230627094112.png]]

1. 使用队列实现

![[Snipaste/Pasted image 20230627094312.png]]

可以通过设置 flag 的方式发现某一层结束了 ---> 第五题会进行介绍

### 二叉树的序列化与反序列化

1. 链表 ---> 数组

没有不挂的服务，树 ---> 文件，字符串，唯一的结构 ---> 序列化。能够唯一表示树的结构

常规的方式 ---> 二叉树的重构 (先序 + 中序 || 其他的东西) ---> 赋予这些内容含义 (找到在实际中的应用是非常重要的)

1. 按照先序遍历序列化
2. 按照层序遍历序列化

#### 先序遍历序列化与反序列化

##### 序列化

![[Snipaste/Pasted image 20230627095550.png]]

再写面向对象程序的时候，你要分清，哪些应该是自己的，哪些应该是传进来的。

##### 反序列化

![[Snipaste/Pasted image 20230627100121.png]]

后序遍历序列化有的，中序没有，因为有歧义。

![[Snipaste/Pasted image 20230627100222.png]]

#### 层序遍历序列化

边界条件，比如头节点是否为空，如果空，那就直接结束捏。—— 可以套用在每一层递归上。

##### 序列化

1. 两个队列，一个队列存储结果，另一个队列存储节点，用来进行按层排序遍历
2. 如果节点为空间点，那么加入结果。如果节点不为空，加入结果，并且加入节点队列。
3. 条件是 !queue.isEmpty()

##### 反序列化

1. 先拿出头节点

![[Snipaste/Pasted image 20230630161041.png]]  

- 对数器的重要性，写对数期。随机生成数组，随机生成链表，随机生成二叉树、暴力解题方法。

##### Leetcode

这道题去年考了

![[Snipaste/Pasted image 20230630161114.png]]

- 多叉树序列化为二叉树的方法，其实比较简单，**左侧右边界**

![[Snipaste/Pasted image 20230630164514.png]]

1. 深度优先遍历

##### 打印二叉树的样子

这是一个工具函数，用来打印二叉树的样子 (图像)，不常考，但是如果一个二叉树输入进去发生死循环，那么你的二叉树连接可能有问题

##### 二叉树最宽的层

1. 按层遍历
2. 标志某一层结束

![[Snipaste/Pasted image 20230702164827.png]]

几个重要变量：

1. 当前层的节点个数
2. 当前层 end | curend
3. 下一层 end
4. max

![[Snipaste/Pasted image 20230702165025.png]]

- TreeMaxWidth

在层序遍历的基础上进行的修改

比较 low 的实现方式：

1. 记录每个节点的层数
2. 弹出的时候统计，并找出最大

##### 返回某个节点的后继节点

在一个遍历顺序中，某一个节点之后打印的节点就是后继节点。所以会有三种类型的搜索二叉树。

1. 经典方法：中序遍历 + 找到 O(N)

![[Snipaste/Pasted image 20230703095955.png]]

有父节点指针之后可不可以将时间复杂度 O(N) --->O(K) 节点与后继节点之间的真实距离

> 1. 关键在于分类讨论
> 2. 你想象节点位置的时候考虑的并不全面 —— 左孩子，右孩子，不如下一个时间段，把所有的情况都列举一遍。
> 3. 写一个随机二叉树的生成程序

##### 二叉树折纸问题

> 具象化的操作之后就理解了，01 + 中序遍历

![[Snipaste/Pasted image 20230703104444.png]]  
![[Snipaste/Pasted image 20230703104526.png]]  
![[Snipaste/Pasted image 20230703104627.png]]  
![[Snipaste/Pasted image 20230703104926.png]]

> 1. 层数作为退出条件

44~45 可以虐面试官 ---> 大厂刷题班

##### 判断是搜索二叉树

##### 判断是完全二叉树

## Reference
