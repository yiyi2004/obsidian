- Time：2023-07-04 10:01
- Label：

## Abstract

- 最简 CGO 程序
- 基于 C 标准库函数输出字符串
- 使用自己的 C 函数
- C 代码的模块化
- 用 Go 重新实现 C 函数
- 面向 C 接口的 Go 编程

## Content

### 最简 CGO 程序

真实的 CGO 程序一般都比较复杂。不过我们可以由浅入深，一个最简的 CGO 程序该是什么样的呢？要构造一个最简 CGO 程序，首先要忽视一些复杂的 CGO 特性，同时要展示 CGO 程序和纯 Go 程序的差别来。下面是我们构建的最简 CGO 程序：

```go
// hello.go
package main

import "C"

func main() {
    println("hello cgo")
}
```

代码通过 `import "C"` 语句启用 CGO 特性，主函数只是通过 Go 内置的 println 函数输出字符串，其中并没有任何和 CGO 相关的代码。虽然没有调用 CGO 的相关函数，**但是 `go build` 命令会在编译和链接阶段启动 gcc 编译器**，这已经是一个完整的 CGO 程序了。

### 基于 C 标准库函数输出字符串

```go
// hello.go
package main

//#include <stdio.h>
import "C"

func main() {
    C.puts(C.CString("Hello, World\n"))
}
```

我们不仅仅通过 `import "C"` 语句启用 CGO 特性，同时包含 C 语言的 `<stdio.h>` 头文件。然后通过 CGO 包的 `C.CString` 函数将 Go 语言字符串转为 C 语言字符串，最后调用 CGO 包的 `C.puts` 函数向标准输出窗口打印**转换后的 C 字符串**。

相比 “Hello, World 的革命” 一节中的 CGO 程序最大的不同是：**我们没有在程序退出前释放 `C.CString` 创建的 C 语言字符串**；还有我们改用 `puts` 函数直接向标准输出打印，之前是采用 `fputs` 向标准输出打印。

没有释放使用 `C.CString` 创建的 C 语言字符串会**导致内存泄漏**。但是对于这个小程序来说，这样是没有问题的，因为程序退出后操作系统会**自动回收**程序的所有资源。

### 使用自己的 C 函数

```go
// hello.go
package main

/*
#include <stdio.h>

static void SayHello(const char* s) {
    puts(s);
}
*/
import "C"

func main() {
    C.SayHello(C.CString("Hello, World\n"))
}
```

除了 `SayHello` 函数是我们自己实现的之外，其它的部分和前面的例子基本相似。

我们也可以将 `SayHello` 函数放到当前目录下的一个 C 语言源文件中（后缀名必须是 `.c`）。因为是编写在独立的 C 文件中，**为了允许外部引用，所以需要去掉函数的 `static` 修饰符**。

## Reference
