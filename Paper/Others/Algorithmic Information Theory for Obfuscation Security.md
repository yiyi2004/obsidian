# Abstract
设计有效的代码混淆的主要问题是保证安全性。最先进的混淆技术依赖于未经证实的安全性概念，因此不被视为可证明的安全性。本文对基于Kolmogorov复杂度和算法互信息的代码混淆安全性进行了理论研究。我们引入了代码混淆的新定义，该定义要求代码及其混淆版本之间的算法互信息最少，从而允许将受控数量的信息泄露给对手。我们认为，我们的定义避免了Barak等人的不可能结果，并且在更直观的意义上，它比混淆无区分性定义更具优势，并且是算法而不是概率的。

# 1 Introduce
恶意逆向工程对软件机密性带来了巨大的风险，尤其是对于在由意图窃取知识产品的软件盗版者控制的恶意主机上运行的软件。使用软件保护技术（如代码混淆）阻止恶意逆向工程，对于保护程序免受恶意主机攻击至关重要。混淆转换试图转换代码，使其对于人类和自动化程序分析工具变得难以理解，同时保留其功能。它是一种低成本的技术，不会影响可移植性，并且有望保护移动程序免受恶意主机攻击。

代码混淆的主要挑战之一是缺乏严格的理论背景。由于缺乏理论基础，很难正式分析和证明这些技术对恶意主机攻击的有效性。特别是，很难比较不同的混淆转换对攻击的适应力。通常，提出的混淆转换技术没有提供可证明的属性。

软件开发人员努力生产结构化且易于理解的代码，他们的动机是简化维护。另一方面，代码混淆将代码转换为结构较弱且易于理解的版本。它产生了更复杂的代码，即Kolmogorov复杂度 (Li和Vit&#39;anyi，2008) 是一种众所周知的理论，可以测量规律性和随机性。随着程序中存在更多的噪声和不规则性，描述程序的最短程序的大小往往会更大。Kolmogorov复杂性是算法信息理论的基本概念，它在许多方面都适应了公认的信息理论的观点，以关注单个实例而不是随机分布。通常，算法信息论用字符串的内在随机性代替了概率的概念。

Kolmogorov复杂性是不可计算的; 然而，它可以在实践中通过无损压缩 (Kieffer和Yang，1996) (Li和Vit&#39;anyi，2008) 来近似，这有助于直观地理解这一概念，并使这一理论与现实世界的应用相关。本文的目的是在算法信息论的背景下为代码混淆提供一个理论框架: 定量捕获代码混淆的安全性，讨论其可实现性并研究其对对手的局限性和弹性。

我们引入了不可理解的概念来定义代码混淆中的混淆，并认为这还不够好。然后，我们提出我们的安全概念，并比较这两个定义。我们认为，我们的安全模型与Barak等人的虚拟黑箱模型根本不同，因此，它们的不可能结果不适用。然后，我们证明在合理的条件下我们可以有安全的混淆。最后，我们在子程序级别研究了两种用于软件中混淆代码的主要方法 (编码和隐藏) 的安全性。

据我们所知，本文是第一个提出算法信息理论作为代码混淆及其威胁模型的理论基础; 我们相信我们的工作是得出一致度量代码混淆保护质量的第一步。该框架可以应用于大多数代码混淆技术，并且不限于任何混淆方法或语言范式。

**论文结构**：在第 2 节中，我们提供了相关工作的概述。第 3 节提供了预备知识和所需的符号。在第 4 节中，我们讨论了我们的方法背后的直觉，提出了代码混淆的正式定义，并展示了针对被动攻击者的安全代码混淆的一些结果。在第 5 节中，我们研究了在子程序级别进行代码混淆的两种主要方法的安全性。第 6 节以拟议的未来工作结束。

# 2 Related Work
科尔伯格等人。 (Collberg et al., 1997) 是第一个根据语义保持转换定义混淆的人。巴拉克等人。 (Barak et al., 2001) 引入了完美混淆的正式定义，试图实现基于黑盒范式的明确定义的安全性。直观地说，如果一个程序混淆器 O 将任何程序 𝑃 转换为一个虚拟黑盒 O(𝑃)，那么任何可以从 O(𝑃) 有效计算的东西，都可以在预言机访问 𝑃 的情况下有效计算。然而，他们也证明了不能通过显示不可能混淆的函数集的存在来满足黑盒定义。另一方面，Garg 等人（Garg 等人，2013 年）最近进行的一项研究提供了积极的结果，使用不可区分性混淆，没有已知的不可能结果。然而，正如 (Goldwasser 和 Rothblum, 2007) 所指出的，不可区分性混淆有一个缺点：它不能直观地保证代码混淆的安全性。

# 3 PRELIMINARIES
我们使用 𝑈 作为通用图灵机的简写，𝑥 用于有限长度的二进制字符串，∣𝑥∣ 用于其长度。我们使用 𝜖 表示可忽略的值，使用 Λ 表示空字符串。我们使用符号𝑂(1) 表示常数，𝑝(𝑛) 表示输入为 𝑛 ∈ ℕ 的多项式函数。 ∥ 用于表示两个程序或字符串之间的连接。 P是一组二进制程序，P′是一组二进制混淆程序，L={𝜆𝑛 𝜆𝑛 ∈ {0, 1}+,𝑛 ∈ ℕ} 是混淆过程中使用的一组（秘密）安全参数1. 𝔸 ={A𝑛}𝑛∈ℕ 表示一组对手（反混淆器），其中对手 A⊆ 𝔸 使用一组反混淆技术（例如逆向工程）；对手一词可与反混淆器互换使用。我们只考虑用 𝐾(.) 表示的 Kolmogorov 复杂度（前缀算法复杂度）的前缀版本。复杂性和 Kolmogorov 复杂性术语有时可以互换使用；有关前缀算法复杂性和算法信息论的更多详细信息，我们请读者参考 (Li and Vit´anyi, 2008)。下面简要介绍该理论的必要部分。

接下来是定义的内容

# 4 CODE OBFUSCATION USING KOLMOGOROV COMPLEXITY

## 4.1 Motivation
代码混淆的主要目的是迷惑对手，使逆向工程的任务极其困难。代码混淆引入了噪声和伪指令，这些指令会在目标混淆代码中产生不规则性。我们认为这些使混淆代码难以理解。经典复杂度指标在测量和量化混淆代码中的不规则性方面的能力有限，因为这些指标中的大多数旨在衡量代码属性的某些方面，例如发现错误和代码维护。在这种情况下，人类的理解是关键。攻击者必须了解混淆代码才能恢复原始代码。衡量代码混淆必须考虑到这个人为因素。尽管测量代码理解是非常主观的，但有一些成功的尝试来测量基于 Kolmogorov 复杂性的人类认知推理和认知科学（Gauvrit 等，2011）。

正如 (Lathrop, 1997) 和 (Jbara and Feitelson, 2014) 中所建议的那样，可以使用 Kolmogorov 复杂性和压缩来量化代码的规律性（和不规则性）。代码规则性是指某种结构被重复多次，因此可以被识别。相反，代码中的不规则性可以解释为代码在代码主体上表现出不同类型的结构。 Jbara 等人介绍了程序的规律性。在（Jbara 和 Feitelson，2014 年）中作为代码理解的潜在衡量标准；他们通过实验表明，使用压缩，长规则函数比 LOC（代码行）和 McCabe（循环复杂度）等传统经典指标可以估计的复杂度要低。

我们的方法背后的主要直觉基于以下论点：如果攻击者未能捕获混淆代码中的某些模式（规律），那么攻击者将难以理解该代码：它无法提供有效且简短的，即简单的描述。另一方面，如果这些规律很容易解释，那么描述它们就会变得更容易，因此代码也不会难以理解。

我们使用图1中的示例来演示我们的动机。我们混淆了图1-(a) 中的程序，该程序通过添加带有伪造代码和数据编码的不透明谓词2来计算前 𝑛 个正整数的总和。如果我们将经典复杂度度量 (McCabe，1976)) 应用于图1-(b)，结果将是6。循环复杂度基于控制流图 (CFG)，并通过以下方式计算: 𝐸 − 𝑁 2，其中 𝐸 是CFG中的边数，𝑁 是节点数。图1(b) 包含 𝑁 = 8个节点，𝐸 = 13条边，则环复杂度为 (13 − 8 2)= 7。我们可以在这里看到一些规律性: 有一个不透明的谓词重复了三次。此外，变量 𝑦 在Ifbranch的同一位置重复三次。我们猜想，由于通过使用无损压缩存在规律性，我们可以在图1-(b) 中找到程序的简短描述。


我们采用图1中的另一个混淆版本-(c) (同一程序的); 通过添加三个不同的不透明谓词来混淆此代码。与图1-(b) 相比，该版本中的模式较少; 描述图1-(c) 的最短程序可能与代码本身非常相似，其中循环复杂度相同7，并且它不考虑代码中发生的更改。假设图1-(c) 的不透明谓词同样难以打破，攻击这个代码至少需要比图1-(b) 中的代码多两倍的努力，因为我们需要找出两个更不透明的谓词的值。此外，图1-(b) 可以比图1-(c) 以更高的速率压缩; 这再次归因于图1-(b) 中的固有规律性。

我们认为，安全且混淆了对手的混淆程序将在其源代码中表现出高度的不规则性，因此需要更长的描述来表征其所有功能。这可以通过Kolmogorov复杂度的概念来捕获，该概念量化了对象中的信息量。与未混淆的程序相比，混淆的程序将具有更多的非必需信息，因此具有更高的复杂性。因此，我们可以使用Kolmogorov复杂性来量化由于混淆过程而导致的混淆程序中的混淆程度。
