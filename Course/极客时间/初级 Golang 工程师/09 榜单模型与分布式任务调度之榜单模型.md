- 需求分析
	- 榜单模型
- 榜单设计与实现
	- 定时任务的基本思路
		- timer
		- cron 表达式
	- 服务接口设计与实现
	- 封装为 job
		- job 接口实现
		- 监控实现
	- 在 wire 里组装
- 查询接口
	- 本地缓存
	- 可用性措施
- 分布式定时任务
	- 使用分布式锁
- 基于 MySQl 设计分布式任务调度与实现

## 需求分析

1. 业务需求：展示一个热点榜单，展示五十条。
2. 从非功能性上来说，热榜功能通常是作为首页的一部分，或者至少是一个高频访问的页面，因此性能和可用性都要非常高。

问题关键点：

- 什么样的才算是热点？
- 如何计算热点？
- 热点必然带来高并发，那么怎么保证性能？
- 如果热点功能崩溃了，怎么样降低对整个系统的影响？

![[Snipaste/Pasted image 20240307151836.png]]

1. 综合考虑**用户的各种行为**
2. 综合考虑**时间**的衰减特性
3. **权重因子**

热点数据模型

1. Hacknews
2. Reddit

![[Snipaste/Pasted image 20240307152000.png]]

1. 得票数的重要性
2. 热度随时间衰减

![[Snipaste/Pasted image 20240307152911.png]]

技术选型的重要性

## 榜单设计与实现

是否需要实时计算？

- 实时计算难点：全表扫描 + 全局排序

![[Snipaste/Pasted image 20240307153130.png]]

解决方案：异步定时计算  
![[Snipaste/Pasted image 20240307153337.png]]

1. 时间间隔
2. 计算时间长度不能太长

进一步

1. 设计缓存，保证极好的查询性能
2. 保证可用性，任何时候都能拿到数据

实现：time.Ticker 定时器

![[Snipaste/Pasted image 20240307153530.png]]

- Context + Ticker 的解决方案

使用 cron 定时任务实现

![[Snipaste/Pasted image 20240307153701.png]]

- cron 表达式  

![[Snipaste/Pasted image 20240307153755.png]]

- 便捷使用方法

![[Snipaste/Pasted image 20240307154907.png]]

计算热榜的算法实现

![[Snipaste/Pasted image 20240307155117.png]]

- 实现一个 xxx 的网站
- 优先级队列

![[Snipaste/Pasted image 20240307155651.png]]

- 热榜实现 #不懂
- 构造第一个测试用例

![[Snipaste/Pasted image 20240307160215.png]]

实现方式 1  
![[Snipaste/Pasted image 20240307160239.png]]

1. 优先级队列
2. 实现逻辑比较简单

![[Snipaste/Pasted image 20240307160423.png]]

- 优化、中断条件。性能是更好的。

![[Snipaste/Pasted image 20240307160700.png]]

1. 加入缓存

![[Snipaste/Pasted image 20240307160836.png]]

![[Snipaste/Pasted image 20240307160937.png]]

坚持面向接口编程

![[Snipaste/Pasted image 20240307161042.png]]

日志采集，系统本身的监控，常见的命令行操作。

修改 wire 完成依赖注入

![[Snipaste/Pasted image 20240307161217.png]]

在 main 中启动



## 查询接口

## 分布式定时任务

## 基于 MySQL 设计分布式任务调度与实现
