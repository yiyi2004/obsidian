wrk 做压测

- [ ] windows 安装 wrk

瓶颈问题在于 CPU  
service 不关心数据从哪里来，只需要数据就好了。  
service 控制业务最核心的内容  
缓存本身就是一个抽象的东西  
Redis 失效的时候，使用本地缓存。  
unify cache

![image-20240126151618763](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240126151618763.png?lastModify=1710336810)

中间件团队做的事情  
面向接口编程

![image-20240126151943581](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240126151943581.png?lastModify=1710336810)

人家既然已经可以传配置，为什么不让他自己初始化呢？

- 中间件研发，需要提供统一的接口就好了。
- 业务研发，experation 写一个字段就可以了，控制过期时间

![image-20240126173541456](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240126173541456.png?lastModify=1710336810)

- 错误：Redis 可能崩掉了。
- 直接会把数据打崩

![image-20240126173802909](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240126173802909.png?lastModify=1710336810)

- 面试，加载，保护数据库。
- 数据库限流啊。熔断、限流的方案。

ORM Middleware

不要用 Redis 集群限流。

强一致性就不要用缓存。

后面解决一致性问题，一定要注意。

**缓存，缓存崩了需要怎么解决的**

数据库限流，告警非常的多。

- 限流
- 问题
- 二级缓存
- 两个 Redis 集群
- 本地缓存 + Redis
- 高大上 + 廉价的

一定要想办法保护住你的数据库

限流 ORM 上限流

![image-20240126174643806](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240126174643806.png?lastModify=1710336810)

和 Redis 保持一种心跳，如果心跳时候 Redis 不存在了。

1. 备用集群
2. 本地缓存
3. 不要访问
4. KeyNotExists
5. 问一下布隆过滤器，如果没有，防止攻击。

针对特定流程优化性能，登录的时候缓存 email

二次验证。

Redis 的数据结构

数据结构对应的操作

升职加薪

![image-20240126195414130](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240126195414130.png?lastModify=1710336810)

- 写好很多 lua 的脚本
- 数据库查询
- 性能分析报告
- 测试写入接口，读接口并不需要那么多数据
- 注册接口
- 查询接口是主流

![image-20240126195519330](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240126195519330.png?lastModify=1710336810)

测试中维护登录态

Redis

![image-20240126195559687](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240126195559687.png?lastModify=1710336810)

面试上讲究一个无中生有

短信验证服务

## 多种登录方式

- 短信验证码
- 微信登录

需求分析与系统设计

依赖注入和抽象接口编程

第三方服务治理——小环节，适合面试，花里胡哨的东西。

### 需求分析 (方法论)

![image-20240126200129394](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240126200129394.png?lastModify=1710336810)

- 输入和输出
- 业务场景
- 异常流程的角度

非功能角度：安全性 > 扩展性 > 性能

做了一个高并发、高可用的功能

**断点续传**

上来我就是三高

**职场生存指南**

扩展性、前瞻性设计 ---> 副业

![image-20240126200744445](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240126200744445.png?lastModify=1710336810)

验证拼图

- 提示重试的次数 可配置的

登录这个东西是独立的嘛？

1. 别的业务有没有可能会用到这个手机验证码的功能。
2. 手机验证码是一个独立的功能。

验证码和登录功能，实战训练营是一个 要的过程。

短信本身就是独立的功能

短信可以换供应商

短信 + 验证功能

- **留出扩展空间**

深入分析非常重要，超前半步设计。

## 如何设计接口

- 针对 A 的，抽象程度不是很高的。
- 针对当下的实现，往前看 1 ~ 2 步

抽取公共的字段和方法出来  
每一个不能 xxx 的背后都是一条人命。  
放到结构体上，防止其他人调用到。  
内部调用状态检不检测无所谓。佛渡有缘人，真的没有必要我来检测啊。  
BaseResponse 操作 HTTP 相关的，否则用不上。  
不要相信别人，不要相信昨天的自己。  
sms.Code 没有定义常量，这种设计真的垃圾，应该有枚举的。  
1 元送你好几百条的。  
准备好自己的回答，不要内耗了。  
Golang 通常是使用 error 传递信息的，当 Get 缓存的时候需要考虑多种情况

1. 能够从缓存中得到数据
2. 缓存中没有数据
    1. 问布隆过滤器
        1. 如果有，查数据库
        2. 没有，不查数据库，返回空值。
3. 缓存出错

Redis 出错，加载数据 ---> 触发限流

ORM Middleware 数据库的限流。

单机的限流

和 Redis 之间保持一种心跳

UnifyCache 的层面上去做

1. 备用集群
2. 本地缓存
3. 返回特定的 Error ，让你不要访问数据库了
4. 缓存发现有问题的时候，问一下布隆过滤器，防止用户攻击。

![image-20240208203620513](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240208203620513.png?lastModify=1710336810)

- 提前优化，为了扩展性

type Password string

包变量的唯一写法

![image-20240208204018638](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240208204018638.png?lastModify=1710336810)

依赖查找在 Golang 里面是不可以的

坚持三条原则

短信服务是一个独立的服务，不仅仅是一个发送验证码。

- ekit 的实现
- 适配器模式
    - 存在问题：留下历史债务，技术债务。

### 验证码服务

深入分析验证码的安全问题

- 留下书面的证据  
验证码服务接口抽象  
不太可能有别的实现，就一个文件就好
- 区分业务场景的参数  
设计接口
- send
    - 安全保障
- verify
    - 防止爆破
    - biz

前端是防不住的

- 一定要有过期时间
    - 没有过期时间，生产环境，可能别人在改，小心你的手贱同事。

check in do something，业务开发的时候经常会遇到

![image-20240221134419915](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240221134419915.png?lastModify=1710336810)

- 并发场景 check in do something 的场景，分布式环境下的并发
- 解决办法
    - Redis 层面上解决，Redis 单线程特性，将要做的事情封装在一起。
    - 分布式锁 —— 难用，性能很差。
- Lua
    - 检查验证码
    - 存储验证码

大多数依赖于 Redis 的操作都需要通过 Lua 脚本实现。

- 利用 go:embed 引入 lua 代码

switch 进行结果的判断 -1 -2 0

发送太频繁，给一个特定的错误。

service: send

1. 生成验证码
2. 塞进去
3. 发送验证码

tplID 做成可配置的，配置化，有代码洁癖，但不多。

err 可能是超时错误，有可能已经发出去了。

- 如果要重试的话，传初始化的时候，传入一个自己就会重试的 smsSvc
- 小心并发问题
- 错误扩散，一致重试，负载很高，用户手动重试也是可以的。

验证码验证的时候也需要进行安全控制，比如验证 3 次以上。

写代码的流程

1. lua 脚本
2. go 代码的逻辑

## 短信业务逻辑实现

用户，验证码登录

- hget hset

聚合服务，如果聚合服务比较复杂，那么单独抽象出来。

写一个假的基于内存的短信验证服务

switch

唯一索引可以有多个空值，但是不能有多个空字符串

主从延迟问题

创建的时候 id 的问题

快路径 + 面路径；一旦出发降级，降级 == true，只走快路径。

快慢路径没有什么优雅

func PathDownGrade(slow, fast func()){

}

开发的环境下内存的实现。

### 升职加薪指南

sqlx encrypt_test

![image-20240221184957159](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240221184957159.png?lastModify=1710336810)

- 有意识的培养并发问题

![image-20240221185224812](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240221185224812.png?lastModify=1710336810)

- 本地缓存的框架
- 单机的并发安全

## 依赖注入

- install wire
- go:build wireinject
- wire 帮助组装，不关心顺序
- wire 生成组装后的代码
- 抽象语法树编程
- 模板编程
- wire 不支持单例模式

IoC 控制反转：依赖注入是控制反转的一种形式 或者 DI dependency Injection

配置重 Go ---> Custom Tags

## 面向接口编程

中间件设计

违背了开闭原则 —— 设计模式

面向接口编程就是为了扩展性

wire 单例模式，使用指针

顶尖程序员：超前设计，但是不超前实践。最小化实践，不要实现过度了。

- 超前设计是重要的。
- 努力的说明，是解决了一类问题。不是解决一个问题。
- 解决公共的问题。
- 预先留下扩展的接口
- 优雅的设计是很省时间的。
- 学会假装很忙
- 3 天应该可以。及时沟通。
- 任何的建议都会引起别人的反感。

![image-20240221200054587](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240221200054587.png?lastModify=1710336810)

## 单元测试

- 用的人只管用，怎么初始化我不管。我一点都不关心如何初始化。

自动化测试

1. 单元测试
2. 集成测试

## 第三方服务的调用治理 (中高级的内容)

1. 装饰器模式
	1. 基于接口的装饰器模式
	2. 叠床架屋的装饰器模式用法
2. 利用装饰器模式治理短信服务
	1. 为短信服务添加限流
	2. 自动切换短信供应商

- 降低用户注册成本。

操作

1. fork
2. creating fork

面试容易赢得竞争优势，高级工程师。有高级的东西比较说。

通向高级工程师的必经之路。炫技式的设计。

第三方服务不在你的控制范围内。在可影响范围内。

**代码不是你写的地方都要做好容错**

1. 不要相信昨天的自己，因为今天的你是更强的。

那你不喜欢还是给我吧，我挺喜欢这个味道的。

是否限流，保守，下游不靠谱，限流。下有很强、业务可用性要求高、尽量容错策略。9999

本地内存做的

**不要改了已有的代码**：这种是侵入式的设计，不要这样不要这样！

**一定要克制自己复制粘贴的欲望！！！**

- 使用装饰器的模式，不改变原有特性，增加额外的功能。——可以不断的扩展功能。

![image-20240223155939293](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240223155939293.png?lastModify=1710336810)

- 装饰器的另一种实现方式就是组合
- **开闭原则**：对修改闭合，对扩展开发（锅甩不到你的头上）
    
- 非侵入式：不修改已有代码

反复的重构 ---> 提高代码能力和设计能力

职场：会哭的孩子有奶吃。

- 实现的基础上搞一些花活，做一些额外的事情。
- 不是抢难得和复杂的活，抢的应该是老板的核心 KPI 的活
- OKR 老板的 123 条
- 混职场和自我提升是不同的

判断一个服务是否有问题，是基础但是比较困难的

- 心跳，网络、
- EOF 大概率连接出现问题
- 不要每次都从 0 开始，进行更加精细的设计。

原子操作是轻量级的并发工具

锁可能执行了几百条的机器指令，原子操作是非常轻量级的并发工具。

动态判定服务商状态

下游服务可以给你 CPU 使用率等等，动态判定下游状态。公司内部的接口。

![image-20240224094137971](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240224094137971.png?lastModify=1710336810)

内部服务鉴权的方式。

设计的是中台的服务。

### 升职加薪指南

1. 为公司的第三方调用添加治理措施

![image-20240224094919197](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240224094919197.png?lastModify=1710336810)

- 实践中很少用，但是你必须会的。没有什么项目精力。
    
    - 每个方案准备个 300 ~ 500 字数。
        
- 没说怎么实现高并发，高并发太难了 QAQ

审批流程

鉴权

技术上的挑战性不多

1. 设计一套同步转异步的条件

决策理由：多个超时错误

通过观察服务，具体的使用场景

![image-20240224095459374](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240224095459374.png?lastModify=1710336810)

- 控制异步重试次数
    
- MQ 还没有讲到，MQ 更加合适啊。

![image-20240224095921159](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240224095921159.png?lastModify=1710336810)

goroutine 泄露，不需要考虑。

- 同步转异步
    
- 转发
    
- offer 收割机，什么是 offer 收割机啊！

### 扫码登录

SSO 与微信扫码登录，Auth2

SSO 是弱化版的 Auth2

微信登录 API

微信开放平台，微信登录的问题。

appid 和 redirect_uri 是相互匹配的。

只能支持 HTTPS 协议

![image-20240226221215518](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240226221215518.png?lastModify=1710336810)

多个平台的 OAuth2 的

短信可以构建统一的抽象，但是微信登录和钉钉登录不一样，没有办法对外提供完整的抽象。多平台登录，登录 handler 不同，不需要重新分发。

改 host 文件，

![image-20240226224014157](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240226224014157.png?lastModify=1710336810)

![image-20240226224231268](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240226224231268.png?lastModify=1710336810)

写代码的小技巧

### 面试要点
