## 并发队列直播文档 3.0- 第三轮

## 目标

提高你们的并发编程能力。p6 +，当你能够独立写出来这个并发队列的时候，就可以在简历加上精通 Go 并发编程。

代码在 live_round_3 分支上

### 课前准备

 安装好 Go 开发环境，Go >=1.18

 提前搜索队列的基本含义，包括普通队列，并发队列，并发阻塞队列，优先级队列，优先阻塞队列等

 提前了解 ring buffer

 （如果你还完全没接触过，课程中是有的）提前学习 context.Context, sync 包中的读写锁， sync.Cond, atomic 包（原子操作），semaphore.Weighted([golang.org/x/sync/semaphore](golang.org/x/sync/semaphore) 包) 

## 10.15

### 讨论（提前思考）

 为什么在有了 channel 之后，还要去考虑设计并发队列呢？

 如果要你设计一个并发队列，你会考虑一些什么场景，或者说考虑一些什么因素？

 基于上面的场景，你怎么设计接口？

 对于实现，你认为什么样的非功能特性是最比较重要的？

 和 channel 作为对比，你认为 channel 和传统的并发队列比起来，优缺点有哪些？

 （可选）平时你是怎么分析并发场景的？或者说，你是怎么分析一段代码有没有并发问题的？

### 知识点

讨论并发队列的使用场景，基本用法，以及初步的接口设计。

● 为啥有了 channel 还要设计并发队列呢？

○ channel 支持的操作是有限的：

■ 看一眼队头元素

■ 随机访问（删除、修改）

■ 遍历（只读）

■ 延时操作（延迟队列 -DelayQueue）

■ 动态容量：JAVA 那边的线程池默认的策略是，当到达核心线程数之后，队列满了，就创建一个新线程。

● 如果要设计并发队列，需要考虑什么因素？

○ 并发对性能的影响，要支撑住高并发。

■ 基于锁的实现

■ 原子操作实现

○ 是否固定容量（动态容量）

■ 怎么个动态法

● 怎么扩容

● 要不要缩容？怎么缩？

■ 初始化容量，或者默认容量

○ 写的时候，是否允许读？

■ 很多其它语言的并发队列，都不允许。

■ 假如说，我们要允许读，你觉得难点在哪里？

● 你要考虑完整的读出来，不能读到修改了一半的版本

● 读哪一个版本

● 假如说我这里有一个场景，是需要读队列的多个元素，同时你也在修改，这时候我读出来的：

○ 全部都是你修改前的

○ 一部分你修改前的，一部分是你修改后的

○ 持久化问题：队列中的元素要不要转储/持久化

○ 阻塞问题：

■ 读的时候，队列没数据怎么办？阻塞，还是返回 nil？

■ 写的时候，队列满了怎么办？阻塞，还是直接返回（或者返回特定错误）？

■ 阻塞是否要超时的问题？

● 设计一个 Queue 接口

### 扩展讨论

● 大明的改进线程池：

○ v1：概率 = （队列中元素数量/队列的容量），假如说我现在队列里面有 20 个元素，然后容量是 100。连续 2 个任务过来，进入队列的时候，不创建新线程的几率是 80% * 79%

○ v2: 当元素数量小于某个阈值的时候，不会创建，然后在大于某个阈值之后，按照 v1 的算法去开线程

● 读写锁：

○ 读优先：只要有人拿着读锁，即便来一个人要写锁，后面再来的人，还是可以拿到读锁

○ 写优先：有人拿着读锁，但是只要有人请求写锁，后面再来的人，就拿不到读锁了

### 课后练习

将 SliceQueue 改为并发队列，支持阻塞，并且支持阻塞超时控制

## 10.22

### 课后练习

尝试实现一个延时队列。

就是：当我 dequeue 的时候，拿到的元素是已经过期的元素，如果没有过期元素，则阻塞直到有过期元素，或者超时。

我入队的时候，每个元素都有一个过期时间。

## 10.29

### 课后练习

尝试一下使用 time.Timer 来作为入队信号
