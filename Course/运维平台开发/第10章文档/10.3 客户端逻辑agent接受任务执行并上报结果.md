
# 01 定义单一任务的结构体和方法
- 在agent目录下新建 taskjob/task.go
- 定义task结构体
```go
package cron

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path"
	"strings"
	"sync"

	"github.com/toolkits/pkg/file"
	"github.com/toolkits/pkg/logger"
	"github.com/toolkits/pkg/sys"
)

type Task struct {
	sync.Mutex

	Id      int64  //uid
	JobId   int64  //任务id
	Clock   int64  // 完成时间
	Action  string // 动作
	Status  string // 状态
	MetaDir string // 本地元信息目录

	alive  bool      //是否还在运行中的标志位
	Cmd    *exec.Cmd // cmd对象
	Stdout bytes.Buffer
	Stderr bytes.Buffer
	// 元信息
	Script  string
	Args    string
	Account string
}
```
- 设置一系列的任务方法
```go
// 设置状态
func (t *Task) SetStatus(status string) {
	t.Lock()
	t.Status = status
	t.Unlock()
}
// 获取状态
func (t *Task) GetStatus() string {
	t.Lock()
	s := t.Status
	t.Unlock()
	return s
}
// 判断是否还在运行中
func (t *Task) GetAlive() bool {
	t.Lock()
	pa := t.alive
	t.Unlock()
	return pa
}
// 设置在运行中
func (t *Task) SetAlive(pa bool) {
	t.Lock()
	t.alive = pa
	t.Unlock()
}
// 获取标准输出
func (t *Task) GetStdout() string {
	t.Lock()
	out := t.Stdout.String()
	t.Unlock()
	return out
}
// 获取错误
func (t *Task) GetStderr() string {
	t.Lock()
	out := t.Stderr.String()
	t.Unlock()
	return out
}
// 重置错误和输出的buffer
func (t *Task) ResetBuff() {
	t.Lock()
	t.Stdout.Reset()
	t.Stderr.Reset()
	t.Unlock()
}
// 通过.done文件判断任务是否完成
func (t *Task) doneBefore() bool {
	doneFlag := path.Join(t.MetaDir, fmt.Sprint(t.Id), fmt.Sprintf("%d.done", t.Clock))
	return file.IsExist(doneFlag)
}
// 加载任务的记过
func (t *Task) loadResult() {
	metadir := t.MetaDir

	doneFlag := path.Join(metadir, fmt.Sprint(t.Id), fmt.Sprintf("%d.done", t.Clock))
	stdoutFile := path.Join(metadir, fmt.Sprint(t.Id), "stdout")
	stderrFile := path.Join(metadir, fmt.Sprint(t.Id), "stderr")

	var err error

	t.Status, err = file.ReadStringTrim(doneFlag)
	if err != nil {
		log.Printf("[E] read file %s fail %v", doneFlag, err)
	}
	stdout, err := file.ReadString(stdoutFile)
	if err != nil {
		log.Printf("[E] read file %s fail %v", stdoutFile, err)
	}
	stderr, err := file.ReadString(stderrFile)
	if err != nil {
		log.Printf("[E] read file %s fail %v", stderrFile, err)
	}

	t.Stdout = *bytes.NewBufferString(stdout)
	t.Stderr = *bytes.NewBufferString(stderr)
}
func (t *Task) meta() (script string, args string, account string) {
	return
}

```
- 准备任务的相关目录
```go
// 准备任务的相关目录
func (t *Task) prepare() error {
	//if t.Account != "" {
	//	// already prepared
	//	return nil
	//}

	IdDir := path.Join(t.MetaDir, fmt.Sprint(t.Id))
	err := file.EnsureDir(IdDir)
	if err != nil {
		log.Printf("[E] mkdir -p %s fail: %v", IdDir, err)
		return err
	}

	writeFlag := path.Join(IdDir, ".write")
	if file.IsExist(writeFlag) {
		// 从磁盘读取
		argsFile := path.Join(IdDir, "args")
		args, err := file.ReadStringTrim(argsFile)
		if err != nil {
			log.Printf("[E] read %s fail %v", argsFile, err)
			return err
		}

		accountFile := path.Join(IdDir, "account")
		account, err := file.ReadStringTrim(accountFile)
		if err != nil {
			log.Printf("[E] read %s fail %v", accountFile, err)
			return err
		}

		t.Args = args
		t.Account = account
	} else {
		// 从远端读取，再写入磁盘
		script, args, account := t.Script, t.Args, t.Account

		scriptFile := path.Join(IdDir, "script")
		_, err = file.WriteString(scriptFile, script)
		if err != nil {
			log.Printf("[E] write script to %s fail: %v", scriptFile, err)
			return err
		}

		out, err := sys.CmdOutTrim("chmod", "+x", scriptFile)
		if err != nil {
			log.Printf("[E] chmod +x %s fail %v. output: %s", scriptFile, err, out)
			return err
		}

		argsFile := path.Join(IdDir, "args")
		_, err = file.WriteString(argsFile, args)
		if err != nil {
			log.Printf("[E] write args to %s fail: %v", argsFile, err)
			return err
		}

		accountFile := path.Join(IdDir, "account")
		_, err = file.WriteString(accountFile, account)
		if err != nil {
			log.Printf("[E] write account to %s fail: %v", accountFile, err)
			return err
		}

		_, err = file.WriteString(writeFlag, "")
		if err != nil {
			log.Printf("[E] create %s flag file fail: %v", writeFlag, err)
			return err
		}

		t.Args = args
		t.Account = account
	}

	return nil
}

```
- 启动/kill 任务
```go
// 启动任务
func (t *Task) start() {
	if t.GetAlive() {
		return
	}
	err := t.prepare()
	if err != nil {
		return
	}
	args := t.Args
	if args != "" {
		args = strings.Replace(args, ",,", "' '", -1)
		args = "'" + args + "'"
	}
	nowPath, _ := os.Getwd()
	scriptFile := path.Join(nowPath, t.MetaDir, fmt.Sprint(t.Id), "script")
	sh := fmt.Sprintf("%s %s", scriptFile, args)
	logger.Infof("[scriptFile:%+v][shCmd:%+v]", scriptFile, sh)
	var cmd *exec.Cmd
	if t.Account == "root" {
		cmd = exec.Command("sh", "-c", sh)
		cmd.Dir = "/root"
	} else {
		cmd = exec.Command("su", "-c", sh, "-", t.Account)
	}

	cmd.Stdout = &t.Stdout
	cmd.Stderr = &t.Stderr
	t.Cmd = cmd
	err = cmd.Start()
	if err != nil {
		log.Printf("[E] cannot start cmd of task[%d]: %v", t.Id, err)
		return
	}

	go runProcess(t)
}


func runProcess(t *Task) {
	t.SetAlive(true)
	defer t.SetAlive(false)

	err := t.Cmd.Wait()
	if err != nil {
		if strings.Contains(err.Error(), "signal: killed") {
			t.SetStatus("killed")
			logger.Debugf("process of task[%d] killed", t.Id)
		} else {
			t.SetStatus("failed")
			logger.Debugf("process of task[%d] return error: %v", t.Id, err)
		}
	} else {
		t.SetStatus("success")
		logger.Debugf("process of task[%d] done", t.Id)
	}

	persistResult(t)
}
// 任务结果落盘
func persistResult(t *Task) {
	metadir := t.MetaDir

	stdout := path.Join(metadir, fmt.Sprint(t.Id), "stdout")
	stderr := path.Join(metadir, fmt.Sprint(t.Id), "stderr")
	doneFlag := path.Join(metadir, fmt.Sprint(t.Id), fmt.Sprintf("%d.done", t.Clock))

	file.WriteString(stdout, t.GetStdout())
	file.WriteString(stderr, t.GetStderr())
	file.WriteString(doneFlag, t.GetStatus())
}


// kill任务
func (t *Task) kill() {
	go killProcess(t)
}
// 杀进程
func killProcess(t *Task) {
	t.SetAlive(true)
	defer t.SetAlive(false)

	logger.Debugf("begin kill process of task[%d]", t.Id)

	err := KillProcessByTaskID(t.Id, t.MetaDir)
	if err != nil {
		t.SetStatus("killfailed")
		logger.Debugf("kill process of task[%d] fail: %v", t.Id, err)
	} else {
		t.SetStatus("killed")
		logger.Debugf("process of task[%d] killed", t.Id)
	}

	persistResult(t)
}

func KillProcessByTaskID(id int64, metadir string) error {
	dir := strings.TrimRight(metadir, "/")
	arr := strings.Split(dir, "/")
	lst := arr[len(arr)-1]
	return sys.KillProcessByCmdline(fmt.Sprintf("%s/%d/script", lst, id))
}

```

# 02 管理task的taskmap
- 新建taskjob\tasks.go ，定义管理task的taskmap
```go
// 定义管理task的taskmap
type LocalTasksT struct {
	M       map[int64]*Task
	MetaDir string
}

var Locals *LocalTasksT

func InitLocals(metaDir string) {
	Locals = &LocalTasksT{
		M:       make(map[int64]*Task),
		MetaDir: metaDir,
	}
}
```
- 上报任务的结果方法
```go
// 上报任务的结果方法
func (lt *LocalTasksT) ReportTasks() []serverRpc.ReportTask {
	ret := make([]serverRpc.ReportTask, 0, len(lt.M))
	for id, t := range lt.M {
		rt := serverRpc.ReportTask{Id: id, Clock: t.Clock}

		rt.Status = t.GetStatus()
		if rt.Status == "running" || rt.Status == "killing" {
			// intermediate state
			continue
		}

		rt.Stdout = t.GetStdout()
		rt.Stderr = t.GetStderr()

		stdoutLen := len(rt.Stdout)
		stderrLen := len(rt.Stderr)

		// 输出太长的话，截断，要不然把数据库撑爆了
		if stdoutLen > 65535 {
			start := stdoutLen - 65535
			rt.Stdout = rt.Stdout[start:]
		}

		if stderrLen > 65535 {
			start := stderrLen - 65535
			rt.Stderr = rt.Stderr[start:]
		}

		ret = append(ret, rt)
	}

	return ret
}
// 根据任务id获取task
func (lt *LocalTasksT) GetTask(id int64) (*Task, bool) {
	t, found := lt.M[id]
	return t, found
}
// 把任务设置到本地map中
func (lt *LocalTasksT) SetTask(t *Task) {
	lt.M[t.Id] = t
}
```
- 分配任务，首先从本地map中获取任务
- 如果找到了就更新任务的动作，比如kill任务
- 然后启动新的任务，将task塞入map中管理
```go
// 分配任务，首先从本地map中获取任务
// 如果找到了就更新任务的动作，比如kill任务
// 然后启动新的任务，将task塞入map中管理
func (lt *LocalTasksT) AssignTask(at *models.TaskMeta) {
	local, found := lt.GetTask(at.Id)
	if found {
		if local.Clock == at.Clock && local.Action == at.Action {
			// ignore repeat task
			return
		}

		local.Clock = at.Clock
		local.Action = at.Action
	} else {
		if at.Action == "kill" {
			// no process in local, no need kill
			return
		}
		local = &Task{
			Id:      at.Id,
			JobId:   at.Id,
			Clock:   at.Clock,
			Action:  at.Action,
			Account: at.Account,
			Args:    at.Args,
			Script:  at.Script,
			MetaDir:lt.MetaDir,
		}
		lt.SetTask(local)

		if local.doneBefore() {
			local.loadResult()
			return
		}
	}

	if local.Action == "kill" {
		local.SetStatus("killing")
		local.kill()
	} else if local.Action == "start" {
		local.SetStatus("running")
		local.start()
	} else {
		logger.Warningf("unknown action: %s of task %d", at.Action, at.Id)
	}
}
// 清理任务的方法
func (lt *LocalTasksT) Clean(assigned map[int64]struct{}) {
	del := make(map[int64]struct{})

	for id := range lt.M {
		if _, found := assigned[id]; !found {
			del[id] = struct{}{}
		}
	}

	for id := range del {
		// 远端已经不关注这个任务了，但是本地来看，任务还是running的
		// 可能是远端认为超时了，此时本地不能删除，仍然要继续上报
		if lt.M[id].GetStatus() == "running" {
			continue
		}

		lt.M[id].ResetBuff()
		cmd := lt.M[id].Cmd
		delete(lt.M, id)
		if cmd != nil && cmd.Process != nil {
			cmd.Process.Release()
		}
	}
}

```
- 在agent的配置文件中写上meta的字段,config\config.go
```go
type Config struct {
	RpcServerAddr              string                `yaml:"rpc_server_addr"`
	LogStrategies              []*models.LogStrategy `yaml:"log_strategies"`
	HttpAddr                   string                `yaml:"http_addr"`
	EnableInfoCollectAndReport bool                  `yaml:"enable_info_collect_and_report"`
	EnableLogJob               bool                  `yaml:"enable_log_job"`
	Job                        JobSection            `yaml:"job"`
}

type JobSection struct {
	MetaDir  string `yaml:"metadir"`
	Interval int    `yaml:"interval"`
}

```
- open-devops-agent.yml中填写相关的job配置
```yaml
job:
  metadir: ./meta
  interval: 2
```
- 并在main中 初始化
```go
	// 初始化任务缓存
	taskjob.InitLocals(sConfig.Job.MetaDir)
```


# 03 定义rpc 交互的流程
- 新建 rpc\report.go
- 定义一个周期执行的ticker
```go
package rpc

import (
	"context"
	"github.com/go-kit/log/level"
	"github.com/toolkits/pkg/logger"
	"open-devops/src/common"
	"open-devops/src/modules/agent/taskjob"
	serverRpc "open-devops/src/modules/server/rpc"
	"time"
)
func TickerTaskReport(cli *RpcCli, ctx context.Context) error {
	ticker := time.NewTicker(5 * time.Second)

	localIp := common.GetLocalIp()
	cli.DoTaskReport(localIp)
	defer ticker.Stop()
	for {
		select {
		case <-ctx.Done():
			logger.Infof("TickerLogJobSync.receive_quit_signal_and_quit")
			return nil
		case <-ticker.C:
			cli.DoTaskReport(localIp)
		}
	}

}
```
- 在main中开启这个任务的编排
```go
		{
			// 同步任务
			g.Add(func() error {
				err := rpc.TickerTaskReport(rpcCli, ctxAll)
				if err != nil {
					level.Error(logger).Log("msg", "taskjob.TickerTaskReport.error", "err", err)
					return err
				}
				return err

			}, func(err error) {
				cancelAll()
			},
			)
		}
```
- 完成这个周期性rpc交互的任务
- 构造TaskReport的rpc请求，其中ReportTasks来自本地map的任务收集任务
- 遍历rpc的结果，分配任务
```go
func (r *RpcCli) DoTaskReport(localIp string) {
	// 构造TaskReport的rpc请求，其中ReportTasks来自本地map的任务收集任务
	req := serverRpc.TaskReportRequest{
		AgentIp:     localIp,
		ReportTasks: taskjob.Locals.ReportTasks(),
	}
	var resp serverRpc.TaskReportResponse
	err := r.GetCli()
	if err != nil {
		level.Error(r.logger).Log("msg", "get cli error", "serverAddr", r.ServerAddr, "err", err)
		return
	}
	err = r.Cli.Call("Server.TaskReport", req, &resp)
	if err != nil {
		r.CloseCli()
		level.Error(r.logger).Log("msg", "Server.TaskReport.error", "serverAddr", r.ServerAddr, "err", err)
		return
	}
	// 遍历rpc的结果，分配任务
	if resp.AssignTasks != nil {

		count := len(resp.AssignTasks)
		for i := 0; i < count; i++ {
			at := resp.AssignTasks[i]

			taskjob.Locals.AssignTask(at)
		}
	}

}

```


