- [[../07 点赞|07 点赞]]

1. insrCnt
	1. WithContext
	2. Clauses(OnConflict{Doupdates: clasuse.Assignments{map[string]any}})
	3. Create 如果不冲突，就创建一个。
2. gorm.Expr 操作 —— "`read_cnt` + 1"
3. 创建联合唯一索引 —— 文章 - 文章 id
4. Redis HIncrBy 能够保证，read_cnt 不存在，先设置为 0，然后自增 1
5. Lua 脚本执行 read_cnt 自增
6. 检查 — 做某事，容易出现并发问题，所以要用 Redis Lua 脚本去剞劂
7. cnt_key: read_cnt like_cnt or collect_cnt
8. delta +1 or -1
9. 软删除，只是更新状态
10. upsert 语义  
11. 查询接口
	1. 返回文章 + 文章的阅读、点赞、收藏数量
12. 小结
	1. 直接维持住总数，Redis 里面或者 MySQL 中
	2. 如果仅仅维护在 Redis 中，启动的时候，或者 Redis 过期的时候需要执行 Count 操作。
13. 有序问题：业务有序、全局有序
14. 同一个消费者组里面，一个分区最多只有一个消费者
15. 消费者之间的关系
16. ACK
	1. 0 不需要服务端确认
	2. 1 客户端发送，需要写入主分区里面
	3. -1 需要服务端同步到所有 ISR 上
17. 超时 context cancel
18. 指定偏移量消费
	1. 关键调用 ResetOffset 方法
19. 异步消费，批量提交 —— 优化手段 | 点赞，因为可以 offset。
20. 读事件 利用 kafka 解耦。实际上没什么用。读事件时批量处理的。
	1. 凑成一批要注意超时控制
	2. 发起调用
21. 插入 100 条数据提交 100 次，插入 100 条数据和提交 1 次的性能相差很大。
22. 消费者本身类似于 web 服务器的东西，需要启动
23. 引入阅读记录功能，不需要改变任何原来的代码，只需要订阅响应的消息队列即可。
24. 升职加薪
	1. 统一的 MQ 抽象
	2. 生产者 API
	3. 消费者 API
	4. 消息本身的抽象
	5. 参考：https://github.com/ecodeclub/mq-api
25. 生产者端，多条消息聚合成一个一批消息
26. 消息积压的解决方法：
	1. 增加分区、topic 现实中基本不可能
	2. 异步消费：也就是前面例子，开启 goroutine 并发消费，最后合并提交，提高消费者的消费能力
		1. **为什么要合并提交**
		2. **不合并提交有什么问题**
	3. 批量消费：将原本一个业务一个消息，改造成一批业务一个消息，一次处理一批业务，参考 Incr 的解决方案。

---
- [[../08 可观测性 prometheus|08 可观测性 prometheus]]

---

- [[../09 榜单模型与分布式任务调度之榜单模型|09 榜单模型与分布式任务调度之榜单模型]]
- 什么样的才算是热点？
- 如何计算热点？
- 热点必然带来高并发，那么怎么保证性能？
- 如果热点功能崩溃了，怎么样降低对整个系统的影响？

1. Hacknews：得票数最重要，而后热度随着事件衰减
2. Reddit 模型：赞成票、反对票和发帖事件

## 面经

[腾讯 IEG 3.8后台实习一面凉经_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/7fd962836a004d66a27ff9b6a6133830?sourceSSR=users)

1. 操作系统内存管理
	1. 内存分配
	2. 虚拟内存
	3. 分页和分段
	4. 页表和段表
	5. 交换
	6. 内存保护
	7. 垃圾回收
2. 进程调度
	1. 线程是操作系统调度的基本单位
	2. 进程调度算法
		1. 先来先服务
		2. 短作业优先
		3. 时间片轮转
		4. 优先级调度
		5. 多级队列调度
			1. 多个队列 每个队列有自己的调度算法
			2. 队列之间有 优先级，优先级最高的队列优先调度
		6. 多级反馈队列：结合多种调度策略的负复杂系统。
3. 拥塞控制
4. TCP 报文头
5. 如何唯一确定一个 TCP 连接
	1. 5 元组 | 协议类型
6. HTTP1.0 和 HTTP2.0 的区别
	1. 连接复用
	2. 二进制分针
	3. 服务器推送
	4. 头部压缩 HPACK
	5. 请求优先级
	6. 流控制
		1. **初始化窗口大小**：在 HTTP/2.0 连接开始时，会有一个初始的窗口大小（Initial Window Size），这个大小可以通过 SETTINGS 帧进行配置。
		2. **窗口更新**：当接收方处理了一些数据并准备好接收更多数据时，它会发送一个 WINDOW_UPDATE 帧，以增加流控制窗口的大小，告诉发送方它可以发送更多数据了。这个窗口更新可以针对单个流也可以针对整个连接。
		3. **暂停发送**：如果窗口大小被耗尽（即减小到 0），发送方必须停止发送数据，并等待接收方通过发送 WINDOW_UPDATE 帧来增加窗口大小。

[腾讯微信支付一面挂_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/a5d45b436c184c2cb1f41711cc18e54a?sourceSSR=search)

1. 内存管理
2. Channel
3. context
4. 实现一个并发 map
	1. atmoc.Value  
	2. lock

在 Go 语言中，实现一个并发安全的 `map` 并使用乐观锁，可以通过 `sync/atomic` 包提供的原子操作来实现。乐观锁的核心思想是假设没有冲突发生，进行操作，然后在操作完成后检查是否有冲突。如果发现冲突，则放弃本次操作，可能进行重试。

下面是一个简化的示例，展示如何使用乐观锁实现一个并发安全的 `map` 结构。这个示例使用 `atomic.Value` 来存储 `map`，以及原子操作来更新 `map`，从而避免在并发访问时的数据竞争：

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

type ConcurrentMap struct {
    m atomic.Value // 使用 atomic.Value 存储 map
    lock sync.Mutex
}

func NewConcurrentMap() *ConcurrentMap {
    cm := &ConcurrentMap{}
    cm.m.Store(make(map[string]interface{}))
    return cm
}

// Set 方法设置键值对
func (cm *ConcurrentMap) Set(key string, value interface{}) {
    for {
        // 加锁以更新 map
        cm.lock.Lock()
        // 拷贝当前 map，实现写时复制（Copy-on-Write）
        oldMap := cm.m.Load().(map[string]interface{})
        newMap := make(map[string]interface{})
        for k, v := range oldMap {
            newMap[k] = v
        }
        newMap[key] = value
        // 存储更新后的 map
        cm.m.Store(newMap)
        cm.lock.Unlock()
        return
    }
}

// Get 方法获取键对应的值
func (cm *ConcurrentMap) Get(key string) (value interface{}, ok bool) {
    // 直接从 atomic.Value 中读取 map
    m := cm.m.Load().(map[string]interface{})
    value, ok = m[key]
    return
}

func main() {
    cm := NewConcurrentMap()
    cm.Set("hello", "world")
    value, ok := cm.Get("hello")
    if ok {
        fmt.Println("Found value:", value)
    } else {
        fmt.Println("Value not found")
    }
}
```

在这个示例中，`ConcurrentMap` 类型内部使用 `atomic.Value` 来存储实际的 `map` 数据。`Set` 方法首先会创建当前 `map` 的一个拷贝，然后在这个拷贝上做修改，并通过 `atomic.Value` 的 `Store` 方法以原子方式更新存储的 `map`。`Get` 方法直接从 `atomic.Value` 中读取当前的 `map`，从而避免了数据竞争。

请注意，这个示例使用了乐观锁的思想，通过写时复制（Copy-on-Write）来避免写操作的竞争。然而，这个简单实现在大量写操作的场景下可能不是很高效，因为每次写操作都需要复制整个 `map`。对于读多写少的场景，这个实现可以提供较好的并发性能。

COW  

1. 预防死锁：破坏四个死锁必要条件
2. 避免死锁
	1. 资源分配图
	2. 银行家算法
3. 检测死锁：死锁检测算法
4. 解决死锁
	1. 进程剥夺
	2. 进程中华之
	3. 资源回滚
5. 换页算法
	1. 最佳换页算法
	2. 先进先出算法
	3. 最近最少使用 LRU
	4. 时钟算法
	5. LFU 访问频率
6. 设计一个线程池，要考虑哪些参数
	1. 核心线程数
	2. 最大线程数
	3. 工作队列
	4. 线程存货事件
	5. 时间单位
	6. 线程工厂
	7. 拒绝策略
	8. 扩展能力
	9. 任务调度

[腾讯PCG二三面面经分享_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/9eaa151d3cac421eb396e8c5b75c5b21?sourceSSR=search)

两个协程交替打印数组，附加要求: 让第二个协程优先打印

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// 定义两个通道，用于控制打印的顺序
	ch1 := make(chan bool)
	ch2 := make(chan bool)

	// 假设这是要交替打印的数组
	array := []int{1, 2, 3, 4, 5}

	// 第一个打印协程
	go func() {
		for _, value := range array {
			<-ch1 // 等待第二个协程打印
			fmt.Println("Printer 1:", value)
			time.Sleep(time.Millisecond * 500) // 假设打印需要一些时间
			ch2 <- true // 通知第二个协程打印
		}
	}()

	// 第二个打印协程
	go func() {
		for _, value := range array {
			fmt.Println("Printer 2:", value)
			time.Sleep(time.Millisecond * 500) // 假设打印需要一些时间
			ch1 <- true // 通知第一个协程打印
			<-ch2 // 等待第一个协程打印
		}
	}()

	// 为了让第二个协程先开始打印，我们需要在开始之前就向ch1发送一个信号
	ch1 <- true

	// 主协程等待，以便打印任务可以完成
	time.Sleep(time.Second * time.Duration(len(array)))
}
```

实现分布式锁：

分布式锁是分布式系统中用于确保多个节点在执行某项任务时能够互斥访问共享资源的机制。由于分布式系统中的节点可能分布在不同的服务器上，传统的进程内锁机制（如互斥锁、读写锁）不再适用，因此需要分布式锁来保证资源的同步访问。

### Redis 实现分布式锁

Redis 实现分布式锁主要是通过 `SET` 命令的 `NX`（Not eXist，如果不存在则设置）和 `EX`（Expire，设置过期时间）选项。这种方式的核心是利用 Redis 的单线程特性，保证操作的原子性。

- **加锁**：
  - 使用 `SET key value NX EX max-lock-time` 命令尝试加锁。
  - 如果返回 `OK`，则加锁成功；如果返回 `nil`，说明锁已经被其他客户端持有。
  - `value` 通常设置为一个唯一标识（如 UUID），这样可以确保只有加锁的客户端能解锁。
  - `max-lock-time` 是锁的过期时间，以避免死锁。
- **解锁**：
  - 客户端删除键来释放锁。
  - 为了安全释放锁，客户端需要检查 `value` 值，确保只解自己加的锁。
  - 这通常通过 Lua 脚本来实现，以保证检查和删除操作的原子性。

```lua
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

### Etcd 实现分布式锁

Etcd 是一个分布式可靠的键值存储，用于配置共享和服务发现，它基于 Raft 算法实现了强一致性。Etcd 可以用来实现分布式锁是通过其提供的 `lease`（租约）机制和 `transaction`（事务）机制。

- **加锁**：
  - 创建一个 `lease`，这个 `lease` 有一个 TTL（Time To Live），作为锁的过期时间。
  - 使用 `lease` 在 etcd 中创建一个键值对，键通常表示锁的名称。
  - 使用事务（transaction）确保在创建键值对的时候键是不存在的，从而确保锁的互斥性。
- **续租**：
  - 定期发送续租请求来维持锁的持有状态。
  - 如果客户端崩溃或无法续租，租约到期后，键值对会被自动删除，从而释放锁。
- **解锁**：
  - 显式删除表示锁的键值对，或者停止续租让租约到期。

分布式锁的实现必须考虑锁的公平性、死锁预防、容错性和性能等因素。Redis 实现较为简单，适合轻量级和性能要求高的场景。Etcd 的实现侧重于一致性和容错性，适合对一致性要求高的场景。

[腾讯IEG 天美 后台开发面经_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/593467348468715520?sourceSSR=search)

- pprof

排查内存泄漏问题是软件开发和维护中的一个重要任务，特别是在长期运行的服务中。内存泄漏会逐渐消耗系统资源，最终可能导致应用程序或系统崩溃。以下是一般性的步骤和方法，以及如何使用 Go 语言的 `pprof` 工具来排查内存泄漏问题。

### 通用步骤排查内存泄漏

1. **确认内存泄漏**：
   - 观察应用的内存使用情况，判断是否存在内存泄漏。可以通过各种监控工具或命令（如 `top`, `htop` 在 Linux 下）来监控内存使用情况。

2. **定位泄漏区域**：
   - 通过日志、监控指标等方式定位可能的泄漏区域。重点关注缓存、全局变量、循环引用等。

3. **代码审查**：
   - 仔细审查疑似泄漏区域的代码，寻找没有正确释放的资源，如文件描述符、数据库连接、未释放的内存等。

### 使用 Pprof 排查 Go 程序的内存泄漏

`pprof` 是 Go 语言提供的一个性能分析工具，可以用来获取 Go 程序的 CPU、内存等方面的性能数据。对于内存泄漏的分析，`pprof` 可以生成堆（heap）的性能剖析报告，帮助定位内存泄漏。

1. **导入 pprof 包**：

   在程序的 `import` 部分导入 `net/http/pprof`。如果你的应用已经运行了 `net/http` 服务器，仅仅通过导入 `pprof` 包就能自动启用 pprof 分析器。

   ```go
   import (
       _ "net/http/pprof"
       "net/http"
   )
   ```

2. **启动 HTTP 服务器（如果应用中没有）**：

   如果你的应用不是一个 HTTP 服务器，你可以专门启动一个 HTTP 服务器来为 pprof 服务。

   ```go
   go func() {
       log.Println(http.ListenAndServe("localhost:6060", nil))
   }()
   ```

3. **生成堆内存剖析报告**：

   当程序运行时，可以通过访问 `http://localhost:6060/debug/pprof/heap` 获取堆内存的剖析报告。

4. **使用 `go tool pprof` 分析**：  
   可以使用 `go tool pprof` 命令行工具下载并分析剖析报告。

   ```bash
   go tool pprof http://localhost:6060/debug/pprof/heap
   ```

5. **在 pprof 交互式界面中分析**：

   `pprof` 提供了一个交互式的命令行界面，可以执行各种命令来分析性能数据。例如：

   - `list` 命令可以列出函数的内存分配细节。
   - `top` 命令显示内存使用的顶级消费者。
   - `web` 命令生成内存分配的图形表示，需要 Graphviz 支持。

### 注意事项

- 分析生产环境中的程序可能会对性能产生影响，建议在低峰期进行。
- 分析内存泄漏时，关注“in-use”（正在使用的内存）而非“alloc”（分配的内存），因为“alloc”包括了已经被垃圾回收的内存。

使用 `pprof` 工具不仅可以帮助开发者定位内存泄漏的问题，还可以深入理解程序的性能特征，是 Go 语言性能优化的有力工具。

- 一个服务器，cpu 利用率很低，但是执行的某个简单计算逻辑经常超时，如何排查

服务器 CPU 利用率很低但执行某个简单计算逻辑经常超时的情况，可能由多种因素导致。排查这类问题时，可以从以下几个方面入手：

### 1. **检查 I/O 等待**

- **磁盘 I/O**：如果应用需要读写大量数据，磁盘 I/O 可能成为瓶颈。
- **网络 I/O**：如果计算依赖于外部服务或数据源，网络延迟或丢包可能导致超时。

### 2. **分析线程和进程状态**

- 检查是否有死锁或资源竞争的情况，这些问题可能导致线程挂起，无法及时完成计算。
- 查看系统的上下文切换次数。频繁的上下文切换可能导致 CPU 资源无法有效利用。

### 3. **审查系统资源限制**

- 查看操作系统对进程或用户的资源限制，例如 CPU 时间、内存使用量等。
- 确认操作系统和中间件（如数据库、Web 服务器）的配置，看是否有限制可能影响性能。

### 4. **应用程序分析**

- 使用性能分析工具（如 `perf`、`gprof`、`pprof`）分析应用程序，确定是哪部分代码执行效率低。
- 检查应用程序日志，查找是否有异常或错误被记录，这些可能是超时的直接原因。

### 5. **查看系统调度和负载**

- 即使 CPU 总体利用率不高，也可能有某个核心的利用率很高，造成任务无法及时调度。
- 检查系统的负载平均值，理解当前系统的工作量。

### 6. **检查外部依赖和第三方服务**

- 如果计算逻辑依赖于外部服务，检查这些服务的响应时间和可用性。
- 考虑引入超时和重试机制，以及断路器模式，提高系统的健壮性。

### 工具和命令

- 使用 `top`、`htop` 查看 CPU、内存等资源的使用情况。
- 使用 `iotop` 查看磁盘 I/O 情况。
- 使用 `iftop` 或 `nethogs` 查看网络流量和连接状态。
- 使用 `strace`、`lsof` 等工具查看进程的系统调用和文件打开情况。

### 实践建议

- **逐步排查**：从观测到的症状出发，一步步缩小问题范围。
- **分离测试**：尝试将问题逻辑单独运行或在其他环境中运行，看是否能复现问题。
- **持续监控**：利用监控工具持续跟踪应用和系统的性能指标，帮助快速定位问题。

通常，这类问题的解决需要综合运用系统监控、应用诊断和代码分析等多种技能和工具。

- golang 内存逃逸概念，如何解决

在 Go 语言中，内存逃逸是一个重要的概念，它指的是在函数中分配的变量不是在栈上分配，而是在堆上分配。栈上的变量在函数返回时自动被清理，而堆上的变量则需要 Go 的垃圾收集器（GC）来回收，这会导致更高的内存使用和潜在的性能损耗。

### 内存逃逸的原因

内存逃逸通常发生在以下几种情况：

1. **变量的生命周期超出了其作用域**：如果一个函数返回了一个在栈上分配的变量的引用，那么这个变量就会逃逸到堆上，因为它在函数返回后依然需要被访问。
2. **大对象或动态大小的对象**：为了避免栈溢出，Go 可能会将大型对象或大小在编译时无法确定的对象分配在堆上。
3. **接口间接引用**：当一个具体类型的变量赋值给一个接口类型时，该变量可能会发生逃逸。
4. **闭包引用**：闭包引用了函数外的变量时，这些变量可能会逃逸到堆上。

### 如何检测内存逃逸

Go 提供了工具来帮助开发者识别内存逃逸，最常用的是通过 `go build` 或 `go run` 命令的 `-gcflags` 标志。

```bash
go run -gcflags='-m' main.go
```

这个命令会输出编译过程中的优化决策，包括哪些变量发生了逃逸。

### 如何减少或避免内存逃逸

虽然内存逃逸分析和优化主要是编译器的工作，但开发者可以通过一些策略来减少内存逃逸，提高程序性能：

1. **避免不必要的指针使用**：如果不需要共享数据，尽量使用值传递而不是指针传递。
2. **使用局部变量替代返回指针**：如果函数需要返回复杂数据但调用者不需要修改原始数据，考虑返回值的副本而不是指针。
3. **避免在循环内部创建闭包**：循环创建的闭包可能会引用循环体外的变量，导致这些变量逃逸。
4. **优化数据结构和算法**：减少不必要的动态内存分配，例如使用固定大小的数组代替切片，或者预先分配足够大小的切片。

### 实践建议

- **代码简洁明了**：简单的代码更容易被编译器优化。
- **性能测试和分析**：使用 Go 的 pprof 工具进行性能分析，找出内存使用高的原因。
- **谨慎优化**：在理解内存逃逸的基础上进行优化，避免过早优化。有时候，即使发生了内存逃逸，对整体性能的影响也可能是微不足道的。

总之，理解内存逃逸对于写出高效、可维护的 Go 代码是很有帮助的。通过合理的代码结构和开发实践，可以减少不必要的内存逃逸，从而提升应用的性能。

- Golang interface 底层如何实现

在 Go 语言中，接口（`interface`）是一种非常强大的特性，它为 Go 提供了一种方式来实现多态和解耦。理解接口的底层实现可以帮助开发者更好地利用 Go 的类型系统，写出更清晰、更高效的代码。

### 接口的底层结构

Go 语言的接口底层是通过两个主要的组件实现的：一个是类型（Type），另一个是数据（Data）。在 Go 的运行时系统中，接口类型的值是由一个指向接口方法表的指针（也称为类型描述符）和一个指向实际数据的指针组成的。

这种实现可以用以下的伪结构表示：

```go
type interfaceValue struct {
    type  *typeDescriptor
    data  *value
}
```

- **`typeDescriptor`**：是一个包含了实际类型信息以及与接口相关的方法集的指针。每个类型，如结构体或自定义类型，都有一个对应的类型描述符，包含了类型的元信息（如名称、方法等）。
  
- **`data`**：是一个指向实际数据的指针。这可以是任何类型的值，该值实现了接口定义的方法。

### 接口的工作方式

当一个具体的类型赋值给接口类型时，Go 运行时会创建一个包含两部分的接口值：

1. **类型部分**：指向该具体类型的类型描述符。
2. **数据部分**：指向实际数据的指针。如果赋值的是一个值类型（如结构体），则 `data` 部分会指向这个值的副本。如果赋值的是指针类型，则 `data` 部分直接指向该指针。

### 方法调用

当通过接口调用方法时，运行时会使用接口的类型部分来找到具体类型的方法集，然后根据方法名定位到具体的方法实现，并使用接口的数据部分作为方法的接收者来执行调用。

### 接口的动态特性

由于接口在运行时存储了关于其值的类型信息，Go 可以在运行时检查接口值的实际类型，或将接口值转换回其原始类型，这是通过类型断言和类型切换实现的。

### 接口的空值

一个没有被任何值赋值的接口的类型和数据部分都是 `nil`。这是检查接口值是否为 `nil` 的一个重要方面：即使接口的数据部分是 `nil`，只要接口的类型部分非 `nil`，接口本身就不是 `nil`。

### 总结

Go 语言的接口底层实现是通过类型描述符和指向实际数据的指针来实现的，这种设计支持了接口的动态特性，使得 Go 在运行时能够进行类型检查和类型转换，同时也支持了多态。理解这些底层细节可以帮助开发者更有效地使用接口，写出更灵活和高效的 Go 代码。

- [Go 语言接口的原理 | Go 语言设计与实现 (draveness.me)](https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/)
