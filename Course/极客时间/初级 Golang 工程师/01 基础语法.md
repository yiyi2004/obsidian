![[Snipaste/Pasted image 20240313101923.png]]

1. 方法 + 运行的上下文
2. 闭包如果使用不当可能会引起内存泄露的问题
	1. 一个对象被闭包引用的化，它是不会被垃圾回收的

![[Snipaste/Pasted image 20240313102103.png]]

1. 先定义后执行
2. 一个方法不能超过 8 个 defer

![[Snipaste/Pasted image 20240313102249.png]]

1. 确定值的原则

![[Snipaste/Pasted image 20240313102350.png]]

- 闭包是指一个方法与跟着这个方法绑定的运行时刻上下文

![[Snipaste/Pasted image 20240313102627.png]]

- 放在一个地方的，不可以取地址哦。

![[Snipaste/Pasted image 20240313102753.png]]

1. ArrayList

![[Snipaste/Pasted image 20240313102926.png]]

1. 是否内存共享 ---> 又没有扩容

![[Snipaste/Pasted image 20240313103358.png]]

- 组合不是继承，没有多态

![[Snipaste/Pasted image 20240313103439.png]]

## 升职加薪指南

![[Snipaste/Pasted image 20240313132220.png]]

![[Snipaste/Pasted image 20240313132229.png]]

![[Snipaste/Pasted image 20240313132239.png]]

## 面试要点

面试要点

- 什么是闭包?闭包有什么缺陷?
	- 匿名函数 + 运行时上下文
	- 缺陷是可能导致内存逃逸
- 什么情况下会出现栈溢出?
	- 深度递归调用
- 什么是不定参数?调用方法的时候，不定参数可以传入 0 个值吗?方法内部怎么使用不定参数?
- 什么是 defer?你能解释 - 下 defer 的运作机制吗?
- 一个方法内部 defer 能不能超过 8 个?
- defer 内部能不能修改返回值?怎么改?
- 数组和切片有什么区别?
- 切片怎么扩容的?

### Defer 实现机制

![[Snipaste/Pasted image 20240313132630.png]]

1. 主动回答
2. 内部实现分为三种实现机制
	1. 堆上分配：GC
	2. 栈上分配：性能好 30%
	3. 开放编码：启用内敛优化
		1. defer <= 8
		2. defer 不能在循环中执行
		3. return X defer <= 15

![[Snipaste/Pasted image 20240313132915.png]]

1. 栈上分配只能有一个 defer

![[Snipaste/Pasted image 20240313133217.png]]

![[Snipaste/Pasted image 20240313133226.png]]

1. byte
2. for no
3. 15 硬性指标

defer 开放编码的启用条件

![[Snipaste/Pasted image 20240313133411.png]]

![[Snipaste/Pasted image 20240313133445.png]]

然而，在后续的版本中（如 Go 1.18），Go 团队将这个阈值调整为 256。这种调整是基于对 Go 程序的广泛分析，旨在更好地平衡内存使用和性能。较低的阈值意味着对于较小的切片，Go 会更早地转向更温和的增长策略，这有助于避免因过度分配内存而导致的浪费。

## 作业

![[Snipaste/Pasted image 20240313133518.png]]
