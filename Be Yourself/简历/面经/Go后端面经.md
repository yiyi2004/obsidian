1. 笔试
2. 自我介绍
3. 项目介绍
	1. 介绍项目的具体详情，为什么要写这个项目，具体是怎么实现的

## 深维智讯 2.27（OC 已拒）

笔试 1h：逻辑题、语言特性、三大件、算法题  
面试 1h：  
自我介绍  
项目选一个介绍  
项目提问

**MySQL 事务隔离级别**  

- 未提交读
- 已提交读 RC
- 不可重复读 RR
- 串行化

**覆盖索引**

- 覆盖索引指的是命中的索引是联合索引，不需要回表进行查询。这样可以减少一次回表，性能更高。

**SQL 执行慢，如何排查**

- 可以通过通过开启慢查询日志查询
- 可以通过 explain 看 SQL 的执行计划、是否命中索引、是否全表烧苗、各个操作的成本估算。

当遇到 SQL 查询执行缓慢的问题时，可以采取以下步骤进行排查和优化：

1. **检查查询计划**：
   - 使用 `EXPLAIN` 或者 `EXPLAIN ANALYZE` 命令查看 SQL 查询的执行计划。这可以帮助你理解数据库如何执行你的查询，包括它是如何使用索引的，是否有全表扫描，以及各个操作的成本估算。
2. **优化查询语句**：
   - **简化查询**：尝试简化查询逻辑，避免复杂的子查询，可以考虑将复杂查询拆分成多个简单查询。
   - **减少数据量**：尽量减少查询返回的数据量，比如通过具体的条件过滤不必要的记录，使用 LIMIT 限制返回的行数。
   - **使用索引**：确保你的查询能够有效地利用索引。没有被索引的列在进行搜索时会导致全表扫描，极大地影响性能。
3. **数据库索引优化**：
   - **添加或调整索引**：根据查询计划中的信息，确定是否需要为某些列添加索引。同时，注意不要过度索引，因为这会增加写操作的成本。
   - **索引维护**：定期维护索引，比如重建或重新组织索引，以确保查询效率。
4. **服务器和硬件资源检查**：
   - **资源瓶颈**：检查数据库服务器的 CPU、内存、磁盘 I/O 是否有瓶颈。高负载或资源饱和可能会导致查询执行缓慢。
   - **配置优化**：调整数据库服务器的配置设置，如内存分配、缓存大小等，以适应实际的工作负载。
5. **查询分析器和监控工具**：
   - 使用数据库提供的查询分析器和监控工具来收集和分析性能数据。这些工具可以帮助你发现慢查询，分析数据库的性能瓶颈。
6. **数据库表结构优化**：
   - **归档旧数据**：定期清理或归档旧数据，减少表的大小，可以提升查询性能。
   - **表分区**：对于非常大的表，考虑使用分区技术，将数据分布到多个物理分区中，以提高查询效率。
7. **避免锁争用**：
   - 确保查询不会因为与其他事务的锁争用而被阻塞。分析和优化事务的设计，减少长事务，合理使用事务隔离级别。

**B+ 树和跳表的查询的时间复杂度**

O(logn)

**Redis 持久化** #不懂

1024&1023

**三次握手四次挥手**

在面试中解释 TCP 的三次握手和四次挥手时，你可以按照以下结构进行回答：

TCP 三次握手（连接建立）

三次握手（Three-way Handshake）的目的是可靠地建立两个 TCP 主机之间的连接。它包括以下步骤：

1. **SYN**：客户端发送一个 SYN（同步序列编号）报文到服务器，并进入 SYN_SEND 状态，等待服务器确认。
2. **SYN-ACK**：服务器接收到客户端的 SYN 报文，回送一个 SYN-ACK（同步确认应答）报文，确认收到了客户端的 SYN。同时，服务器将自己的 SYN 报文发送给客户端。服务器进入 SYN_RECV 状态。
3. **ACK**：客户端收到服务器的 SYN-ACK 报文后，会发送一个 ACK（确认）报文，当服务器接收到这个 ACK 报文时，连接建立成功。

这个过程主要是为了确认双方的接收和发送能力都是正常的。

TCP 四次挥手（连接释放）

四次挥手（Four-way Handshake）的目的是可靠地关闭两个 TCP 主机之间的连接。它包括以下步骤：

1. **FIN**：当主机完成数据发送后，会发送一个 FIN（结束）报文给对方，并进入 FIN_WAIT_1 状态。
2. **ACK**：接收方收到 FIN 报文后，会发送一个 ACK 报文给发送方，并进入 CLOSE_WAIT 状态。发送方收到 ACK 后，进入 FIN_WAIT_2 状态。
3. **FIN**：接收方准备好关闭连接时，发送一个 FIN 报文给发送方，并进入 LAST_ACK 状态。
4. **ACK**：发送方收到这个 FIN 后，发送一个 ACK 报文给接收方，然后进入 TIME_WAIT 状态。经过一段时间后，确保对方收到 ACK 报文，发送方关闭连接。接收方收到 ACK 后立即关闭连接。

这个过程中涉及四次挥手是因为 TCP 是全双工模式，双方都需要单独关闭自己的发送和接收通道。

补充说明

- 在三次握手中，第三次握手是确认双方的接收能力和发送能力都正常。
- 在四次挥手中，需要四步是因为当一方完成数据发送后，还需要确保对方所有的数据都接收完毕才能完全关闭连接，而且 TCP 连接是全双工的，每个方向都必须单独进行关闭。

正确理解并能够清晰表述这两个过程对于理解 TCP 协议的可靠性机制非常重要。

**Time-Wait 和 Closed-Wait**

在 TCP 协议中，`TIME-WAIT` 和 `CLOSE-WAIT` 是两种不同的状态，它们出现在 TCP 连接的生命周期中的不同阶段，主要涉及连接的终止过程。下面是这两个状态的详细解释：

**TIME-WAIT** 状态

- **定义**：`TIME-WAIT` 状态发生在 TCP 四次挥手过程的最后阶段。当一个 TCP 连接正在关闭，并且主动关闭连接的一方（通常是客户端）发送了最后一个 ACK 响应后，它会进入 `TIME-WAIT` 状态。
  
- **目的**：
  - 确保最后一个 ACK 报文能够到达对方。如果对方没有收到这个 ACK，它会重新发送 FIN 报文，`TIME-WAIT` 状态的一方应该对此做出响应。
  - 允许旧的重复分段在网络中消失。这样可以避免在新的连接中出现旧连接的数据包，确保下一个连接是干净的。
- **持续时间**：这个状态通常会持续 2 倍的 MSL（Maximum Segment Lifetime，最大报文生存时间），MSL 通常假定为 2 分钟，因此 `TIME-WAIT` 状态通常持续 4 分钟。

**CLOSE-WAIT** 状态

- **定义**：在 TCP 四次挥手过程中，当被动关闭连接的一方（通常是服务器）收到对方发送的 FIN 报文，确认对方要求关闭连接后，它会发送 ACK 响应并进入 `CLOSE-WAIT` 状态。
- **目的**：`CLOSE-WAIT` 状态表示等待本地应用程序关闭连接。在这个状态下，TCP 连接的这一端知道对方想要关闭连接，但在它可以发送自己的 FIN 报文之前，需要等待本地应用程序决定完成剩余的数据发送并正式关闭连接。
- **行为**：在 `CLOSE-WAIT` 状态下，应用程序应该**继续读取**任何到达的数据，并最终**调用关闭连接**的操作。完成这些操作后，它会发送 FIN 报文给对方并进入 `LAST-ACK` 状态，等待对方的最后一个 ACK 响应。

区别总结

- `TIME-WAIT` 是主动关闭连接方的一个状态，保证连接被平滑地关闭，避免在网络中的旧数据包影响新连接。
- `CLOSE-WAIT` 是被动关闭连接方的状态，**等待本地应用程序关闭连接**。

正确管理这些状态对于维护 TCP 连接的可靠性和性能至关重要。尤其是在高性能网络应用中，理解这些状态如何影响资源利用和连接管理非常重要。

**chmod751**

Owner Group Others  
读 写 执行

## 螣龙安科 2.28（OC 已拒）

**Redis string 底层** #不懂

**Gin 特性**

Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。它是一个类似于 martini 但拥有更好性能的 API 框架，由于使用了 **httprouter**，性能提升显著。Gin 是处理高性能请求的理想选择。以下是 Gin 的一些显著特性：

1. **快速**：Gin 使用了自定义的 HTTP 路由器，它比 Go 的标准库、mux 和其他路由器更快。其性能接近原生 HTTP 处理。
2. **轻量级**：Gin 提供了最基础的、核心的功能，避免了额外的库和依赖，使得框架保持简洁和轻量。
3. **中间件支持**：Gin 支持中间件，允许用户在处理请求和响应之前或之后执行代码，非常适合处理日志、用户认证、数据校验等任务。
4. **错误管理**：Gin 提供了一种便捷的方式来集中处理请求过程中发生的错误。
5. **路由分组**：支持路由分组功能，能够共享相同的路径前缀、中间件等，这对于构建具有共同 URL 前缀的路由集合非常有用，例如 API 版本管理。
6. **JSON 验证**：Gin 提供了结构体绑定和验证的功能，支持绑定 JSON、XML 和标准表单值等数据，并且可以对绑定的数据进行验证。
7. **模板渲染**：内置模板渲染功能，支持 HTML、XML、JSON 等格式的响应，方便构建不同的 Web 应用。
8. **高度可定制**：Gin 的设计允许高度的定制，包括自定义中间件、绑定器、渲染等。
9. **强大的性能与内存优化**：Gin 经过了精心优化，旨在减少内存分配，提高处理速度，使其成为构建高性能应用的理想选择。
10. **社区支持**：Gin 拥有活跃的社区和大量的外部库，方便开发者扩展功能和解决问题。

Gin 通过提供简洁的 API、出色的性能和高度的可扩展性，成为了 Go 开发者构建 web 应用和微服务的热门选择。

**sync.map** [[../../../Coding/Go/深入理解go/Go Map 原理|Go Map 原理]]

**JWT 单点登录**  

[[../../../Course/极客时间/初级 Golang 工程师/03 Session 和 JWT|03 Session 和 JWT]]

**Slice 并发访问**

**Slice 扩容**

**map 底层实现 B 的作用** [[go map]]

**MySQL 事务**

事务提及如何保证一致性

BufferPool

口述算法：

**三数之和**

**最长回文子串**

## 好未来 2.28 一面

mysql：

事务隔离级别、索引优化、查看 SQL 使用索引 (explain)

redis：

数据类型

String 和 Hash 区别

过期策略

如何让一个 key 过期

主要结合项目拷打 redis、mysql

作者：池敖池恩  
链接：[https://www.nowcoder.com/discuss/593098900697788416?sourceSSR=post](https://www.nowcoder.com/discuss/593098900697788416?sourceSSR=post)  
来源：牛客网

## 好未来 Go 实习面经 （挂）

处女面，双非 无实习 区域铜。2.29 技术面主管面 hr 面。3.4 挂。  
无项目问题（6.824，简单微服务，xv6），无算法问题，这是 kpi 吗？kpi 为啥还有 hr 面。  

1. map 是否线程安全  
2. **gin 框架大致原理**   
3. 进程线程协程，如何实现协程  
4. mysql 事务隔离级别  
5. 可重复读和读已提交差别，举例说明，简单讲了 mvcc  
6. 可重复读不适用场景  
7. 幻读问题  
8. 联合索引  

场景题：  

1. 分数和年龄两个字段，联合索引顺序。  
2. redis 排行榜

作者：haria_  
链接：[https://www.nowcoder.com/feed/main/detail/8156f85cafb44b97b8b7fe65732f09b9?sourceSSR=search](https://www.nowcoder.com/feed/main/detail/8156f85cafb44b97b8b7fe65732f09b9?sourceSSR=search)  
来源：牛客网

本人 25 届，目前收到快手电商 Java 实习的正式 offer，base 杭州。百度网盘商业化 Golang 实习口头 offer（开始走流程），base 北京。本人是 Java 技术栈为主，觉得以后秋招也是以 Java 技术栈为主，但是感觉百度的 title 会不会更好一些。想听听各位牛友的建议  

作者：junzuoguan  
链接：[https://www.nowcoder.com/feed/main/detail/a740c67812094f588d9977dbbcc3e54a?anchorPoint=comment](https://www.nowcoder.com/feed/main/detail/a740c67812094f588d9977dbbcc3e54a?anchorPoint=comment)  
来源：牛客网

## 滴滴地图三面速通

一面：  
实习项目  
**go 的 gin？go 服务？**  
连数据库用的哪个库  
**MySQL 的数据库的锁**  
锁触发条件/情况  
**go 的 GPM 模型简单介绍**  
**go 的垃圾回收**  
**进程和线程的区别**  
**进程间通信方式**  
**线程间通信方式**  
**常用的 Linux 命令**  

在 Linux 操作系统中，有许多常用的命令可以帮助您完成日常的文件管理、系统维护、网络配置、程序运行等各种任务。以下是一些最基础且常用的 Linux 命令及其简单描述：

1. **目录和文件操作命令：**
   - `cd`：改变当前工作目录。
   - `ls`：列出目录内容。
   - `pwd`：打印当前工作目录的绝对路径。
   - `mkdir`：创建新的目录。
   - `rmdir`：删除空目录。
   - `rm`：删除文件或目录（使用 `-rf` 参数可递归删除非空目录）。
   - `cp`：复制文件或目录。
   - `mv`：移动或重命名文件和目录。
   - `touch`：创建新文件或更新已有文件的访问和修改时间。
   - `ln`：创建硬链接或符号链接。

2. **文件内容查看和编辑：**
   - `cat`：合并并打印文件内容到标准输出。
   - `less` 或 `more`：分页查看文件内容。
   - `head`：查看文件开头部分内容。
   - `tail`：查看文件结尾部分内容，`tail -f` 实时跟踪文件末尾变化。
   - `vim` 或 `nano` 或 `emacs`：文本编辑器，用于编辑文件内容。

3. **文件权限和所有权管理：**
   - `chmod`：更改文件或目录的权限。
   - `chown`：更改文件或目录的所有者。
   - `chgrp`：更改文件或目录所属的组。

4. **系统信息查询：**
   - `uname`：显示系统信息，如内核名称、版本等。
   - `uptime`：查看系统运行时间和负载情况。
   - `top` 或 `htop`：实时显示系统状态和进程资源占用情况。
   - `free`：查看内存使用情况。
   - `df`：报告文件系统的磁盘空间使用情况。
   - `du`：估算文件或目录所占磁盘空间大小。

5. **搜索文件和内容：**
   - `find`：根据名称、类型、大小、时间等条件搜索文件。
   - `grep`：在文件中搜索符合模式的行。

6. **压缩和解压缩：**
   - `gzip`、`gunzip` 或 `zcat`：gzip 压缩和解压。
   - `bzip2`、`bunzip2` 或 `bzcat`：bzip2 压缩和解压。
   - `tar`：打包和解包文件，支持多种压缩格式。

7. **网络和通信：**
   - `ping`：测试网络连通性。
   - `ifconfig`（旧版）或 `ip`（新版）：查看和配置网络接口。
   - `netstat`（旧版）或 `ss`（新版）：显示网络连接、路由表等信息。
   - `curl` 或 `wget`：从互联网下载文件。

8. **进程控制：**
   - `ps`：报告当前系统中进程的状态。
   - `top` 或 `htop`（增强版）：动态查看和管理进程。
   - `kill` 或 `pkill`：结束进程。
   - `jobs`：查看当前 shell 环境下已启动的任务列表。
   - `fg` 或 `bg`：将后台任务调至前台运行或恢复后台运行。

9. **软件安装和包管理：**
   - 在 Debian/Ubuntu 系列中：`apt-get` 或 `apt`。
   - 在 CentOS/RHEL/Fedora 系列中：`yum` 或 `dnf`。

10. **其他常用命令：**
    - `man`：查看命令的手册页。
    - `history`：查看历史命令记录。
    - `clear` 或 `Ctrl + L`：清屏。
    - `echo`：输出字符串或变量值。
    - `alias`：设置命令别名。

以上只列举了一部分常见命令，实际使用的命令远不止这些，具体使用时可根据需要查阅更详细的命令手册。

**队列和栈的区别**  
图的了解  
图上两点的最小距离何种算法  

- Dijkstra 算法和 Floyd 算法

goroutine 中有哪几种锁  

**手撕：快排**  

二面：  
论文项目介绍  
实习项目介绍  
更新缓存数据场景的应对  
**go 中多态的实现**  
定位是偏网络 数据库 还是 Web  
Web 框架的使用  
**gin 对于用户登录态的处理**  

在 Gin 框架中，处理用户登录态通常涉及到 session 或者 token 的管理。以下是一种基于 JWT（JSON Web Tokens）的处理方式：

1. 用户登录时，验证用户名和密码是否正确。如果正确，服务器生成一个 JWT，这个 JWT 包含了用户的唯一标识符以及其他可能需要的信息，并且设置了过期时间。然后将 JWT 通过 HTTP Header 或 Cookie 返回给客户端。

```go
import (
    "github.com/gin-gonic/gin"
    "github.com/dgrijalva/jwt-go"
)

func login(c *gin.Context) {
    var user User // 假设 User 是你的用户模型结构体
    if err := c.ShouldBind(&user); err == nil {
        // 验证用户名和密码逻辑...
        if ok := validate(user.Username, user.Password); ok {
            token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "username": user.Username,
                "exp":      time.Now().Add(time.Hour * 24).Unix(), // 设置 token 过期时间为24小时
            })
            tokenString, _ := token.SignedString([]byte("your_secret_key")) // 签名并生成 token 字符串
            c.JSON(200, gin.H{
                "token": tokenString,
            })
        } else {
            c.JSON(401, gin.H{"error": "Invalid username or password"})
        }
    } else {
        c.JSON(400, gin.H{"error": "Invalid request body"})
    }
}
```

1. 客户端在后续请求中，将 JWT 放在 Authorization 请求头中（通常是 Bearer 模式），发送给服务器。
2. 服务器在每个受保护的路由中间件中，解析并验证 JWT，验证通过则继续执行后续操作，否则返回未授权错误。

```go
func authenticateMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.AbortWithStatusJSON(401, gin.H{"error": "Unauthorized"})
            return
        }

        tokenString := strings.Replace(authHeader, "Bearer ", "", 1)
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
            if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
                return nil, fmt.Errorf("Unexpected signing method: %v", token.Header["alg"])
            }
            return []byte("your_secret_key"), nil // 这里应使用与签发时相同的密钥
        })

        if err != nil {
            c.AbortWithStatusJSON(401, gin.H{"error": "Unauthorized"})
            return
        }

        if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
            // 获取到的 claims 可以用于获取用户信息或进行其他权限校验
            username := claims["username"].(string)
            // ...
        } else {
            c.AbortWithStatusJSON(401, gin.H{"error": "Unauthorized"})
        }
        
        c.Next()
    }
}

// 使用中间件
router.GET("/protected", authenticateMiddleware(), func(c *gin.Context) {
    // ...
})
```

注意：上述代码仅作示例用途，请根据实际需求调整并确保安全性，如对 secret key 的安全存储和使用等。同时，JWT 不适合存储过于敏感的数据，因为它在传输过程中是明文的，尽管可以被签名但不能被加密。对于非常敏感的信息，建议结合 HTTPS 和后端数据库一同处理。

用户态的管理，用户登录态的保持  
多个进程（含同名进程）全部杀掉的 Linux 命令  

三面：  
**项目中遇到的一个有挑战的技术问题，如何解决的，解决思路**  

- 索引优化、性能优化等等功能，高并发的场景

**B+ 树索引**  

B+ 树（B-plus Tree）是一种广泛应用于数据库和文件系统中用于索引的数据结构，尤其在关系型数据库管理系统如 MySQL 中扮演着关键角色，它优化了磁盘 I/O 密集型环境下的数据检索性能。  

**B+ 树的主要特点**

1. **层级结构**：B+ 树是一个自平衡的多路搜索树，它的每个节点包含多个键和对应数量的指针。B+ 树的阶表示每个节点最多有多少个孩子，它决定了树的扇出度（即每个节点可以有多少个子节点）。相比 B 树，B+ 树的每个节点通常能存储更多的键值对和指针，从而使得树的高度更低，减少了磁盘 I/O 次数。
2. **叶节点存储数据**：在 B+ 树中，所有的数据都存储在叶子节点上，而非叶子节点仅存储索引（键值对），并不直接保存实际的数据行。并且，所有叶子节点形成了一个有序链表，这样有利于范围查询和全表扫描。
3. **高扇出性**：B+ 树的节点具有较高的扇出性，这意味着在一个节点内可以存储大量的键值和指针，从而保证即使数据量很大，树的高度也能维持在较低水平，通常在 2 到 4 层之间，这对于减少磁盘寻址的 I/O 次数至关重要。
4. **聚簇索引与辅助索引**：
   - **聚簇索引**（Clustered Index）：在 InnoDB 存储引擎中，主键索引采用的就是聚簇索引，数据行的实际内容就储存在叶子节点上，按照主键的顺序排列。因此，一张表只有一个聚簇索引，它决定数据行的物理存储顺序。
   - **辅助索引**（Secondary Index，又称非聚集索引）：除了主键索引外的其他索引都是辅助索引，它们的叶子节点存储的是相应键值以及对应的主键值，而不是实际的行数据。
5. **范围查询友好**：由于所有叶子节点形成连续的有序链表，对于需要范围查询的情况，B+ 树只需要沿着叶子节点的链表顺序扫描即可，无需像 B 树那样回溯父节点，大大提高了效率。

总结来说，B+ 树索引的设计理念是为了最大化地利用外部存储（如磁盘）的特点，通过合理的数据分布和组织形式，使得数据读取更加高效，尤其适合大量数据和频繁的查询操作场景。  

wgs84  

WGS84（World Geodetic System 1984）是一种全球大地坐标系标准，由美国国防部研制并在 1984 年确定，被广泛应用于地理信息系统、航空航海、测绘、GPS 全球定位系统等领域。它是目前国际上公认并普遍采用的地心坐标系统之一。

在 WGS84 坐标系中，主要特点包括：

- 原点位于地球质心。
- Z 轴指向国际时间局（BIH）在 1984.0 定义的协议地球极（CTP）方向，即地球自转轴在某一特定时刻的方向。
- X 轴指向 BIH1984.0 的零度子午面（Prime Meridian）和 CTP 赤道的交点，也即是国际本初子午线穿过赤道的地方。
- Y 轴通过右手定则确定，从而构成右手直角坐标系。

WGS84 还包括了一个地球参考椭球体模型，用来逼近地球的形状，并提供了精确的参数来描述地球表面的几何特征。这一模型被用于计算地理位置的经纬度坐标、海拔高度以及相关空间位置的转换。

随着时间的推移，WGS84 经历了多次修订，以改进其精度，每一次修订都会产生一个新的版本，例如通过 GPS 卫星网络收集数据来进行细微修正。由于其与 GPS 系统的紧密联系，WGS84 成为现代导航、定位和遥感应用的基础坐标框架。

**谷歌卫星影像数据的组织形式，如何覆盖一个地球以及缩放**  
**缓存预热方案的背景与解决方案**  

所谓缓存预热，就是提前把数据库里的数据刷到缓存里，通常有这些方法：

1. 直接写个缓存刷新页面或者接口，上线时手动操作
2. 数据量不大，可以在项目启动的时候自动进行加载
3. 定时任务刷新缓存

缓存预热（Cache Priming）是在缓存系统中的一种策略，主要是指在应用程序启动之初或者在服务可用之前，预先将一些重要的、经常访问的数据加载到缓存系统中，以便当用户发起请求时可以直接从缓存中获取数据，而不是等到有请求到达时才触发缓存填充，这样可以显著提升系统的响应速度和服务质量。

背景：

- **性能优化**：对于依赖缓存提供高性能的服务而言，首次请求时如果数据不在缓存中，就需要从持久化存储（如数据库）中加载，这通常比从缓存中读取慢得多，可能导致延迟增加和系统负载突增。
- **高峰时段应对**：在高峰期到来之前进行缓存预热，可以防止大量并发请求在同一时间尝试加载相同数据而造成的“缓存雪崩”现象，保证服务稳定性。
- **热点数据**：对于那些访问频度极高或者重要性极强的热点数据，必须确保它们始终存在于缓存中，以提供近乎实时的服务体验。

解决方案：

1. **手动预热**：开发人员编写专门的脚本或页面，在服务部署或重启后手动触发加载关键数据到缓存。
2. **自动预热**：
   - **项目启动时预加载**：应用程序初始化阶段，可以通过监听启动事件，自动化加载高频访问的数据到缓存中。
   - **定时任务**：设定定时任务，在固定时间段或周期性地将预期会访问的数据加载到缓存。
   - **事件驱动**：基于业务逻辑，当发生某些事件（如数据库数据变更）时触发预热操作。
3. **增量预热**：只预热最近新增或更新的数据，而不是每次全部重新加载。
4. **全量预热**：适用于数据量相对较小的情况，在系统启动时一次性加载所有缓存数据。
5. **分布式缓存预热**：对于大型分布式系统，可能需要设计复杂的分布式缓存预热策略，确保多个节点上的缓存同步和有效预加载。
6. **API Gateway 预热**：在 API Gateway 层面设计预热策略，当流量入口感知到服务启动或配置变更时，主动发起预热请求。
7. **监控和智能预热**：结合监控工具和 AI 算法预测哪些数据可能会变成热点数据，并提前进行预热，实现智能化管理缓存。

总之，缓存预热的具体实现方式会根据应用场景、数据量、系统架构等因素的不同而有所差异，目标是让缓存系统能在真正开始服务时处于准备就绪的状态。

**Redis 数据如何做淘汰**  

Redis 数据淘汰策略（ eviction policy）是在 Redis 内存使用达到用户预设的 `maxmemory` 上限时触发的一种机制，用于在内存不足时自动删除部分数据以腾出空间。Redis 提供了多种淘汰策略供用户选择，以下是其中几种主要的淘汰策略：

1. **volatile-lru**：仅针对设置了过期时间（TTL）的键进行淘汰，通过 LRU（Least Recently Used）算法来选择最近最少使用的键进行删除。
2. **allkeys-lru**：对所有键（包括没有设置过期时间的键）使用 LRU 算法淘汰。
3. **volatile-lfu**：仅针对设置了过期时间的键，使用 LFU（Least Frequently Used）算法淘汰访问频率最低的键。
4. **allkeys-lfu**：对所有键使用 LFU 算法淘汰。
5. **volatile-random**：随机淘汰设置了过期时间的一个键。
6. **allkeys-random**：随机淘汰任意一个键，无论其是否有过期时间。
7. **volatile-ttl**：优先淘汰即将过期的键，也就是说，根据键的剩余生存时间（TTL）进行淘汰，生存时间越短的键越先被淘汰。
8. **noeviction**（默认策略）：不允许任何数据被驱逐，当内存满时，所有引起更多内存分配的操作都会返回错误，除非是 DEL 或者 UNLINK 这样的删除操作。

选择合适的淘汰策略需要根据您的应用特性和数据访问模式来决定。在 Redis 配置文件中（如 redis.conf），通过设置 `maxmemory-policy` 参数来指定使用哪种淘汰策略。一旦达到 `maxmemory` 限制，Redis 就会依据所选策略开始淘汰数据。

**Redis 中的 Key 如何设计**

在 Redis 中设计 Key 是至关重要的，因为良好的 Key 设计可以提升数据查询效率、节省存储空间并简化维护。以下是一些建议和最佳实践：

1. **命名规范**：
   - **简洁明确**：Key 应该尽可能简短，减少网络传输开销，同时易于理解和记忆。例如，`user:1234:name` 表示用户 ID 为 1234 的用户名信息。
   - **有意义**：Key 应该能够表达其存储的内容，遵循一定的命名约定，例如使用冒号（:`）、破折号（-）或下划线（_）分隔字段，便于阅读和理解。
   - **统一前缀**：为不同类型的数据添加统一前缀，如 `user:`, `order:`, `session:` 等，方便分类管理和批量操作。
2. **结构化设计**：
   - **嵌套结构**：对于关联性强的数据，可以考虑使用 Hash 结构，比如 `user:1234` 作为一个 Hash 键，内部包含多个字段如 `name`, `email` 等。
   - **集合和列表**：若数据需要按集合或列表存储，如用户关注列表，可以设计为 `followers:1234`。
3. **过期时间**：
   - 对于临时或有生命周期的数据，如 Session、验证码等，设置合适的过期时间（TTL）非常重要，避免内存中积累大量无用数据。
4. **大小控制**：
   - 注意 BigKey 问题，避免单个 Key 的 Value 过大（例如大于几兆字节），以免影响 Redis 性能和网络带宽。
   - 使用合适的 Redis 数据结构（如 Set、Sorted Set 等）替代大体积的 String 类型，降低存储成本。
5. **扩容与分区**：
   - 如果应用需要横向扩展，考虑在 Key 设计时加入分片标识，使数据均匀分布在多个 Redis 实例中。
6. **避免热点 Key**：
   - 避免所有客户端都频繁访问同一 Key，如果不可避免，可以考虑使用 Lua 脚本减少网络往返次数。
7. **事务与批处理**：
   - 在设计 Key 时考虑到原子操作和批处理的需求，比如使用 pipeline 或 multi/exec 事务。
8. **冗余与一致性**：
   - 根据业务需求，可能需要设计带有备份或镜像功能的 Key，例如使用 Redis 主从复制或集群。
9. **删除策略**：
   - 适时地清理不再使用的 Key，尤其是在有限内存场景下，配合 Redis 的淘汰策略。

综上所述，设计 Redis Key 的关键是兼顾可读性、易维护性、性能优化及资源利用率。同时，还要结合具体的业务场景和技术要求做出合理的选择。

Redis 具体设计的原理  

Redis 的设计原理可以从以下几个核心方面进行详细说明：

1. **内存数据库**：
   - Redis 是一个纯内存数据库，它将所有数据存储在内存中，以此实现快速的数据读写操作。内存存储意味着读写速度接近于处理器的速度，相较于传统的硬盘存储，大幅度提升了性能。
2. **数据结构丰富**：
   - Redis 不仅仅是一个简单的键值存储系统，它支持五种基本数据结构：字符串（Strings）、列表（Lists）、集合（Sets）、有序集合（Sorted Sets）和哈希表（Hashes）。这些数据结构提供了丰富多样的操作，例如列表的 push/pop、集合的交并差运算、有序集合的范围查找等，满足多种业务场景需求。
3. **单线程模型**：
   - 采用了单线程事件驱动模型，所有客户端请求都在同一个线程中顺序执行。虽然看似单线程限制了并发能力，但由于数据在内存中，不存在传统数据库磁盘 I/O 瓶颈，所以单线程足以充分利用 CPU 并发处理网络请求。同时，单线程避免了锁竞争，简化了编程模型，提高了系统的稳定性和性能。Redis
4. **异步持久化**：
   - Redis 提供两种持久化机制，分别是 RDB（Redis Database）和 AOF（Append Only File）：
     - RDB：通过定时快照的方式将内存中的数据保存到磁盘上，是一种周期性全量持久化的方法，**适合灾难恢复场景**。
     - AOF：记录每一个写命令到日志文件中，当 Redis 重启时再重新执行这些命令来重建数据，支持多种不同的持久化策略和日志重写优化，可以实现更高的数据安全性。
5. **网络模型**：
   - Redis 使用了基于 Reactor 模式的网络库，如 **epoll**（Linux）或 kqueue（BSD/Mac OS X），能够高效地处理大量并发连接，支持非阻塞 I/O。
6. **复制与高可用**：
   - Redis 支持主从复制（Replication），主节点的数据会异步复制到从节点，从而实现数据的备份和故障转移。
   - Redis Sentinel（哨兵）系统提供了自动化的故障检测和恢复，能够选举新的主节点，保持 Redis 集群的高可用性。
   - Redis Cluster 则实现了数据的分布式存储和管理，通过分片（Sharding）技术分散数据压力，支持线性水平扩展。
7. **Lua 脚本与事务**：
   - Redis 支持在服务器端执行 Lua 脚本，可以在服务器端一次执行多个命令，保证原子性和减少网络延迟。
   - Redis 的事务支持多条命令的一次性执行，采用 Multi/Exec 模式，但需要注意的是 Redis 的事务不保证严格的 ACID 特性，而是提供一种简单的命令序列执行。
8. **性能优化**：
   - Redis 自身实现了多种优化技术，包括高效的内存管理、数据结构的紧凑存储、字典的渐进式 rehash 等，最大限度地减少内存消耗和 CPU 开销。

以上是 Redis 的几个主要设计原理，这些特性共同构成了 Redis 高性能、低延迟、持久化、高可用的 NoSQL 数据存储系统。

timeline:10.9 投递 -10.12 三面速通 -12.15OC-12.19offer

作者：99 小菜鸡  
链接：[https://www.nowcoder.com/feed/main/detail/10340b068c664dc7b4a6155609de5e72?sourceSSR=search](https://www.nowcoder.com/feed/main/detail/10340b068c664dc7b4a6155609de5e72?sourceSSR=search)  
来源：牛客网

## 简历怎么写

- [看看一份标杆简历的分析（建议收藏）_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/566984772325515264?sourceSSR=search)

## 寄了！，有请下一位天才中单

### 百度后端实习 一面凉经

15min

### 自我介绍 + 问项目

数据库表是怎么建的，数据读取流程是怎么样的

redis 用到了那些结构，是怎么保持数据一致性的

我看你有整合日志，你是怎么对日志分级的

怎么串联起日志的上下游（不会）

25 Min

### Golang 基础

slice 和 array 的区别

slice 的扩容过程

大切片和小切片的耗时是一样的吗

defer 的执行流程，顺序

### Mysql

mysql 有那些索引

你项目里的 mysql 是怎么建索引的

索引树的数据结构是什么样的

联合索引的流程，结构

走索引和不走索引的流程

mysql 的锁了解吗（只知道行锁）

行锁解决了哪些问题（不会）

### Redis

你项目里有用到 hash 吗，具体是什么样的

hash 的底层数据结构是什么（不会）

string 的底层数据结构是什么

redis 的缓存策略有哪些

reids 的缓存开着和关着的时候对读写有什么影响吗（不会）

redis 过期删除策略有那些

知道分布式锁吗

用 redis 实现分布式锁的流程是什么样的

在分布式锁中怎么防止等待太久或者因为故障不能解锁

分布式锁解决了什么单机锁不能解决的问题（没答到点上）

### 数据结构

聊聊链表和二叉树的区别，插入，搜索方面

10min

### 算法

**一个二叉树从树的右边看，看到的值是哪些**

```go
		if depth == len(res) {
			res = append(res, node.Val)
		}
```

作者：lustresix  
链接：[https://www.nowcoder.com/discuss/567019741512990720?sourceSSR=search](https://www.nowcoder.com/discuss/567019741512990720?sourceSSR=search)  
来源：牛客网

## 滴滴 秋招 网约车 后端开发 一二面（凉经）

### 一面 10.12（43min）

- 自我介绍
- 实习经历
- MySQL 性能慢的原因
- 联合索引 (a, b, c)，where b = 1，能走吗，where a = 1，能走吗
- MySQL 索引原理
- B+ 树更扁 有什么好处
- InnoDB 默认隔离级别
- 可重复读级别是怎么实现的
- 限流算法
- 手撕
    - 力扣 92.反转链表 II
    - 力扣 53.最大子数组和
- 项目
- Redis 持久化
- AOF 文件存储的是什么类型的数据
- 反问

### 二面 10.12（50min）

- 自我介绍
- 挑一个项目详细介绍一下 背景、遇到了什么问题、你是怎么解决的
- 实习项目
- Go 协程模型
- 协程创建过程（启动 main 函数初始化，它会创建哪些协程、哪些 G、哪些 M、哪些 P、队列是什么时候创建的、全局队列是什么时候创建的）
    - 这块不会，跟面试官说我是主 Java 的，然后问了我线程池的创建过程
- 线程池中的线程，工作的时候是什么状态，不工作的时候是什么状态
- 线程在什么场景下会变为 `Blocked` 状态
- 线程 进程区别
- 介绍 CMS 或者 G1 的回收过程
- CMS 怎么识别出来对象可以被回收的
- 可达性分析算法
- 除了可达性分析算法还有什么标记法
- JMM 工作内存和主内存怎么交互的
- volatile
- 如果不加 volatile，值会从哪读
- 共享内存和工作内存有什么区别
- TCP 怎么保证可靠性
- 超时重传，时间设置不当会有什么问题
- 滑动窗口 接收方窗口过大会有什么影响
- MySQL 事务，读已提交、可重复读
- 手撕
    - 力扣 33. 搜索旋转排序数组
    - 力扣 300. 最长递增子序列
- 反问

> 手撕最后一道没撕出来，直接秒挂了。写成了最长连续递增子序列，太扯淡了..

> 每轮面试 2 道手撕，没顶住呀。

作者：海苔 ___  
链接：[https://www.nowcoder.com/discuss/567296604001009664?sourceSSR=search](https://www.nowcoder.com/discuss/567296604001009664?sourceSSR=search)  
来源：牛客网

## 百度二面

百度实习二轮面试

好消息，一面过了，坏消息，二面更炸

### 纯聊天

5min

为什么来北京

未来职业规划

非常轻松

### Golang 相关

10min

GMP 的底层实现

map 的底层实现

扩容，缩容的流程（缩容不太懂）

锁的底层原理

设计一个并发安全的 map

你知道泛型吗，和 interface 的区别

你写 golang 的时候遇到什么坑吗

### 计算机网络

5min

从输入域名到返回页面的全部流程

负载均衡的策略（不会）

限流的例子

### 设计

5min

设计一个好友系统，要什么技术（答得非常不好）

如何保证 redis 双写一致

Gin 框架的底层实现是什么（只知道中间件和路由前缀树）

### 算法

5min

两数之和，共享屏幕在自己 idea 上写就行，非常尴尬我少了一个，l++，出了 bug 一次

### 反问

您觉得我还有什么不足，我现阶段学习的方向，面对生产环境怎么办之类的

### 总结

这次时间非常短，30 几分钟不到，面试官非常和气，我说不会都是笑着说没事可以学的那种，（但是估计心里想的是怎么会有这种 sb），虽然感觉又寄了但是面试体验很好，一点都不紧张，哎，只能说技不如人是这样的。二面项目完全没问，感觉就是层次上了一个台阶真正开始问素养方面了，，，还得多练

作者：lustresix  
链接：[https://www.nowcoder.com/discuss/567743711845560320?sourceSSR=search](https://www.nowcoder.com/discuss/567743711845560320?sourceSSR=search)  
来源：牛客网

## 字节暑期实习二面面经

1.自我介绍  
2.项目深挖 (挖穿了…问了个底儿朝天)![](https://uploadfiles.nowcoder.com/images/20220815/318889480_1660553876047/9F754803BEAE3E73E7C878EC3BB2001D)  
3.gc 垃圾回收算法  
4.Spring 设计模式: 举例说明  
5.ThreadLocal 以及底层实现原理  
6.有哪几种常见的线程池  
7.讲讲线程池的工作方式  
8.手撕算法，需要手写输入输出实例  
字符串的最长不重复子串长度  
(滑动窗口或者动态规划都可以实现)  
9.你觉得秒杀有什么难解决的技术难点？  
(我没做过秒杀项目嘤嘤嘤不知道面试官为什么问秒杀相关 只蒙了应该有瞬间高并发问题和库存数据一致性的问题)  
怎么解决呢？不会了…![](https://uploadfiles.nowcoder.com/images/20220815/318889480_1660553763930/8B36D115CE5468E380708713273FEF43)  
10.反问: 部门业务和技术栈

作者：重金属音乐爱好者  
链接：[https://www.nowcoder.com/feed/main/detail/007df2c150b84121b10d470de49ad3c8?sourceSSR=search](https://www.nowcoder.com/feed/main/detail/007df2c150b84121b10d470de49ad3c8?sourceSSR=search)  
来源：牛客网

## 京东 Golang 开发面经 （挂 Go 掌握程度不足）

### 一面 9.16 60min

- 讲一下项目
- go 语言的掌握程度
- 数据结构
- go 语言的 map
- 拉链法的优缺点
- 拉链法如何优化
- 负载因子调到 1 会有什么后果
	- 空间利用率提高，但是发生冲突的可能性也增大了
- 数据库
- 数据库索引有哪些
- sql 建表  
	设计一张字生表：表需求是可以记录学生姓名、出生日明、手机 号、是否在读。邮箱。家庭地址、生表现评价 常见查询条件为姓名、出生日期、手机号、是否在读
- 这个表有什么缺陷
- 新加一个学号字段要考虑什么
- 数据库四大特性
- innodb 默认隔离级别
- rr 是怎么实现的
- 网络
- tcp 三次握手
- ip 位于哪层？icmp 位于哪层？ping 命令位于哪层？
	- ip 网络层，icmp 网络层，ping 应用层
- telnet 是什么操作？位于哪层？
	- telnet 测试映射端口或远程访问主机，应用层
- https 加密过程 (这个我不太清楚 如果有大佬知道 麻烦评论区指点一下)

### 二面 9.27 35mn

- 二面面试官：" 看你简历感觉你对 go 的接触程度不是特别深 你需要在接下来的过程中说服我
- 对哪些语言比较熟悉
- 为什么很多大厂都用 go
- 说一说对 slice 的认识
- slice 如何做深拷贝
- 数据库
- 如何避免回表
- 标识性差的字段一定不能做索引列吗？
- 标识性差的字段为什么不能用来做索引列？
- b 和 b+ 树的区别
- mysql 默认隔离级别
- rr 如何解决不可重复读

作者：留不住的四月  
链接：[https://www.nowcoder.com/discuss/353158536559534080](https://www.nowcoder.com/discuss/353158536559534080)  
来源：牛客网

## 字节飞书 Golang 二面实习面经 (已 OC)

(应该是 g 了,easy 算法没做出来)

1. 算法 (手里一副扑克牌, 第一张放在桌面上,第二张放回手牌底部, 重复第一步直到手里没牌. 根据桌子上的牌, 推出手里的牌)
2. 一面试完下来就秒了, 面试半小时找规律, 结果发现做错了
3. 讲讲线程、协程、进程区别
4. 讲讲你最喜欢哪个语言,为什么 (ababa, 说了 go 比 java 以来管理简单,但是他说 maven 其实比 mod 强的不是一点)
5. 微服务的优点?对比单体的优点?(聊了十几分钟, 但是面试官都说这种单体其实也可以)
6. 每个业务单独开来,自己用自己的数据库, 高内聚 低耦合 服务分工明确 (那单体也可以划分模块呀?)
7. 可以实现多部署, 高可用 (单体也可以部署多个呀?)
8. 微服务, 如果一个服务挂了, 其余的服务还可以支持, 起码有容错 (我单体部署几百个,也可以呀?)
9. 分布式部署,对机器压力小 (我微服务分几个部署在我的机器上, 浪费资源不是更多吗?)
10. 其实如果真的服务器很少的话, 单体也可以, 看业务的体量和需求吧
11. 说到了负载均衡, 负载均衡有哪些技术?
12. RR
13. 哈希取模
14. 一致性哈希
15. 怎么实现负载均衡呢?
16. nginx
17. nginx 在哪里实现?
18. 网关服务
19. nginx 在 osi 哪一层, 负载均衡在哪一层?
20. 讲一下 golang 协程池, 作用是什么? (扯了 10 分钟, 感觉不符合面试官预期)
21. 资源复用 (但是 goroutine 本来就很轻, 感觉没有必要复用呀?)
22. 限制资源个数, 避免高并发过多 goroutine 冲垮服务器
23. 还有呢? 不知道了…
24. 输入 url 到渲染的总流程
25. 输出 10 分钟
26. 为什么二进制的文件到了客户端,浏览器可以看到多彩的画面
27. html?js?css?
28. 又给了一道巨简单的题目, 算是做出来了.
29. 反问
30. 学习的建议
31. 和胜任字节实习生,能力 gap 多少, 需要从哪里改进
32. 被发现套话了,他说第二个问题其实是想知道面试结果吧,我就回答第一个好了…

哎, 头痛一整天, 算法脑子又宕机, 字节 886 😭

面试官还是很和蔼的 0.0

----

11.18 接好运, 2 面已过, 我是字节的🐶

作者：Lewy 华  
链接：[https://www.nowcoder.com/discuss/554371366380650496](https://www.nowcoder.com/discuss/554371366380650496)  
来源：牛客网

## 字节飞书后端实习 Golang 一面面经

1. 手写 LRU
2. 说一下 golang 协程调度
3. 说一下如果你要设计一款 RPC 框架，你会如何设计
4. 看你说到了负载均衡，说一下一致性哈希
5. MySQL 的事务如何实现的
6. 看你会 Kitex，说一下这个你了解多少
7. 说一下你觉得你项目中的难点，或者最有价值的东西
8. 刚开你说到了 ZSet，底层是什么数据结构
9. 这个底层的 Hashtable 时间复杂度
10. 说一下项目里面的 Channel+Select 调度
11. 项目里的 Redis 限流
12. 反问：
13. 字节对实习生的期待
14. 对我的建议

作者：Lewy 华  
链接：[https://www.nowcoder.com/discuss/551074669743378432?sourceSSR=users](https://www.nowcoder.com/discuss/551074669743378432?sourceSSR=users)  
来源：牛客网

## 松鼠 Ai Golang 后端实习 一面面经

- golang 学了多久
- 我们这边是 php 转 golang，如果要你学 php 写业务，你的一个学习的方法是什么样的
- golang 的内存模型
- golang 垃圾回收
- golang 数组和切片的底层实现
- 给你一个容量 15 的切片，截取他的 [2:20] 可以吗
- mysql 底层数据结构
- b+ 树叶子结点的数据结构，怎么连接的
- mysql 有很多种 int 类型，每种的大小多少
- tinyint 的范围是多少
- mysql 里面创建的时候 int1 int10 有啥区别
- 用户数据库分库分表，你会怎么分
- 那比如 1 亿个用户，你会通过那些字段来分
- char varchar 区别
- count * count 1 count 字段 的区别
- 那 count * count 字段的时候，某些字段有 null，那有啥区别？
- 看你项目有用 redis，说一下常用的数据结构
- 项目里怎么用的，zset 评论区怎么弄的
- 看你有用 redis 实现令牌桶，讲一下令牌桶的思想
- redis 用的什么数据结构实现的令牌桶
- 看你有用 rocketmq 做消息队列，为什么不用 redis 做呢？
- kafka 的 ack 机制了解吗？每个值对应哪种情况？
- 反问业务

作者：Lewy 华  
链接：[https://www.nowcoder.com/discuss/552458157377728512?sourceSSR=users](https://www.nowcoder.com/discuss/552458157377728512?sourceSSR=users)  
来源：牛客网

## 字节跳动 - 头条后端 (Go)- 暑期实习面经（已接 offer）

第一份实习，拿到 offer 才敢写面经系列…

面试经验总的来说：

- 心态一定要好，多和面试官交流，不要沉默，实在不会大方承认
- 简历上的项目一定要熟，项目用到的东西也要熟，用到 redis 必问
- 面试官喜欢问为什么，多查查，遇到了就能装 b
- 算法题需要亿点运气

### 一面（3.22）55min

面试官是个小姐姐，nice

1. 自我介绍
2. 扒项目
    - 主要工作，遇到的困难
    - 一些细节问题，改进方案
3. go 垃圾回收
    - 不太熟，大概描述了一下，提了一嘴 Python（简历上写了熟悉 Python），小姐姐说没关系，说下 Python 是怎么做的
4. hashmap（说了 go 的 map 和 redis 的 hash 结构）
5. redis rehash 过程
6. rehash 过程中添加数据，查询数据怎么办？（就是问渐进式 rehash，刚好没看到，瞎猜了半天）
7. hash 冲突用的什么方法解决的？查询时间？最坏时间？
8. 你说链地址法冲突到一条链上会退化成 O(n)，它不好为什么要用？为什么不用其他的？
    - 没太明白她的意思，我只是说最坏情况可没说它不好。。然后只能说它们各有优缺点吧
    - 应该再说一下链地址法的主要优势的
9. 一道没见过的算法题

> 给出一个分子式，比如：HMg2(H2ON3)3N2，计算这个分子式中每个原子出现了多少次，输出一个 map，比如上面的分子式中：map[string]int {"H": 7, "Mg": 2,"O": 3, …}
> 1. 都以大写字母开头，后面跟 0 个或者 1 个小写字母，比如 Mg, H
> 2. 单个原子后面跟 0 个或者 1 个数字表示它出现的次数，比如 Mg2 表示 Mg 出现 2 次，数字范围 2-9
> 3. 分子式中可能有括号，括号后面可能跟 0 个或者 1 个数字表示整个括号内的原子出现的次数，比如 (N3Ag)2 表示 N 出现 6 次，Ag 出现 2 次 4. 括号可以嵌套
> 4. 输入是合法的

上来就遇到这么长的题让我很慌，加上之前 redis 被问到不会，这里感觉都要停止思考了。。看了半天说想办法从后往前把数字乘进去去掉括号再处理，问她思路有没有问题，得到肯定回答才松了一口气，然后说了下具体方法，理清之后面试官把括号去掉了，然后说时间不够了写下简化版代码吧

1. 反问

算法题写了有二三十分钟，感觉要凉了，没想到结束时面试官说先别走啊，我去喊一下二面面试官，瞬间复活

### 二面（3.22）1h

逐渐有状态了，二面还算轻松，全程在线，当时感觉过挺快，回头一听才发现问了这么多问题

1. gmp
    
2. 协程的优势
    
3. 进程线程区别
    
4. 进程地址空间有哪些划分
    
5. 进程间通信
    
6. 共享内存是怎么回事？映射到实际物理内存的虚拟地址在地址空间的哪一部分（我猜在堆区）
    
7. 虚拟内存
    
8. 页面置换算法（说了局部算法和全局算法）
    
9. LRU 实现思路
    
10. mysql 引擎，它们的区别
    
11. innodb 辅助索引为什么存主键 id，回表不是要浪费时间？
    
12. b+ 树索引优势
    
13. acid
    
14. 隔离级别，可重读是怎么实现的？幻读是怎么回事？间隙锁知道不？
    
15. 读写锁互斥关系，其他分类的锁
    
16. 我看你项目用到了 redis 具体用到了哪些数据结构？（string，hash，zset）
    
17. zset 实现，跳表是怎么回事？高度？时间复杂度？为什么不用 b+ 树？
    
18. redis 是单进程还是多进程？
    
19. 扒项目（另一个爬虫项目）
    
    - 代理服务的默认端口？（第一次听说代理还有默认端口）
    - 页面解析用的什么？
    - 爬虫比较困难的场景？
    - 纯 js 渲染的页面怎么爬？
20. （第一个项目）压测怎么做的？其他一些可以优化的点
    
21. 力扣原题，舒服：力扣 33. 搜索旋转排序数组
    
22. 反问

二面面试官超级 nice，各种引导，问到我不会了就说 ok 没问题，全程给我信心，越面越顺

晚上另一个 hr 小哥哥加我微信约了三面时间，之前联系我的小姐姐不见了，唉

### 三面（3.25）30min

1. 扒项目（收获什么的）
    
2. 我看你项目用了 mongodb，mongodb 存储索引知道吗？和 mysql 比有哪些优势？（回答 mongodb 并不熟，只是毕设想用用新东西，优点就知道非结构化扩展容易，速度快）
    
3. mysql 存储引擎
    
4. 项目用到了 redis 哪些结构（zset，hash），说一说底层实现
    
5. zset 除了跳表 +hash 表外还有其他实现吗？
    
    - 才想起来数据量较小时会用压缩列表实现
    - 又问压缩列表实现的主要目的，答节省内存
6. 进程通信方式
    
7. io 多路复用的几种方法（不熟，就提了下名字）
    
8. cookie session
    
9. 拥塞控制
    
10. 力扣原题，舒服：力扣 15. 三数之和

三面面试官应该是某个部门老大，面相和蔼，问了 30 分钟就结束了，有点慌，没想到结束后 10 分钟 hr 就发来微信约 hr 面了

### Hr 面（3.29）15min

聊天，实习生都没啥好问的

面完晚上我等不及就微信问 hr 结果，说没问题，offer 在审批了，然后就是漫长的等待，中间还赶上清明假期，足足等了一周多才接到 offer，期待成为一名 ByteDancer

作者：两三点雨山前  
链接：[https://www.nowcoder.com/discuss/353157793744101376](https://www.nowcoder.com/discuss/353157793744101376)  
来源：牛客网

## 京东 Golang 开发工程师 校招三面面经，许愿 Offer

去年秋招的时候面试的这家公司，马上又要秋招了，给小伙伴们分享下作参考：

**一面（一个小时左右）**

1. 自我介绍
2. 深挖简历项目
3. 读写锁机制
4. 哈希的存储、查询和冲突
5. Go map 的底层原理
6. Go sync.Map
7. 最后问了我能提前实习时间

**二面** **（20m)**

1. 自我介绍 + 深挖项目
2. 项目相关

**HR 面 (10 分钟左右，很快)**

- 自我介绍
- 深挖项目
- 对京东有什么了解
- 为什么选择这个岗位
- 职业规划

基本就是这些，有需要的小伙伴可以参考一下，也可以看看 **SSP 面试笔记** 上别人的面经；

希望大家的面试都能顺利通过！

## 面经

- [golang面试经验答案总结（一）分享一篇B站后端面经 哔哩哔哩_golang 2年经验面试-CSDN博客](https://blog.csdn.net/jinchenga/article/details/131500407?spm=1001.2014.3001.5502)
- [golang面试经验答案总结（二）字节跳动一面 golang_字节跳动go面试题-CSDN博客](https://blog.csdn.net/jinchenga/article/details/131502376?spm=1001.2014.3001.5502)
