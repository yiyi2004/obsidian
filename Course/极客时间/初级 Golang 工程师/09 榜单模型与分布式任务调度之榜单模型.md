- 需求分析
	- 榜单模型
- 榜单设计与实现
	- 定时任务的基本思路
		- timer
		- cron 表达式
	- 服务接口设计与实现
	- 封装为 job
		- job 接口实现
		- 监控实现
	- 在 wire 里组装
- 查询接口
	- 本地缓存
	- 可用性措施
- 分布式定时任务
	- 使用分布式锁
- 基于 MySQl 设计分布式任务调度与实现

## 需求分析

1. 业务需求：展示一个热点榜单，展示五十条。
2. 从非功能性上来说，热榜功能通常是作为首页的一部分，或者至少是一个高频访问的页面，因此性能和可用性都要非常高。

问题关键点：

- 什么样的才算是热点？
- 如何计算热点？
- 热点必然带来高并发，那么怎么保证性能？
- 如果热点功能崩溃了，怎么样降低对整个系统的影响？

![[Snipaste/Pasted image 20240307151836.png]]

1. 综合考虑**用户的各种行为**
2. 综合考虑**时间**的衰减特性
3. **权重因子**

热点数据模型

1. Hacknews
2. Reddit

![[Snipaste/Pasted image 20240307152000.png]]

1. 得票数的重要性
2. 热度随时间衰减

![[Snipaste/Pasted image 20240307152911.png]]

技术选型的重要性

## 榜单设计与实现

是否需要实时计算？

- 实时计算难点：全表扫描 + 全局排序

![[Snipaste/Pasted image 20240307153130.png]]

解决方案：异步定时计算  

![[Snipaste/Pasted image 20240307153337.png]]

1. 时间间隔
2. 计算时间长度不能太长

进一步

1. 设计缓存，保证极好的查询性能
2. 保证可用性，任何时候都能拿到数据

实现：time.Ticker 定时器

![[Snipaste/Pasted image 20240307153530.png]]

- Context + Ticker 的解决方案

使用 cron 定时任务实现

![[Snipaste/Pasted image 20240307153701.png]]

- cron 表达式  

![[Snipaste/Pasted image 20240307153755.png]]

- 便捷使用方法

![[Snipaste/Pasted image 20240307154907.png]]

计算热榜的算法实现

![[Snipaste/Pasted image 20240307155117.png]]

- 实现一个 xxx 的网站
- 优先级队列

![[Snipaste/Pasted image 20240307155651.png]]

- 热榜实现 #不懂
- 构造第一个测试用例

![[Snipaste/Pasted image 20240307160215.png]]

实现方式 1  

![[Snipaste/Pasted image 20240307160239.png]]

1. 优先级队列
2. 实现逻辑比较简单

![[Snipaste/Pasted image 20240307160423.png]]

- 优化、中断条件。性能是更好的。

![[Snipaste/Pasted image 20240307160700.png]]

1. 加入缓存

![[Snipaste/Pasted image 20240307160836.png]]

![[Snipaste/Pasted image 20240307160937.png]]

坚持面向接口编程

![[Snipaste/Pasted image 20240307161042.png]]

日志采集，系统本身的监控，常见的命令行操作。

修改 wire 完成依赖注入

![[Snipaste/Pasted image 20240307161217.png]]

在 main 中启动

## 查询接口

查询接口的缓存方案

本地缓存实现

![[Snipaste/Pasted image 20240307163606.png]]

在 Repository 上组装

![[Snipaste/Pasted image 20240307163738.png]]

1. 需求分析
2. 业务逻辑
3. TDD 开发
	1. 接口
	2. domain
	3. 数据结构
	4. 多个层级

![[Snipaste/Pasted image 20240307163854.png]]

1. 正常情况下去本地缓存中获取，获取不到就回去 Redis 中获取
2. 可以在 Redis 崩溃的 hi 后，再次尝试从本地缓存获取，此时不会查本地缓存是否已经过期
3. 本地缓存的方案实现起来并不难哦

![[Snipaste/Pasted image 20240307164137.png]]

- fallover 策略

Redis 永不过期

![[Snipaste/Pasted image 20240307164201.png]]

1. 规避数据库故障引起的榜单问题

## 分布式定时任务

## 基于 MySQL 设计分布式任务调度与实现

## 面试指南

![[Snipaste/Pasted image 20240307164344.png]]

1. 极致性能的缓存方案：本地缓存 + Redis 缓存 + 数据库
	1. 查找：本地缓存 ---> Redis ---> 数据库
	2. 更新：数据库 ---> 本地缓存 ---> 最后更新 (或者删除)Redis，核心在于一点，本地缓存的操作几乎不可能的失败。
2. 高级的亮点
	1. 本地缓存可以预加载
	2. 本地缓存可以用作容错
		1. 部分场景可以考虑本地缓存永不过期，异步任务刷新本地缓存。

热榜的其他高并发思路

![[Snipaste/Pasted image 20240307164658.png]]

- 热榜高并发方案 #不懂



## 分布式任务调度

分布式任务调度：

- Redis 实现，不同的任务。

- 多个实例的时候，每个计算一遍，
- 分布式锁 解决方法，开源方案：github.com/gotomicro/redis-lock@latest
- 一个分布式锁是很考察并发水平的。
- 视频 教分布式锁 + 教程
- 时间戳 通知
- 只有一个节点计算
- 广播 本地缓存 Redis 缓存
- Ranking Service 里面分布式锁还是 job 上的分布式锁。

- 释放锁失败怎么办
  - 重试 抖动
  - 手工处理
  - 及时高级
  - 导致下一个人等很长时间
  - 最差的情况下 过期时间

- 同一时刻一个goroutine 运行定时任务
- 3 分钟执行一次，不释放锁。这个节点算不出来。
  - 数据的
  - 拿到锁之后就不释放了，为什么。
- 判断自己有没有维持住分布式锁
  - 维持住了，执行业务逻辑
  - 没有维持住，返回 nil
- 扩大锁的范围
- 各种失败
- 死锁问题，释放没有
- 节点关闭的时候要释放分布式锁 | 暴露 Close 方法。
- 释放资源，事实上的规范，返回一个 Error

![image-20240330152839946](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240330152839946.png)

main 中 close 掉，cancelFunc

## 分布式任务调度（基于MySQL）

- 分布式任务调度中心。我是不是吹牛吹的太大了。

剪切掉，兼容不同的协议。

- MySQL 通用的分布式任务调度方案。
- 用这个分布式任务调度机制，调度我的热榜和其他的定时任务

- MySQL 取代 Redis 排他性
- 确认抢到任务，执行定时任务。

- 定时任务可能有很多，定时同步数据，操作 数据库。
- 抢占了，但是崩了怎么办
  - 非常典型的续约机制，证明自己还活着，更新时间
  - epoch 每次续约，每次续约 +1
  - 检测 epoch 更新时间，如果很久没有更新，失败了
  - 服务注册与发现，可以使用续约机制。

- 防止偶发性的失败，连续三次失败，太晚发现，心跳间隔。
  - 大规模分布式系统，心跳本身就会引起问题
  - 太短、太长了
