- 负载均衡算法
	- 静态负载均衡算法
		- 去那种计算于动态调整
	- 动态负载均衡算法
	- 负载均衡算法选型
- 在 GRPC 中接入负载均衡
	- 关键接口
	- 接入自己的实现
- 不同框架接入负载均衡算法
- 在 gRPC 中实现 fallover 机制
- 高端负载均衡方案
	- 结合熔断、限流、降级的负载均衡
	- 动态判定负载均衡算法

## 负载均衡算法

静态摆烂，不是实际的负载。统计学意义上的

1. 轮询
	1. 假设
		1. 所有服务器的处理能力是一样的
		2. 所有请求所需的资源也是一样的
			1. 不合理
2. 加权轮询
3. 随机
4. 加权随机
5. 哈希
6. 一致性哈希  

![[Snipaste/Pasted image 20240311185841.png]]

1. 在注册中心模型下，服务节点启动的时候会把自己的权重注册进去

### 平滑的加权轮询算法

![[Snipaste/Pasted image 20240311190542.png]]

平滑的加权轮询算法（Smooth Weighted Round-Robin, SWRR）是一种负载均衡算法，它是加权轮询算法的一个变种。相比传统的加权轮询算法，SWRR 在保证服务权重比例的同时，能够更加平滑地分配请求，避免因权重差异较大时出现的请求集中问题。这在处理不同处理能力的后端服务时非常有用。

#### 算法原理

1. **初始化**：为每个服务设置两个权重变量：初始权重（Wi）和当前权重（Ci）。初始权重是固定的，而当前权重在每次选择过程中动态调整。
2. **选择过程**：
   - 在每次选择时，选取当前权重（Ci）最大的服务。
   - 选取后，将其当前权重（Ci）减去所有服务初始权重（Wi）之和。
3. **权重更新**：
   - 无论是否被选中，所有服务的当前权重（Ci）都会在每次选择过程中增加各自的初始权重（Wi）。
4. **重复步骤 2 和 3**，继续下一轮的选择。

#### 示例实现

以下是一个简单的平滑加权轮询算法的示例实现：

```go
package main

import "fmt"

type Server struct {
    Name          string
    Weight        int // 初始权重
    CurrentWeight int // 当前权重
}

func main() {
    servers := []*Server{
        {"Server1", 5, 0},
        {"Server2", 1, 0},
        {"Server3", 1, 0},
    }

    for i := 0; i < 10; i++ {
        server := chooseServer(servers)
        fmt.Println("Chosen:", server.Name)
    }
}

func chooseServer(servers []*Server) *Server {
    total := 0
    var maxServer *Server
    maxWeight := -1

    for _, server := range servers {
        // 增加当前权重
        server.CurrentWeight += server.Weight
        total += server.Weight

        // 选择当前权重最大的服务器
        if server.CurrentWeight > maxWeight {
            maxWeight = server.CurrentWeight
            maxServer = server
        }
    }

    // 被选中的服务器减去权重总和
    maxServer.CurrentWeight -= total
    return maxServer
}
```

这段代码演示了如何在 Go 中实现平滑加权轮询算法。它首先定义了一个 `Server` 结构，包含服务器名称、初始权重和当前权重。`chooseServer` 函数用于根据算法逻辑选择一个服务器，然后在主函数中通过循环多次调用该函数来模拟请求分配过程。

平滑的加权轮询算法通过动态调整每个服务的当前权重，使得服务的选取更加平滑，尤其是在权重差异较大的情况下，能有效避免请求的波动和集中，从而实现更加合理的负载均衡。

1. 初始化相同
2. 加
3. 选
4. 减

### 随机

![[Snipaste/Pasted image 20240311191217.png]]

- 加权随机

![[Snipaste/Pasted image 20240311191250.png]]

### 哈希

![[Snipaste/Pasted image 20240311191321.png]]

加权哈希

![[Snipaste/Pasted image 20240311191334.png]]

### 一致性 Hash

![[Snipaste/Pasted image 20240311191513.png]]

![[Snipaste/Pasted image 20240311191522.png]]

一致性哈希算法（Consistent Hashing）是一种特殊的哈希算法，用于解决分布式系统中的数据分布和负载均衡问题。与传统的哈希算法相比，一致性哈希算法在增加或移除节点时能够最大限度地减少已有数据的迁移，从而提高系统的稳定性和扩展性。一致性哈希算法最初是为了解决互联网缓存问题而提出的，但现在它被广泛应用于各种分布式存储系统中。

#### 基本原理

1. **哈希环**：一致性哈希算法将哈希值空间组织成一个虚拟的圆环，假设哈希值的范围是 0 到 MAX，则可以将这个范围想象成一个环，0 和 MAX 紧挨着。
2. **节点哈希**：系统中的每个节点（可以是服务器或数据存储区域）通过哈希函数计算出一个或多个哈希值，然后将这些哈希值放置在环上的对应位置。
3. **数据哈希**：存储的每条数据也通过哈希函数计算出一个哈希值，然后根据这个哈希值在环上定位，数据将被存储在顺时针方向遇到的第一个节点上。

#### 关键特性

- **分布式**：当系统需要添加或移除节点时，只有该节点在环上的邻近节点会受到影响，大部分的数据仍然可以保持原有的位置，这样就大大减少了数据迁移的开销。
- **负载均衡**：通过为每个节点引入虚拟节点（即在环上为每个节点创建多个哈希值），可以更加均匀地分布数据，避免部分节点过载。
- **高可用性**：在节点故障的情况下，只有存储在该节点上的数据需要被迁移到其他节点，系统的其他部分继续正常工作，从而提高了系统的可用性。

#### 应用场景

一致性哈希算法广泛应用于各种分布式系统中，包括：

- **分布式缓存系统**：如 Memcached、Redis 集群等。
- **分布式数据库**：如 Cassandra、DynamoDB 等。
- **负载均衡**：在负载均衡器中使用一致性哈希算法可以有效地分配请求到后端服务器。

#### 示例

假设哈希环的最大值是 2^32-1（假设使用 32 位哈希函数），我们有三个服务器节点 A、B、C，它们的哈希值分别定位在环上的 1、3、5 位置。现在有一个键 key，其哈希值为 4，根据一致性哈希算法，这个键将被存储在哈希值为 5 的节点 C 上，因为 C 是按顺时针方向遇到的第一个节点。

通过使用一致性哈希算法，系统可以在动态伸缩时保持较高的稳定性和效率，从而解决分布式系统中的一些关键问题。

### 动态负载均衡算法

![[Snipaste/Pasted image 20240311191955.png]]

1. 最少连接数
2. 最少活跃数
3. 最快响应

#### 最少连接数

![[Snipaste/Pasted image 20240311192643.png]]

1. 连接多路复用、一个连接可能有多个请求

#### 最少活跃数

![[Snipaste/Pasted image 20240311192743.png]]

1. 最少请求数量

#### 最快响应时间

![[Snipaste/Pasted image 20240311193031.png]]

1. 平均响应时间
2. 99 线
3. 999 线

### 负载均衡总结

![[Snipaste/Pasted image 20240311193110.png]]

1. 要不要考虑服务器的处理能力
2. 选择什么指标来表达服务器当前负载
3. 是不是所有请求所需的资源都是一样的 —— 显然不是
4. 选什么负载均衡算法，轮询 出了问题再说

![[Snipaste/Pasted image 20240311193325.png]]

1. 权重特别大，考虑平滑效果
2. 实际调用结果调整权重
3. 动态调整的，考虑上限和下限问题、权重会不会变成 0、最大值、最小值。
	1. 导致完全不被命中、或者一直命中

#### 微服务框架的局限性

![[Snipaste/Pasted image 20240311193620.png]]

![[Snipaste/Pasted image 20240311193701.png]]

### 面试要点

![[Snipaste/Pasted image 20240311193743.png]]
