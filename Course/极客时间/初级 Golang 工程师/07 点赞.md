1. 需求分析
2. 阅读数功能设计与实现
3. 点赞功能的设计与实现
4. 收藏功能的设计与实现
5. Kafka 入门
6. 用 Kafka 改造阅读计数实现
7. Kafka 面试中的重难点

## 需求分析

1. 基本功能——如何实现一个功能。
2. 是否通用

gorm expr 操作

![image-20240306144503735](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306144503735.png)

创建联合的唯一索引

![image-20240306144551121](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306144551121.png)

事实上，你只需要考虑情况一，因为 Redis 有一个  
HIncrBy 命令，它能够保证，如果 read_cnt 不存在，  
就先设置为 0，而后自增 1。

![image-20240306144756475](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306144756475.png)

![image-20240306144857564](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306144857564.png)

软删除

update status 替代直接插入删除，更新某个字段的

硬删除整个删除、整个插入的性能要比这里只是更新  
一个字段慢。

![image-20240306145931587](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306145931587.png)

- 插入点赞记录
- 增加文章 Like 的数量

查询接口实现

![image-20240306150520386](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306150520386.png)

不需要解决并发问题

![image-20240306150950883](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306150950883.png)

点赞功能实现小结

![image-20240306152238942](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306152238942.png)

引入 Redis 来提高计数类业务的性能

1. Redis 直接维护住总数
2. 排查业务，看能不能使用第二种优化业务的性能
3. SELECT COUNT 优化 SQL 命中索引

SQL 查询优化，我是真的很信任你的。

![image-20240306152708287](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306152708287.png)

基础概念

1. producer
2. consumer
3. broker 消息服务器
4. topic 和 partition
5. 消费者组与消费者

一个 topic 是一个业务

主分区与 broker，干好自己的事情。

![image-20240306153435163](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306153435163.png)

1. 轮询
2. 随机
3. 哈希

**如果要做到业务有序，就需要保证业务的消息都丢**  
**到同一个分区里面果要做到全局有序，就只能有一个分区。**

上面应该是保证有序的核心

![image-20240306160207994](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306160207994.png)

- 消费者组、消费者、分区之间的关系。

![image-20240306160338855](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306160338855.png)

- 由此衍生出消息积压问题，如何解决消息积压的问题

kafka 早期版本需要一个 zookeeper 现在不需要了捏

Raft 实现，分布式的理论需要补充一下。

客户端的选择：

![image-20240306160742676](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306160742676.png)

- 分布式的项目选择。封装成 shell 脚本。

sarama tools

![image-20240306161207023](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306161207023.png)

- 发送消息入门

![image-20240306161328093](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306161328093.png)

- sarama 分区选择
- 同一个业务的消息一定发送到同一个分区上，从而保证业务内消息有序

![image-20240306161434562](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306161434562.png)

- 异步发送例子

社区比较好的方案，得到一些面试的经验。相信自己是可以的。

1. 设置 Return.Success 和 Return.Error
2. 初始化 producer
3. 发送消息
4. 处理结果

指定 acks，三个值

![image-20240306190834436](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306190834436.png)

图解到 acks

![image-20240306190956663](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306190956663.png)

ISR in sync replicas 跟上节奏

![image-20240306191100683](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306191100683.png)

在实践中坚持一个原则，谁创建的 channel 谁关闭，可以避免很多问题

从 channel 里面读取数据，会读到零值 (关闭的 channel)

Sarama 启动消费者

![image-20240306191706310](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306191706310.png)

上面提到的 ConsumerGroupHandler

![image-20240306191819464](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306191819464.png)

使用 Context 控制消费者退出

![image-20240306191936002](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306191936002.png)

指定偏移量消费

![image-20240306192130316](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306192130316.png)




![image-20240306192328516](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306192328516.png)

## 用 Kafka 改造阅读计数功能

目前存在的缺点

![image-20240306193523807](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306193523807.png)

使用 kafka 解耦，标记用户读了谋篇文章，读文章实践

引入 DDD 中一个概念：领域事件

领域事件定义：

![image-20240306194102320](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306194102320.png)

有关 kafka 的八股文需要看一下。其实是一个异步的解耦的关系。

消费者消费消息

![image-20240306194431437](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306194431437.png)

批量处理消息提高性能

![image-20240306194604267](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306194604267.png)

1. 类似于阅读这种场景，**非常使用用批量处理接口加快消费者效率**
2. 消费者很难改变生产模型

批量处理

![image-20240306194813671](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306194813671.png)

开启批量消费

![image-20240306195018012](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306195018012.png)

![image-20240306195200572](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306195200572.png)

1. 使用一个事务，极大的提高了性能

![image-20240306195352669](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306195352669.png)

- 组装消费者，启动消费者
- 引入阅读记录功能，不需要改变任何原来的代码，只需要订阅响应的消息队列即可。

![image-20240306195534689](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306195534689.png)

## 升职加薪指南

- 统一的 MQ API 抽象
- https://github.com/ecodeclub/mq-api
- 生产者 API
- 消费者 API
- 消息本身的抽象

---

- 利用批量接口，提高生产者消费者性能

![image-20240306200814131](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306200814131.png)

生产者方面，可以有效的减轻 broker 的压力。

## Kafka 面试题

![image-20240306201020306](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306201020306.png)

消息积压

![image-20240306201244170](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306201244170.png)

消息有序

![image-20240306201315325](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240306201315325.png)

1. 全局有序：只使用一个分区
2. 业务有序：hash 算法指定生产者发送消息的分区
