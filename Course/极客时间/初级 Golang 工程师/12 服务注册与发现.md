- 服务注册于发现基本模型
	- IP 直连
	- 使用域名
	- 注册中心
	- 服务自省
	- 借助微服务网关的服务注册与发现
- 注册中心机制
	- 服务启动过程
	- 服务发现过程
- 在 gRPC 中使用注册中心
	- gRPC 中接入服务注册与发现
	- 不同微服务框架的接入方案
- 注册中心选型
	- CAP 基本理论
	- 注册中心与 CAP
- 服务注册与发现的高可用
	- 注册中心崩溃
	- 服务端与注册中心连不上
	- 客户端与注册中心连不上
	- 客户端与服务端连不上

![[Snipaste/Pasted image 20240308150410.png]]

注册中心机制

1. 服务端注册
2. 客户端第一次先查询**注册中心**，**然后缓存可用节点**
3. 负责中心在服务节点发生变动的时候 ，主动通知一下客户端

注册中心在大规模集群下容易成为瓶颈

![[Snipaste/Pasted image 20240308150737.png]]

1. **元数据的概念**  

![[Snipaste/Pasted image 20240308150901.png]]

1. 服务网关位置，通过域名得到
2. 知道真是服务器位置，服务注册与发现过程，借助注册中心或者 DNS

## 注册中心机制

![[Snipaste/Pasted image 20240308151134.png]]

1. 域名 + 端口 | IP + 端口连接注册中心

![[Snipaste/Pasted image 20240308151255.png]]

1. 定位信息，IP + 端口 关键
2. **其他信息**：比如分组功能，一般是用来搞服务治理的

![[Snipaste/Pasted image 20240308151536.png]]  

1. 服务器主动  
2. 注册中心主动  
3. 心跳失败、判定服务节点崩溃，通知客户端不要使用这个节点

心跳机制

![[Snipaste/Pasted image 20240308151813.png]]

1. **心跳时间间隔**
2. **如何判定连不上**，一次心跳还是多次心跳

![[Snipaste/Pasted image 20240308152404.png]]

1. 双向心跳、用的很少

![[Snipaste/Pasted image 20240308152435.png]]

**客户端缓存的可用节点列表**  
优雅的服务下线

![[Snipaste/Pasted image 20240308152538.png]]

1. **通知注册中心**
2. 服务节点**拒绝新请求**，读取一般请求，读完之后直接拒绝，不会交给后端业务代码
3. 等到**正在**处理的请求结束，定时任务等待结束
4. 处理已经接收的请求完毕，**服务端结束运行**
5. **超时控制退出**，业务时间过长，超过时间限制，直接退出

![[Snipaste/Pasted image 20240308152950.png]]

1. 服务发现时机
	1. **客户端启动的时候**
	2. **第一次调用某个服务的时候**，执行服务发现  
2. **注册中心和客户端也保持心跳**

## 面试要点

![[Snipaste/Pasted image 20240308153148.png]]

1. 服务注册与发现有哪些组件

## 在 gRPC 中使用注册中心 (接入服务注册与发现)

gRPC 的默认的服务发现方案

![[Snipaste/Pasted image 20240309090412.png]]

1. **域名服务器**
2. **在 k8s 推荐这种形态**

![[Snipaste/Pasted image 20240309090522.png]]

- dnsResolver 部分源码

![[Snipaste/Pasted image 20240309091819.png]]

1. Resolver 对服务的解析、包括定位信息在内的一些元数据

### Etcd 注册中心

![[Snipaste/Pasted image 20240309092033.png]]

1. 使用方法
	1. 创建一个 endpoint.Manager
	2. 添加一个 endpoint
	3. 注册数据变动，调用 **Update**
	4. 后续推出调用 **Delete** 方法，删除这个 endpoint

通过 Add 方法更新元数据

![[Snipaste/Pasted image 20240309092232.png]]

1. 实际上调用 Update 方法，传入一个 **Add** 操作

![[Snipaste/Pasted image 20240309092309.png]]

1. em.**DeleteEndpoint**
2. 调用 gRPC 优雅退出

存在问题：

![[Snipaste/Pasted image 20240309092357.png]]

1. **当即之后注册信息没有删除**

启用 **Lease** #不懂

![[Snipaste/Pasted image 20240309092422.png]]

1. 先创建**租约**
2. 开启**自动续约**，调用 **KeepAlive** 方法，建议打日志
3. 在操作 **Endpoint** 的时候，都要带上这个租约 **ID**
4. 退出的时候取消 **kaCtx** 以退出续约的 goroutine

etcd 续约机制  
![[Snipaste/Pasted image 20240309092756.png]]

1. 默认 **etcd ttl/3** 的时间续约一次
2. **客户端暴露重试机制**、**判定机制**
3. 大多数时候采用 etcd 的租约机制，实践中没有什么问题

客户端服务发现

![[Snipaste/Pasted image 20240309093000.png]]

1. SDK 处理好同步数据的事情
2. resolver: **etcd** /// 不要忘记
3. 实现接口 return "etcd"

改造 interactive 的服务启动过程

![[Snipaste/Pasted image 20240309093140.png]]

1. 确保端口打开之后才注册的

项目中踩过哪些坑 #不懂 需要特别准备。

服务注册

![[Snipaste/Pasted image 20240309093507.png]]

1. register 耦合了注册中心 etcd

获取自己地址的方法

![[Snipaste/Pasted image 20240309093602.png]]

![[Snipaste/Pasted image 20240309093729.png]]

1. client 做服务发现

![[Snipaste/Pasted image 20240309093832.png]]

1. 在 k8s 中推荐使用 **DNS** 的，因为很可能发生 ip 漂移

![[Snipaste/Pasted image 20240309093907.png]]

1. 当选用一个注册中心的时候，需要关心什么
	1. **有没有自动续约机制**，如果没有，就需要手动续约
	2. **续约的间隔**实践多长
	3. **续约失败**，SDK 有没有处理方式
	4. 注册中心和客户端是什么模型，客户端多久知道服务端发生变化

### 不同框架接入服务发现

#### Go-zero

![[Snipaste/Pasted image 20240309094303.png]]

![[Snipaste/Pasted image 20240309095057.png]]

#### Kratos

![[Snipaste/Pasted image 20240309095140.png]]  
![[Snipaste/Pasted image 20240309095153.png]]

### 微服务框架总结

![[Snipaste/Pasted image 20240309095221.png]]

在以 gRPC 为底层通信机制的微服务框架上，基本上服务注册于发现有一些共同点：

1. 必然实现了 gRPC 的 **Resolver** 接口
2. 必须又要给 **register** 的过程，也就是在服务端启动的时候注册数据
3. 必然会有一个**续约**的过程
4. **如果支持不同的服务注册与发现**，类似于 Registry 和 Discovery 之类的接口，一致性抽象

## 注册中心选型

CAP 理论

![[Snipaste/Pasted image 20240309100315.png]]

- C consistency 一致性
- A availability 可用性
- P partition tolerance 分区容错性：网络通信被破坏导致系统被分割成多个部分，依旧能够对外提供服务。

![[Snipaste/Pasted image 20240309100432.png]]

1. 大部分时候 P 不可少
2. etcd 是 AC 模型，网络故障导致节点不能通信，etcd 集群不可用

![[Snipaste/Pasted image 20240309100606.png]]

1. 标准答案是 AP
	1. 错误 > 没拿到 AP
	2. 正确数据 CP

接下来看看不同的注册中心使用的模型

### ZooKeeper

![[Snipaste/Pasted image 20240309100856.png]]

1. ZooKeeper
	1. 主从结构中间件
	2. 树形结构保存数据
2. 变更事件、主动拉取最新数据。规避变更事件必须有序的问题？ #不懂

![[Snipaste/Pasted image 20240309101307.png]]

1. 优点
	1. **API** 简单
	2. **成熟度高**
	3. **支持多语言客户端**
	4. Watcher + Push
2. 缺点
	1. 服务规模限制，无法支持超大规模集群：ZooKeeper 无法支撑太多的 TCP 连接
	2. 主从模式下，主节点就是写瓶颈
	3. 主从模式下，还会偶尔出现脑裂问题
	4. 主节点选举的时候，集群不可用
3. CP 模型

### Eureka

![[Snipaste/Pasted image 20240309102741.png]]

1. 对等、数据同步
2. 优点
	1. 可用性更高，更大规模集群
	2. 适合横向扩展，避免出现单节点写入瓶颈
3. 缺点
	1. 服务发现比较慢：扩散
	2. 多语言支持比较找：BUG 多

### Nacos

![[Snipaste/Pasted image 20240309102927.png]]

1. 同时支持 AP 和 CP 两种模式
2. 优点
	1. 高可用性，支持熔断降级等措施
	2. 中文社区
	3. 功能更加丰富：例如根据 namespace，Group 等来区分不同环境
3. 缺点
	1. 部署和运维的难度高一些
	2. CP 和 AP 继承在一起，源码复杂度高，难以理解
	3. 多哦语言支持比较差

### Etcd

![[Snipaste/Pasted image 20240309103345.png]]

1. etcd 配置中心和注册中心
2. 优点
	1. 简单易用：Go、部署简单，使用 HTTP 作为接口
	2. 高可用性：**Raft** 算法保证强一致性，是的服务注册和发现更可靠
3. 网络稳定性比较差，etcd 不合适了

### 注册中心总结

![[Snipaste/Pasted image 20240309103533.png]]

1. 大规模集群优先考虑 etcd
2. 选型
	1. **通用标准**：**成熟度高、社区支持完善**
	2. **扩展性**：业务增长、集群规模变大 ---> 注册中心是否能扩展
	3. **成本引述**：部署一个集群需要的节点数量
	4. **集群**：对等 or 主从 | 优先对等
	5. **CAP**：优先考虑 AP

## 服务注册于发现的高可用

![[Snipaste/Pasted image 20240309104507.png]]

![[Snipaste/Pasted image 20240309104618.png]]

1. **服务端崩溃**
	1. **fallover**

![[Snipaste/Pasted image 20240309104703.png]]

1. 注册中心高可用
	1. **启动注册中心的高可用方案**，例如部署一个集群
	2. **双注册中心方案**
	3. **按照业务拆分多个注册中心**，不同业务，不同注册中心，核心业务和非核心业务不同注册中心
2. 客户端怎么办
	1. 使用本地缓存的可用节点信息，不准
	2. 无法联通，移出节点列表
3. 如果一个新服务，没有本地缓存，发起调用，返回特定错误。

![[Snipaste/Pasted image 20240309105115.png]]

1. 注册中心崩溃，服务端怎么办
	1. 新节点，注册失败，直接退出服务
	2. **老节点**、**本地缓存**、**应该继续提供服务**

![[Snipaste/Pasted image 20240309105225.png]]

注册中心和服务端之间无法通信

1. 都不需要做什么
2. 一段时间无法保持心跳，要告警，要靠 v 了要不要直接退出

### 升职加薪指南

![[Snipaste/Pasted image 20240309105319.png]]

## 面试要点

![[Snipaste/Pasted image 20240309105334.png]]

## 作业

![[Snipaste/Pasted image 20240309105435.png]]
