
# 01 server端封装task任务的缓存
- 新建task/task.go做任务执行的操作
- 首先封装一个task任务缓存的对象和它的init方法
- 这个map代表机器ip对应的任务数组，因为一个机器可能被同时配置多个任务
```go
var TaskCaches *TaskCache

type TaskCache struct {
	sync.RWMutex
	M map[string][]*models.TaskMeta // 这个map代表机器ip对应的任务数组，因为一个机器可能被同时配置多个任务
}

func TaskCacheInit() {
	TaskCaches = &TaskCache{
		M: make(map[string][]*models.TaskMeta),
	}
}
```
- 定义一个同步db中的任务方法，周期执行doSyncTask
```go
// 定义一个同步db中的任务方法，周期执行doSyncTask
func SyncTaskManager(ctx context.Context, logger log.Logger) error {

	level.Info(logger).Log("msg", "SyncTaskManager.start")
	ticker := time.NewTicker(15 * time.Second)
	defer ticker.Stop()
	for {
		select {
		case <-ctx.Done():
			level.Info(logger).Log("msg", "SyncTaskManager.exit.receive_quit_signal")
			return nil
		case <-ticker.C:

			TaskCaches.doSyncTask()
		}
	}
}
```
- 完成这个dosync同步方法
- doSyncTask从db中查询出所有为完成的任务，对应就是done=0的task
- 然后遍历 task ， 按照机器ip塞入map中
```go
// doSyncTask从db中查询出所有为完成的任务，对应就是done=0的task
// 然后遍历 task ， 按照机器ip塞入map中
func (tc *TaskCache) doSyncTask() {
	// 获取为完成的任务
	tasks, err := models.TaskMetaGetUnDo()
	if err != nil {
		logger.Errorf("[doSyncTask][error: %+v]", err)
		return
	}
	m := make(map[string][]*models.TaskMeta)
	for _, t := range tasks {

		err := json.Unmarshal([]byte(t.HostsRaw), &t.Hosts)
		if err != nil {
			logger.Errorf("[json.Unmarshal_host][t:%+v][error: %+v]", t, err)
			continue
		}
		logger.Debugf("[get_task_from_mysql][t:%+v]", t)
		if len(t.Hosts) == 0 {
			continue
		}

		for _, host := range t.Hosts {
			// 按照机器ip分发
			tasks, loaded := m[host]
			if !loaded {

				tasks = make([]*models.TaskMeta, 0)
			}
			t.Action = "start"

			tasks = append(tasks, t)

			m[host] = tasks
		}
	}

	tc.Lock()
	defer tc.Unlock()
	tc.M = m
	logger.Debugf("[tc.M:%+v]", tc.M)
}
```


- 在server中的go编排开启这个任务，在编排开启之前
```go
	// 初始化task的本地cache map
	task.TaskCacheInit()
```
- 并添加一个编排任务
```go
	{
		// 任务执行同步任务

		g.Add(func() error {
			err := task.SyncTaskManager(ctxAll, logger)
			if err != nil {
				level.Error(logger).Log("msg", "task.SyncTaskManager.error", "err", err)

			}
			return err

		}, func(err error) {
			cancelAll()
		},
		)
	}

```
- 最后给这个cache绑定一个方法，根据机器的ip地址获取分配给他的任务列表
```go
func (tc *TaskCache) GetTasksByIp(ip string) []*models.TaskMeta {
	tc.Lock()
	defer tc.Unlock()
	res, loaded := tc.M[ip]
	if !loaded {
		res = make([]*models.TaskMeta, 0)
	}
	return res
}

```


# 02 将task操作暴露给web
- 新增web的路由处理文件 D:\go_path\src\open-devops\src\modules\server\web\route_task.go

```go
package web

import (
	"github.com/gin-gonic/gin"
	"open-devops/src/common"
	"open-devops/src/models"
)

func TaskAdd(c *gin.Context) {

	var input models.TaskMeta
	if err := c.BindJSON(&input); err != nil {
		common.JSONR(c, 400, err)
		return
	}
	id, err := input.AddOne()
	if err != nil {
		common.JSONR(c, 500, err)
		return
	}
	common.JSONR(c, 200, id)
}

func TaskGets(c *gin.Context) {

	ljs, err := models.TaskMetaGets("id>0")
	if err != nil {
		common.JSONR(c, 500, err)
		return
	}

	common.JSONR(c, 200, ljs)
}

```
- 在route 添加这两个路由
```go
// D:\go_path\src\open-devops\src\modules\server\web\route.go
		api.POST("/task", TaskAdd)
		api.GET("/task", TaskGets)
```
- 然后本地启动server，写python脚本测试task的添加和获取
- 添加task的python代码
```python
def task_add():
    """

CREATE TABLE `task_meta`
(
    `id`        bigint unsigned NOT NULL AUTO_INCREMENT,
    `title`     varchar(255)    not null default '' COMMENT '标题',
    `account`   varchar(64)     not null COMMENT '脚本执行账号',
    `timeout`   int unsigned    not null default 0  COMMENT '执行超时',
    `hosts_raw` varchar(4096)   not null  COMMENT '执行机器的ip列表json',
    `script`    text            not null COMMENT '执行的脚本',
    `args`      varchar(512)    not null default '' COMMENT '执行的脚本的参数',
    `creator`   varchar(64)     not null default '' COMMENT '创建者',
    `created`   timestamp       not null COMMENT '创建时间',
    `done`      int unsigned    not null COMMENT '任务结束与否的标志位=0未结束，=1结束',
    PRIMARY KEY (`id`),
    KEY (`created`)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8;
    """

    data = {
        "script": '''#!/bin/bash\nss -ntlp''',
        "account": "root",
        "title": "test01",
        "timeout": 5,
        "hosts": json.dumps(["192.168.3.200","192.168.3.201"]),
        "creator": "xiaoyi",
        # "created": 123,
        # "done": "0",
        # "tag_json": json.dumps(tag),

    }
    print(data)
    # uri = 'http://192.168.3.200:8082/api/v1/task'
    uri = 'http://localhost:8082/api/v1/task'
    res = requests.post(uri, json=data, headers=JSON_H)
    print(curlify.to_curl(res.request))
    print(res.status_code)
    print(res.text)


```
- 正常添加后去查询mysql，可以看到添加的测试task
```shell script
mysql> select * from task_meta\G
*************************** 1. row ***************************
       id: 1
    title: test01
  account: root
  timeout: 5
hosts_raw: ["192.168.3.200", "192.168.3.201"]
   script: #!/bin/bash
ss -ntlp
     args: 
  creator: xiaoyi
  created: 2021-11-25 17:31:17
     done: 0
1 row in set (0.00 sec)

mysql> 


```
- 然后是测试查询task的python
```python
def task_query():

    uri = 'http://localhost:8082/api/v1/task'
    res = requests.get(uri, headers=JSON_H)
    print(curlify.to_curl(res.request))
    print(res.status_code)
    print(res.text)
```
# 截止到这里task的添加已经和web打通
# 并且本地的map也能获取到任务了


# 03 rpc下发任务和任务结果收集的逻辑
## 定义rpc 任务下发和上报的结构体
- 在server rpc 中新建task.go,D:\go_path\src\open-devops\src\modules\server\rpc\task.go
- 定义 agent的上报请求
```go
package rpc

import (
	"github.com/toolkits/pkg/logger"
	"open-devops/src/models"
	"open-devops/src/modules/server/task"
)


// agent上报的单个任务结果
type ReportTask struct {
	Id     int64
	Clock  int64
	Status string
	Stdout string
	Stderr string
}
// agent的上报请求
type TaskReportRequest struct {
	AgentIp       string     // agent的ip用来获取新的任务
	ReportTasks []ReportTask // 上次任务的结果
}


```
- 定义下发给agent的任务
```go

// 下发给agent的任务
type TaskReportResponse struct {
	Message     string
	AssignTasks []*models.TaskMeta
}

```


## 完成rpc的逻辑
- 编写一个rpc 方法
- 首先要处理agent上报的任务结果，就是将ReportTasks翻译成models.TaskResult记录到库中
- 将job标记为已处理 ,这样下次就不会再分配这个任务了
```go
func (t *Server) TaskReport(args TaskReportRequest, reply *TaskReportResponse) error {
	toMarkDoneIds := make(map[int64]struct{})
	if len(args.ReportTasks) > 0 {
		//	处理返回
		// 将task返回结果入库
		//
		// 首先要处理agent上报的任务结果，就是将ReportTasks翻译成models.TaskResult记录到库中

		for _, x := range args.ReportTasks {
			tRes := models.TaskResult{
				Id:     0,
				TaskId: x.Id,
				Host:   args.AgentIp,
				Status: x.Status,
				Stdout: x.Stdout,
				Stderr: x.Stderr,
			}
			err, added := tRes.Save()
			if err != nil {
				logger.Errorf("[TaskResult.SaveError][agent.ip:%+v][tRes:%+v][error:%+v]",
					args.AgentIp,
					tRes,
					err,
				)
			}
			if added {
				logger.Infof("[TaskResult.Save.Success][agent.ip:%+v][tRes:%+v]",
					args.AgentIp,
					tRes,
				)
				toMarkDoneIds[x.Id] = struct{}{}
			}

		}
		// 将job标记为已处理 ,这样下次就不会再分配这个任务了
		for id, _ := range toMarkDoneIds {
			err := models.MarkTaskMetaDone(id)
			if err != nil {
				logger.Errorf("[TaskMeta.MarkTaskMetaDone][agent.ip:%+v][id:%+v][error:%+v]",
					args.AgentIp,
					id,
					err,
				)
			} else {
				logger.Infof("[TaskMeta.MarkTaskMetaDone][agent.ip:%+v][id:%+v]",
					args.AgentIp,
					id,
				)
			}
		}

	}
	reply.AssignTasks = task.TaskCaches.GetTasksByIp(args.AgentIp)

	return nil
}

```