1. 加密算法 BCrypt
2. 跨域问题
	1. 发送方协议 + 域名 + 端口 != 接收方的
	2. preflight 里面高数浏览器接收哪些
	3. Gin 提供跨域的 Middleware
	4. **跨域问题设置哪些头部**
3. Gin Middleware
	1. 什么是
	2. 原理是什么
	3. 一个具体的方案 —— 限流方案
	4. ginx
		1. web 治理
		2. 可观测性
		3. 身份认证和鉴权
4. 性能优化考虑参数是分配在堆上还是栈上
5. User 表的设计外键索引。
6. 加密算法
	1. PBKDF2 额外存储 salt
	2. BCrypt 号称是最安全的
7. select for update 的并发问题
8. Cookie 关键配置
	1. Domain
	2. Path
	3. Max-age Expire 只保留必要时间
	4. Http-Only —— true 浏览器上的 JS 没有办法使用 cookie，永远设置为 true
	5. Secure
	6. SameSite 是否允许跨站发送 Cookie
9. JWT token 位置
10. 设计模式，builder 模式，很好的设计

---

[[../02-2 用户基本功能和 GORM 入门|02-2 用户基本功能和 GORM 入门]]

1. AOP 方案，所有业务都关心的东西
2. CORS
	1. AllowCrendentials
	2. AllowHeader
	3. ExposeHeader
	4. AllowOrignFunc 哪些来源是被允许的
3. BCrypt
	1. 不需要自己生成盐值
	2. 不需要额外存储盐值
	3. 可以通过 cost 控制加密性能
	4. 同样的文本，加密后的结果是不一样的
4. 什么是 Cookie 和 Session
	1. 定义
		1. 绘画管理、个性化配置、跟踪
		2. 通常通过 cookie 传递
			1. 查询参数
			2. header
			3. cookie
	2. 相同
	3. 区别
		1. 存储位置
		2. 安全性
		3. 生命周期
		4. 资源开销
5. **map**
	1. [[../../../../Coding/Go/深入理解go/Go Map 原理|Go Map 原理]]
6. **channel**[[../../../../Coding/Go/深入理解go/Go Channel|Go Channel]]

---

[[../03 Session 和 JWT|03 Session 和 JWT]]

1. cookie 的实现
2. 刷新 Session 的过期时间
	1. 每次访问刷新
	2. 最后访问刷新
	3. 固定时间刷新
	4. 长短 token
3. JWT
	1. Header JWT 元数据、描述 token 本身的数据 JSON 对象
	2. Payload 数据内容 JSON 对象
	3. Signature 根据 head + token 签名
4. JWT 跨域设置
5. JWT 优点
	1. 无状态和可扩展性：服务端不需要保存用户的认证信息和会话状态，已于扩展。
	2. 安全性 支持对称加密 HMAC 和非对称加密 RSA
	3. 自包含
6. 注意
	1. HTTPS 可能拦截
	2. 如果被盗用，过期之前都可以
	3. Payload Base64 编码 敏感信息 X
7. **雪花 ID 分布式 ID 生成器是干什么的**
8. **singleflight**
9. 限流降级 + 特色部分  

---

1. **单机限流和集群限流** (Redis)
2. 滑动窗口算法，需要分布式锁
3. 识别攻击者和正常用户——二次验证
	1. 浏览器指纹
	2. IP 归属地问题
	3. 尽可能采集前端信息
4. 检查前端接口，而后加入限流功能
	1. 可以考虑整个集群限流
	2. 针对核心业务的接口限流
	3. 针对不登录就可以访问的接口限流
5. 为 Gin 添加限流插件
	1. 单机限流
		1. 令牌桶算法
		2. 漏桶算法
		3. 滑动窗口算法
		4. 固定窗口算法
	2. 基于 Redis 的限流
	3. 基于 Redis 的 IP 限流
6. 面试要点
	1. Session 过期时间的设置
		1. 设置 10 分钟过期
		2. 每次访问都刷新，性能差
		3. 快要过期再刷新 —— 恰好边界 不好处理
		4. 固定时间间隔，每分钟第一次访问刷新
		5. 长短 token
	2. 增强登录安全性
		1. 怎样保护 SessionID HTTPS cookie secure httponly true
		2. session id or jwt token 泄露的时候怎么办，校验附加信息 User-Agent
	3. 怎样保护 web 服务
		1. IP 限流
		2. 集群限流
7. 代码生成技术
	1. 反射
	2. 模板编程
	3. AST 抽象语法树编程
8. builder 保持链式调用
9. 奇诡的方式

**单机限流和集群限流**是两种常见的限流策略，主要用于控制访问流量，防止系统过载，保障系统的稳定性和可用性。它们在应对高并发场景时发挥着关键作用。下面分别解释这两种限流策略：

**单机限流**指的是在单一服务器上实施的流量控制策略。它旨在限制单个服务器在单位时间内能够接受的请求数量或操作数量，防止因为突发的高流量而导致服务器资源被耗尽（如 CPU、内存溢出等），从而避免服务崩溃或响应时间过长。单机限流通常适用于单体应用或服务的流量控制。

**单机限流**的实现方法有多种，包括令牌桶（Token Bucket）、漏桶（Leaky Bucket）和计数器等算法。

**集群限流**是在微服务或分布式系统中实现的流量控制策略，旨在整个系统或服务集群范围内限制流量。由于分布式系统通常由多个服务实例组成，部署在不同的服务器或容器中，集群限流能够确保整个系统在面对大规模流量时的稳定性和可用性，防止某一部分因流量过大而成为瓶颈。

**集群限流**需要在整个集群的上下文中考虑流量分配和控制，这可能涉及跨多个服务器或服务实例的协调和同步。集群限流的实现可能需要依赖中间件、服务网格（如 Istio）、API 网关等组件，来实现跨服务的流量控制和监控。

总结

单机限流和集群限流都是为了防止系统过载，保持服务的高可用性，但适用的场景不同。单机限流适用于单个服务或应用的流量控制，而集群限流适用于分布式系统或服务集群的整体流量控制。在实际应用中，根据系统的架构和需求选择合适的限流策略至关重要。

写代码的原则

1. 开闭原则
2. 面向接口编程
3. 装饰器模式
4. 坚持依赖注入
5. DDD
6. TDD —— 先写测试，再写业务代码。从用户的角度去考虑接口应该怎么设计。  

---

[[../04 接口抽象技巧和短信验证码登录(未完成)|04 接口抽象技巧和短信验证码登录(未完成)]]

1. Redis 失效的时候使用本地缓存
2. unify cache
3. 缓存穿透、缓存击穿、缓存雪崩、**缓存穿刺**
4. 缓存里面有数据、缓存里面没有数据、缓存出错了
5. 缓存崩了怎么解决
	1. 数据库限流
	2. 限流问题
	3. 二级缓存
	4. lianggeRedis 集群
	5. 本地缓存 + Redis
	6. 高大上的集群 + 廉价的集群
6. Redis 崩了，这种写法会直接导致服务不可用，但是保护住了数据库
7. 和 Redis 保持心跳
	1. 备用缓存
	2. 本地缓存
	3. KeyNotExist
	4. 问一下布隆过滤器
8. wrk 接口测试——从 0-1 的高成就感的事情
	1. 性能瓶颈
		1. 数据库查询
		2. 别人的服务
	2. 性能分析报告
	3. 更多性能优化技巧
	4. 输出性能优化方案
	5. 写好很多的 Lua 脚本
	6. 数据库拆线呢
	7. 注册接口
	8. 查询接口是主流
	9. 测试，模拟登录 拿到 token
9. Redis 面试题
	1. 你用 Redis 解决过什么问题
		1. 缓存数据
		2. 限流的实现
		3. 分布式锁
	2. 支持哪些数据结构
		1. list 消息队列
		2. string 缓存数据
		3. hash 缓存对象
		4. set
		5. zset 限流，还需要复习一下限流的内容
10. 多种登录方式
	1. 短信登录
	2. 微信登录
11. ORM Middleware 数据库的限流。
12. 验证码服务
	1. send 安全保障
	2. verify
		1. 防止爆破
		2. biz
		3. 前端是防不住的
	3. 一定要有过期时间
13. check in do something 分布式环境下的并发，非常常见
	1. Redis 层面上解决 Redis 单线程特性 lua
	2. 分布式锁 难用 性能差
14. lua
	1. 检查验证码
	2. 存储验证码
15. send
	1. 流程
		1. 生成验证码
		2. 塞进去
		3. 发送验证码
		4. tplID 可以做成可配置的
		5. 安全控制 验证 3 次以上不行了哦
	2. lua 脚本的编写
	3. go 代码的编写
16. 短信业务逻辑实现
	1. hget 和 hset
	2. 唯一索引可以有多个控制，但是不能有多个空字符串
	3. 快路径 + 满路经
17. 如何实现验证码功能
	1. 验证码流程基本步骤
	2. 安全问题
	3. 并发问题 lua
18. 衍生问题
19. 依赖注入
	1. install wire
	2. go build: wireinject
	3. wire 帮助组装 不关注顺序
	4. wire 不支持单例模式
	5. 依赖注入 DI 是控制反转的一种形式
20. 什么是依赖注入？Go 中的依赖注入？
21. 什么是面向接口编程？为什么？
22. 什么是 IOC
23. 第三方服务治理
	1. 为短信服务添加限流
	2. 自动切换短信运营商
24. 炫技式的设计
25. 不要相信昨天的自己，因为今天的自己更强。
26. 装饰器模式
27. 开闭原则：对修改闭合、对扩展开放
28. 非侵入式的设计、反复重构代码
29. 判定一个服务是否有问题 (第三方短信服务)
	1. 心跳、网络
	2. EOF 大概率式连接除了问题
	3. 不要每次都从 9 开始，进行更加精细的控制
30. 设计一个协程池需要考虑哪些内容
31. 锁可能执行了几百条的机器指令，原子操作是非常轻量级的并发工具。
32. 动态判定服务商状态
33. 下游服务可以给你 CPU 使用率等等，动态判定下游状态。公司内部的接口。
34. 设计并实现一个高可用的短信平台
	1. 提高可用性：重试机制、客户端限流、failover（轮询、实时检测）
		1. 实时检测
			1. 基于超时的实时检测：连续超时
			2. 基于响应时间的实时检测、比如平均响应时间上升 20%
			3. 基于长尾请求的实时检测，。。。响应时间超过 1s 的请求占比超过 10%
			4. 错误率
	2. 提高安全性
		1. 完整的资源申请和审批流程
		2. 鉴权
			1. 静态 token
			2. 动态 token
	3. 提高可观测性：日志、metrics、tracing、丰富完善的排查手段
35. 上面每个方案准备 300 ~ 500 字的内容
36. 设计一套同步转异步的条件，决策理由，多个超时错误
37. 审批流程
38. 鉴权  
![image-20240224095459374](file://C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20240224095459374.png?lastModify=1710336810)
39. 控制重试的次数
40. MQ 是更合适的选择
41. 微信登录
42. appid redirect_uri
43. 只支持 https 协议
