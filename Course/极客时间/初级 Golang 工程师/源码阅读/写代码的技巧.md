#编码技巧

## 定时任务

```go
package time

import (
	cron "github.com/robfig/cron/v3"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

func TestCronExpr(t *testing.T) {
	expr := cron.New(cron.WithSeconds())
	// 这个任务的标识符
	// @every 是便利语法
	id, err := expr.AddJob("@every 2s", JobFunc(func() {
		t.Log("hello, world")
	}))
	require.NoError(t, err)
	t.Log(id)
	// 调度运行
	expr.Start()
	// 假装我们运行一段时间
	time.Sleep(time.Second * 10)
	// 停止任务
	ctx := expr.Stop()
	// 等待正在运行中的任务运行结束
	<-ctx.Done()
}

type JobFunc func()

func (jf JobFunc) Run() {
	jf()
}
```

## context.WithTimeout + Ticker

```go
func TestTimer(t *testing.T) {
	ctx, cancel := context.WithTimeout(
		context.Background(),
		time.Second*10)
	defer cancel()
	timer := time.NewTimer(time.Second)
	defer timer.Stop()
	for {
		select {
		case now := <-timer.C:
			t.Log(now.String())
		case <-ctx.Done():
			// 退出
			return
		}
	}
}
```

## 原子操作

```go
func Atomic() {
	var val int32 = 12
	// 原子读，你不会读到修改了一半的数据
	val = atomic.LoadInt32(&val)
	println(val)
	// 原子写，即便别的 Goroutine 在别的 CPU 核上，也能立刻看到
	atomic.StoreInt32(&val, 13)
	// 原子自增，返回的是自增后的结果
	newVal := atomic.AddInt32(&val, 1)
	println(newVal)
	// CAS 操作
	// 如果 val 的值是13，就修改为 15
	swapped := atomic.CompareAndSwapInt32(&val, 13, 15)
	println(swapped)
}
```

## Kafka 的操作暂时忽略

## k8s 定时任务的写法

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: demojob
spec:
#  难点就是要学会写正确的表达式
#  我从网上抄的，五分钟一次，这里的表达式是咩有秒的部分的
  schedule: "*/5 * * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
            - name: helloworld
              image: flycash/cron_job:v0.0.1
              imagePullPolicy: IfNotPresent
          restartPolicy: OnFailure
```

## Viper
