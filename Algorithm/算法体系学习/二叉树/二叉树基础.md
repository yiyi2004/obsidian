- Time：2023-06-27 08:14
- Label： #algorithm #go #二叉树

## Abstract

- 现在从二叉树开始，前面的内容要进行复习
- 二叉树的定义 + 二叉树的遍历 (递归方式)
- 最终能否通过算法面试不是由你刷过多少题目决定的，而是你对算法的理解的深度决定的
	- 功夫到了，我是不相信会出意外的

## Content

### 递归序

递归函数实现，**递归序**——二叉树的递归套路中非常重要

任何事情都开始于简单的事情，递归函数是非常强的，保证所有的函数都会**回到自己 3 次**。

you should know who you are, and be yourself.

第一次到自己就打印，这就是先序遍历，中序、后序同理。都是由递归序加工来的。

递归序非常强

![[Snipaste/Pasted image 20230627082446.png]]

这些两个集合的交集是且仅是 A 的祖先节点——证明这件事其实不难

1. 证明祖先节点在集合里面
2. 分两种情况讨论其他节点不在集合里面

- [ ] 那么交集的算法怎么写，可以复用嘛

### 非递归实现二叉树遍历

#### 先序遍历

![[Snipaste/Pasted image 20230627084538.png]]

1. 栈顶出来记为 current
2. 有右压入右，有左压入左 (先右再左)

#### 后续遍历

先序遍历 头左右 ---> 头右左 ---> 左右头 (后序遍历)

1. 出栈的时候不打印，将节点放入新的栈中。
2. 等所有的节点都入栈之后，再弹出新栈的所有节点

对象的复用，节省内存.算法之间是有联系的.

**如何使用一个栈实现后续遍历**——极客的写法

![[Snipaste/Pasted image 20230627090257.png]]

#### 中序遍历

中序改成非递归，如何成为一个极客，也就是最优的时间和空间复杂度，代码写的要优雅。

![[Snipaste/Pasted image 20230627091028.png]]

不能指望在工程中使用递归，因为递归栈是相对比较小的，很有可能回造成栈溢出。因此需要借用内存，内存是比较大的，所以不要使用系统栈作为递归的实现方案。

上线代码是不行的，递归 ---> 非递归是重要的工程能力。**限制层数的递归**

![[Snipaste/Pasted image 20230627091537.png]]

1. 两个循环退出条件 ---> stack empty or cur null
2. if cur != nil else …

解释：二叉树是可以由左边界划分

![[Snipaste/Pasted image 20230627092035.png]]

牛的，我已经比较理解了。左边界压入栈，所以出来的时候是逆序的。

都是先弄左边，然后弄自己，最后弄右树，是真的牛。

### 链表删除某个节点

1. 设计返回值的时候应该是 Node 类型，但是我认为在 Go 里面应该设计为 error 类型

不给头节点，删除链表中的元素，给出要删除节点的地址 (指针)，**但是有个问题就是如果找不到的节点，Java 的 GC 会把内存释放掉，所以根本就没有意义了**

1. nil 指向的是内存的某个独立的区域
2. 不能删除一个最后一个节点
	1. 其实是可以的 prepre and pre
3. 但是如果在工程的服务器上
	1. 数据迁移比较麻烦 ---> 不一定提供数据的拷贝
	2. 流量迁移费劲，因为找不到上一个节点
	3. 依赖没有迁移

**在面试中讲出一些存在问题也是非常重要的**

### 二叉树按层遍历

![[Snipaste/Pasted image 20230627094112.png]]

1. 使用队列实现

![[Snipaste/Pasted image 20230627094312.png]]

可以通过设置 flag 的方式发现某一层结束了 ---> 第五题会进行介绍

### 二叉树的序列化与反序列化

1. 链表 ---> 数组

没有不挂的服务，树 ---> 文件，字符串，唯一的结构 ---> 序列化。能够唯一表示树的结构

常规的方式 ---> 二叉树的重构 (先序 + 中序 || 其他的东西) ---> 赋予这些内容含义 (找到在实际中的应用是非常重要的)

1. 按照先序遍历序列化
2. 按照层序遍历序列化

#### 先序遍历序列化与反序列化

##### 序列化

![[Snipaste/Pasted image 20230627095550.png]]

再写面向对象程序的时候，你要分清，哪些应该是自己的，哪些应该是传进来的。

##### 反序列化

![[Snipaste/Pasted image 20230627100121.png]]

后序遍历序列化有的，中序没有，因为有歧义。

![[Snipaste/Pasted image 20230627100222.png]]

#### 层序遍历序列化

边界条件，比如头节点是否为空，如果空，那就直接结束捏。—— 可以套用在每一层递归上。

##### 序列化

1. 两个队列，一个队列存储结果，另一个队列存储节点，用来进行按层排序遍历
2. 如果节点为空间点，那么加入结果。如果节点不为空，加入结果，并且加入节点队列。
3. 条件是 !queue.isEmpty()

##### 反序列化

1. 先拿出头节点

![[Snipaste/Pasted image 20230630161041.png]]  

- 对数器的重要性，写对数期。随机生成数组，随机生成链表，随机生成二叉树、暴力解题方法。

##### Leetcode

这道题去年考了

![[Snipaste/Pasted image 20230630161114.png]]

- 多叉树序列化为二叉树的方法，其实比较简单，**左侧右边界**

![[Snipaste/Pasted image 20230630164514.png]]

1. 深度优先遍历

##### 打印二叉树的样子

这是一个工具函数，用来打印二叉树的样子 (图像)，不常考，但是如果一个二叉树输入进去发生死循环，那么你的二叉树连接可能有问题

##### 二叉树最宽的层

1. 按层遍历
2. 标志某一层结束

![[Snipaste/Pasted image 20230702164827.png]]

几个重要变量：

1. 当前层的节点个数
2. 当前层 end | curend
3. 下一层 end
4. max

![[Snipaste/Pasted image 20230702165025.png]]

- TreeMaxWidth

在层序遍历的基础上进行的修改

比较 low 的实现方式：

1. 记录每个节点的层数
2. 弹出的时候统计，并找出最大

##### 返回某个节点的后继节点

在一个遍历顺序中，某一个节点之后打印的节点就是后继节点。所以会有三种类型的搜索二叉树。

1. 经典方法：中序遍历 + 找到 O(N)

![[Snipaste/Pasted image 20230703095955.png]]

有父节点指针之后可不可以将时间复杂度 O(N) --->O(K) 节点与后继节点之间的真实距离

> 1. 关键在于分类讨论
> 2. 你想象节点位置的时候考虑的并不全面 —— 左孩子，右孩子，不如下一个时间段，把所有的情况都列举一遍。
> 3. 写一个随机二叉树的生成程序

##### 二叉树折纸问题

> 具象化的操作之后就理解了，01 + 中序遍历

![[Snipaste/Pasted image 20230703104444.png]]  
![[Snipaste/Pasted image 20230703104526.png]]  
![[Snipaste/Pasted image 20230703104627.png]]  
![[Snipaste/Pasted image 20230703104926.png]]

> 1. 层数作为退出条件

44~45 可以虐面试官 ---> 大厂刷题班

#### 二叉树递归套路 | 树形 DP

##### 判断是完全二叉树

1. 如果一个节点只有右孩子，那么一定不是完全二叉树
2. 当第一次遇到左右节点不双全的情况，那么接下来的所有节点都是叶子节点

如果顺利遍历完成，那么是完全二叉树。

有两种方法，方法一和方法二，CBT，方法二是非自然方法。

##### 判断是否是平衡二叉树

> 平衡二叉树是一种特殊的二叉搜索树，它的定义包括以下两个要素：
> 
> 1. 二叉搜索树（Binary Search Tree）：平衡二叉树是一种满足二叉搜索树性质的二叉树。对于平衡二叉树中的每个节点，其左子树中的所有节点都小于它，右子树中的所有节点都大于它。这保证了平衡二叉树具有有序性质，可以高效地支持查找、插入和删除操作。
> 2. 平衡性（Balance）：平衡二叉树在结构上具有平衡性，即树中任意节点的左右子树的高度差不超过一个固定的值（通常为 1）。这种平衡性的要求确保了树的高度相对较小，使得查找、插入和删除操作的时间复杂度保持在较低的水平。
> 
> 平衡二叉树的平衡性质使得它在处理动态数据集合时具有较好的性能。它可以避免二叉搜索树退化为链表，从而保持了较快的操作时间。常见的平衡二叉树有红黑树、AVL 树、Treap 等。这些树结构在插入和删除节点时会自动调整树的结构，以保持平衡性质。

平衡二叉树满足三个条件

1. 左树是平衡的
2. 右树是平衡的
3. | height(左树) - height(右树) | < 2

![[Snipaste/Pasted image 20230703132455.png]]

> 这里左右是平等结构的，到时候会讲关于平等结构的

![[Snipaste/Pasted image 20230703133914.png]]

其实现在的重点变成分析递归任务的过程

任何树形 BP 的题目都是这种感觉

拓扑排序不唯一，但是每一个都对，岔开的话题捏

##### 判断是搜索二叉树 | 不是线索二叉树喔

经典的搜索二叉树中是没有相等的元素的，重复值的需求 ---> 用链表解决 (类似用链表解决 hash 冲突问题)

1. 中序遍历，如果是升序排序，那么就是搜索二叉树
2. 递归套路

递归套路，赵可能性

1. 列出是搜索二叉树的可能性，向左树、右树要信息
	1. x 的左树是搜索二叉树
	2. x 的右树是搜索二叉树
	3. x 的左树的最大节点 < x
	4. x 的右树的最小节点 > x

![[Snipaste/Pasted image 20230703135212.png]]

当左右要求不一致的时候，**取全集**。

递归是对每个节点相同的处理流程，一视同仁，所以不要去写特定的数据结构，没有必要。

对于空树的指标，如果不好处理就返回 null，在上游进行处理。

因为不知道空是怎么设置的 (base case return null) 所以要小心判 null

##### 二叉树的最大距离

![[Snipaste/Pasted image 20230705184246.png]]  
![[Snipaste/Pasted image 20230705184909.png]]  
![[Snipaste/Pasted image 20230705185154.png]]  
![[Snipaste/Pasted image 20230705185937.png]]

1. 其实关键在什么地方呢？在于分类讨论的完备性，如果考虑的情况是完备的，那么程序自然是正确的。

##### 判断一颗二叉树是否是满二叉树

![[Snipaste/Pasted image 20230705190504.png]]

1. 满二叉树的性质，高度为 h，那么它的节点个数 == $2^{h}- 1$
2. 两个因素，节点个数和高度

##### 找到最大的子树是搜索二叉树

最大的子树有几个点，然后返回。

## Reference
