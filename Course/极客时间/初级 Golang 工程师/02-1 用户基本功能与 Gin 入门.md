- Gin 入门
- webook WEB 结构
- 跨域问题
- GORM 入门
- 设计项目结构
- 定义用户模型
- 密码加密
- 登录功能
- 深入讨论 Session
- JWT
- 保护登录系统

## Gin 入门

Gin 的学习要点：

- 如何定义路由：包括参数路由、通配符路由
- 如何处理输入输出
- 如何使用 middlew

are 解决 AOP 问题

## Webook WEB 结构

- 集中注册和分散注册  
![[Snipaste/Pasted image 20240112100459.png]]

- 分组路由简化注册

![[Snipaste/Pasted image 20240112100620.png]]

- 目录结构

internal: 放着我们所有的业务代码  
pkg: 沉淀出来可以给其他项目使用的东西

- 预编译正则表达式

![[Snipaste/Pasted image 20240112102649.png]]

- github.com/dlclark/regexp2

整体校验，要区分不同的错误：

![[Snipaste/Pasted image 20240112102735.png]]

## 跨域问题

- **preflight 请求**

gin 跨域问题解决方案：

- https://github.com/gin-gonic/contrib

![[Snipaste/Pasted image 20240112103032.png]]

middleware 的其他名字：

1. plugin
2. handler
3. filter
4. interceptor

所有业务都关心的东西，AOP 方案

CORS Middleware

- AllowCrendentials：是否允许带上用户认证信息（比如 cookie）。
- AllowHeader：业务请求中可以带上的头。
- ExposeHeader: 可以在 response 中设置的 Header 头，比如 x-jwt-token 这些自定义的字段。
- AllowOriginFunc：哪些来源是允许的。

![[Snipaste/Pasted image 20240112103407.png]]

这个 middleware 设置了 Access-Control 家族的几个 Header，这是解决跨越问题的关键。preflight 请求如下。

![[Snipaste/Pasted image 20240112103858.png]]

跨域问题要点：

跨域问题是因为发**请求的协议 + 域名 + 端口**和**接收请求的协议 + 域名 + 端口**对不上。比如说这里的 localhost:3000 发到 localhost:8080 上。

- 解决跨域问题的关键是在 preflight 请求里面告诉浏览器自己愿意接收请求。
- Gin 提供了解决跨域问题的 middleware，可以直接使用。
- middleware 是一种机制，可以用来解决一些所有业务都关心的问题，使用 Use 方法来注册 middleware。

## 升职加薪指南

- 设计并实现一个 Gin 的插件库，Gin 的插件库有一些存在并发问题，因此你可能得自己写一个。

![[Snipaste/Pasted image 20240313135057.png]]

## 面试要点

实际上，Gin 作为简单的框架，能够面试的内容并不多。

- 什么是 Gin 的 middleware？能用来解决什么问题？
- 什么是跨域问题，怎么解决？
- **跨域问题需要设置哪些头部？**  

跨域资源共享（CORS，Cross-Origin Resource Sharing）是一种允许来自不同源的资源进行交互的机制，它通过在服务器端设置一系列的 HTTP 响应头来解决 AJAX 请求中的跨域问题。为了实现 CORS 并允许跨域请求，以下是一些关键的 HTTP 响应头部和它们的作用：

1. allow-origin
2. allow-methods
3. allow-headers
4. allow-credentials
5. expose-headers
6. max-age

以上是背诵内容

1. `Access-Control-Allow-Origin`
	- **作用**：指定哪些域名可以访问该资源。可以设置为具体的域名（如 `https://example.com`）或 `*`（表示任何域名）。
	- **示例**：`Access-Control-Allow-Origin: *`
2. `Access-Control-Allow-Methods`
	- **作用**：指定允许访问资源的 HTTP 方法（如 GET、POST 等）。
	- **示例**：`Access-Control-Allow-Methods: GET, POST, PUT`
3. `Access-Control-Allow-Headers`
	- **作用**：在预检请求（preflight request）中，指定浏览器允许在实际请求中使用的 HTTP 头列表。
	- **示例**：`Access-Control-Allow-Headers: Content-Type, Authorization`
4. `Access-Control-Allow-Credentials`
	- **作用**：指示响应是否可以暴露给页面。用于凭证请求，如果要发送 cookies，此值需设置为 `true`。
	- **示例**：`Access-Control-Allow-Credentials: true`
5. `Access-Control-Expose-Headers`
	- **作用**：指定哪些头部信息可以暴露为响应头部，供前端 JavaScript 代码访问。
	- **示例**：`Access-Control-Expose-Headers: Content-Length, X-Kuma-Revision`
6. `Access-Control-Max-Age`
	- **作用**：指定预检请求的结果能够被缓存多长时间（以秒为单位）。
	- **示例**：`Access-Control-Max-Age: 86400`

当你配置跨域策略时，不需要设置所有这些头部，具体取决于你的应用需求。例如，如果你的跨域请求不涉及特殊请求头、不发送凭证信息且只使用 GET、POST 或 HEAD 方法，那么只设置 `Access-Control-Allow-Origin` 可能就足够了。

需要注意的是，对于会修改数据的请求（如 POST、PUT、DELETE 等）或者发送了非简单请求头的请求，浏览器会首先发送一个预检请求（使用 OPTIONS 方法），询问服务器是否允许跨域请求。服务器必须正确响应这个预检请求，然后才会发送实际的请求。  

---

在 Gin 面试的时候，一定要提起自己研发了一个强大 Gin 插件库。  
