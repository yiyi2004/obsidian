随着业务系统功能、模块、规模、复杂性的增加，我们对 Redis 的要求越来越高，尤其是在高低峰场景的动态伸缩能力，比如：电商平台平日流量较低且平稳，双十一大促流量是平日的数倍，两种情况下对于各系统的数量要求必然不同。如果始终配备高峰时的硬件及中间件配置，必然带来大量的资源浪费。

Redis 作为业界优秀的缓存产品，成为了各类系统的必备中间件。哨兵模式虽然优秀，但由于其不具备动态水平伸缩能力，无法满足日益复杂的应用场景。在官方推出集群模式之前，业界就已经推出了各种优秀实践，比如：Codis、twemproxy 等。

为了弥补这一缺陷，自 3.0 版本起，Redis 官方推出了一种新的运行模式——Redis Cluster。

Redis Cluster 采用无中心结构，具备多个节点之间自动进行数据分片的能力，支持节点动态添加与移除，可以在部分节点不可用时进行自动故障转移，确保系统高可用的一种集群化运行模式。按照官方的阐述，Redis Cluster 有以下设计目标：

- 高性能可扩展，支持扩展到 1000 个节点。多个节点之间数据分片，采用异步复制模式完成主从同步，无代理方式完成重定向。
- 一定程度内可接受的写入安全：系统将尽可能去保留客户端通过大多数主节点所在网络分区所有的写入操作，通常情况下存在写入命令已确认却丢失的较短时间窗口。如果客户端连接至少量节点所处的网络分区，这个时间窗口可能较大。
- 可用性：如果大多数节点是可达的，并且不可达主节点至少存在一个可达的从节点，那么 Redis Cluster 可以在网络分区下工作。而且，如果某个主节点 A 无从节点，但是某些主节点 B 拥有多个（大于 1）从节点，可以通过从节点迁移操作，把 B 的某个从节点转移至 A。

简单概述。结合以上三个目标，我认为 Redis Cluster 最大的特点在于可扩展性，多个主节点通过分片机制存储所有数据，即每个主从复制结构单元管理部分 key。

因为在主从复制、哨兵模式下，同样具备其他优点。

当系统容量足够大时，读请求可以通过增加从节点进行分摊压力，但是写请求只能通过主节点，这样存在以下风险点：

- 所有写入请求集中在一个 Redis 实例，随着请求的增加，单个主节点可能出现写入延迟。
- 每个节点都保存系统的全量数据，如果存储数据过多，执行 rdb 备份或 aof 重写时 fork 耗时增加，主从复制传输及数据恢复耗时增加，甚至失败；
- 如果该主节点故障，在故障转移期间可能导致所有服务短时的数据丢失或不可用。

所以，动态伸缩能力是 Redis Cluster 最耀眼的特色。

## 1. 哈希槽

Redis-cluster 引入了**哈希槽**的概念。

Redis-cluster 中有 16384(即 2 的 14 次方）个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽。

Cluster 中的每个节点负责一部分 hash 槽（hash slot）。

比如集群中存在三个节点，则可能存在的一种分配如下：

- 节点 A 包含 0 到 5500 号哈希槽；
- 节点 B 包含 5501 到 11000 号哈希槽；
- 节点 C 包含 11001 到 16383 号哈希槽。

![image-20210717200519848](img/image-20210717200519848.png)

## 2. 请求重定向

Redis cluster 采用去中心化的架构，集群的主节点各自负责一部分槽，客户端如何确定 key 到底会映射到哪个节点上呢？这就是我们要讲的请求重定向。

在 cluster 模式下，**节点对请求的处理过程**如下：

- 检查当前 key 是否存在当前 NODE？
  - 通过 crc16（key）/16384 计算出 slot
  - 查询负责该 slot 负责的节点，得到节点指针
  - 该指针与自身节点比较
- 若 slot 不是由自身负责，则返回 MOVED 重定向
- 若 slot 由自身负责，且 key 在 slot 中，则返回该 key 对应结果
- 若 key 不存在此 slot 中，检查该 slot 是否正在迁出（MIGRATING）？
- 若 key 正在迁出，返回 ASK 错误重定向客户端到迁移的目的服务器上
- 若 Slot 未迁出，检查 Slot 是否导入中？
- 若 Slot 导入中且有 ASKING 标记，则直接操作
- 否则返回 MOVED 重定向

move 重定向：

![img](img/redis-cluster-3.png)

- 槽命中：直接返回结果
- 槽不命中：即当前键命令所请求的键不在当前请求的节点中，则当前节点会向客户端发送一个 Moved 重定向，客户端根据 Moved 重定向所包含的内容找到目标节点，再一次发送命令。

ASK 重定向：

Ask 重定向发生于集群伸缩时，集群伸缩会导致槽迁移，当我们去源节点访问时，此时数据已经可能已经迁移到了目标节点，使用 Ask 重定向来解决此种情况

![img](img/redis-cluster-5.png)

## 3. Cluster 集群结构搭建

**搭建方式**

1. 配置服务器（3 主 3 从）
  	1. 建立通信（Meet）
  	2. 分槽（Slot）
  	3. 搭建主从（master-slave）

**Cluster 配置：**

1. 是否启用 cluster，加入 cluster 节点

   ```properties
   cluster-enabled yes|no
   ```

2. cluster 配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容

   ```properties
   cluster-config-file filename
   ```

3. 节点服务响应超时时间，用于判定该节点是否下线或切换为从节点

   ```properties
   cluster-node-timeout milliseconds
   ```

4. master 连接的 slave 最小数量

```properties
cluster-migration-barrier min_slave_number
```

**Cluster 节点操作命令:**

1. 查看集群节点信息

   ```properties
   cluster nodes
   ```

2. 更改 slave 指向新的 master

   ```properties
   cluster replicate master-id
   ```

3. 发现一个新节点，新增 master

   ```properties
   cluster meet ip:port
   
   ```

4. 忽略一个没有 solt 的节点

   ```properties
   cluster forget server_id
   ```

5. 手动故障转移

   ```properties
   cluster failover
   ```

**redis-cli 命令**

1. 创建集群

   ```properties
   redis-cli –-cluster create masterhost1:masterport1 masterhost2:masterport2
   masterhost3:masterport3 [masterhostn:masterportn …] slavehost1:slaveport1
   slavehost2:slaveport2 slavehost3:slaveport3 ––cluster-replicas n
   ```

   master 与 slave 的数量要匹配，一个 master 对应 n 个 slave，由最后的参数 n 决定

   master 与 slave 的匹配顺序为第一个 master 与前 n 个 slave 分为一组，形成主从结构

2. 添加 master 到当前集群中，连接时可以指定任意现有节点地址与端口

   ```properties
   redis-cli --cluster add-node new-master-host:new-master-port now-host:now-port
   ```

3. 添加 slave

   ```properties
   redis-cli --cluster add-node new-slave-host:new-slave-port
   master-host:master-port --cluster-slave --cluster-master-id masterid
   ```

4. 删除节点，如果删除的节点是 master，必须保障其中没有槽 slot

   ```properties
   redis-cli --cluster del-node del-slave-host:del-slave-port del-slave-id
   ```

5. 重新分槽，分槽是从具有槽的 master 中划分一部分给其他 master，过程中不创建新的槽

   ```properties
   redis-cli --cluster reshard new-master-host:new-master:port --cluster-from srcmaster-id1, src-master-id2, src-master-idn --cluster-to target-master-id --cluster-slots slots
   ```

将需要参与分槽的所有 masterid 不分先后顺序添加到参数中，使用，分隔

指定目标得到的槽的数量，所有的槽将平均从每个来源的 master 处获取

1. 重新分配槽，从具有槽的 master 中分配指定数量的槽到另一个 master 中，常用于清空指定 master 中的槽

   ```properties
   redis-cli --cluster reshard src-master-host:src-master-port --cluster-from srcmaster-id --cluster-to target-master-id --cluster-slots slots --cluster-yes 
   ```
