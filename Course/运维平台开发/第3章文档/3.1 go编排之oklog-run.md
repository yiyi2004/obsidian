## 多个 Goroutine 协作，共同进退

- 地址 https://github.com/oklog/run
- prometheus 采用的

### 用法

- g.add 第一个参数为 run 函数，返回 error，要求改函数长时间运行，遇到错误再退出
  - 具体场景有两个 1. for +ticker +ctx
  - 长时间运行的 http 和 rpc 用 error chan 在 g.add 中做
- 第二个参数为 interrupt 函数，作用是退出时做一些清理操作

### 在 server.go Main 中添加如下代码

- 接收退出信号的函数

```go
	// 编排开始
	var g run.Group
	ctxAll, cancelAll := context.WithCancel(context.Background())
	fmt.Println(ctxAll)
	{

		// 处理信号退出的handler
		term := make(chan os.Signal, 1)
		signal.Notify(term, os.Interrupt, syscall.SIGTERM)
		cancelC := make(chan struct{})
		g.Add(
			func() error {
				select {
				case <-term:
					level.Warn(logger).Log("msg", "Receive SIGTERM ,exiting gracefully....")
					cancelAll()
					return nil
				case <-cancelC:
					level.Warn(logger).Log("msg", "other cancel exiting")
					return nil
				}
			},
			func(err error) {
				close(cancelC)
			},
		)
	}
	g.Run()
```

> 这时运行我们的 server ，点击停止可以看到

```shell
level=info ts=2021-07-30T11:03:55.821+08:00 caller=server.go:93 msg=successfully_init_db db_num=1
level=warn ts=2021-07-30T11:03:59.122+08:00 caller=server.go:112 msg="Received SIGTERM, exiting gracefully..."



```

- 退出的时候通知其他 goroutine 退出，在 ctxAll watch 的
- 只要有任意的 Add 函数报错了，逐一执行他们的 interrupt 函数，否则等待第一个 err 返回

#### 添加一个模块 1，看一下协同的效果

```go
	{

		g.Add(func() error {
			for {
				ticker := time.NewTicker(5 * time.Second)
				select {
				case <-ctxAll.Done():
					level.Warn(logger).Log("msg", "我是模块01退出了，接收到了cancelall")
					return nil
				case <-ticker.C:
					level.Warn(logger).Log("msg", "我是模块01")
				}

			}

		}, func(err error) {

		},
		)
	}

```

```go
// Package run implements an actor-runner with deterministic teardown. It is
// somewhat similar to package errgroup, except it does not require actor
// goroutines to understand context semantics. This makes it suitable for use in
// more circumstances; for example, goroutines which are handling connections
// from net.Listeners, or scanning input from a closable io.Reader.
package run

// Group collects actors (functions) and runs them concurrently.
// When one actor (function) returns, all actors are interrupted.
// The zero value of a Group is useful.
type Group struct {
	actors []actor
}

// Add an actor (function) to the group. Each actor must be pre-emptable by an
// interrupt function. That is, if interrupt is invoked, execute should return.
// Also, it must be safe to call interrupt even after execute has returned.
//
// The first actor (function) to return interrupts all running actors.
// The error is passed to the interrupt functions, and is returned by Run.
func (g *Group) Add(execute func() error, interrupt func(error)) {
	g.actors = append(g.actors, actor{execute, interrupt})
}

// Run all actors (functions) concurrently.
// When the first actor returns, all others are interrupted.
// Run only returns when all actors have exited.
// Run returns the error returned by the first exiting actor.
func (g *Group) Run() error {
	if len(g.actors) == 0 {
		return nil
	}

	// Run each actor.
	errors := make(chan error, len(g.actors))
	for _, a := range g.actors {
		go func(a actor) {
			errors <- a.execute()
		}(a)
	}

	// Wait for the first actor to stop.
	err := <-errors

	// Signal all actors to stop.
	for _, a := range g.actors {
		a.interrupt(err)
	}

	// Wait for all actors to stop.
	for i := 1; i < cap(errors); i++ {
		<-errors
	}

	// Return the original error.
	return err
}

type actor struct {
	execute   func() error
	interrupt func(error)
}
```
