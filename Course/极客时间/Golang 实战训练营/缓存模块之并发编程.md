## 并发编程

### Context

ThreadLocal ---> Context

新建的

赋值，新建的东西，线程 threadlocal 的东西。

rpc attachment  
grpc http header  
自定义的 rpc metadata

进程内传递  

context.Context 公共的方法

ekit 工具类库

长远考虑，提前使用 context.Context

![[Snipaste/Pasted image 20240127165501.png]]

child 覆盖 parent

![[Snipaste/Pasted image 20240127165737.png]]

传递一个 map，逼不得已，将 map 传递下去，child 修改 map，parent 可以拿到 map[key]

refresh token

![[Snipaste/Pasted image 20240127180248.png]]

判断是否超时  
![[Snipaste/Pasted image 20240127180415.png]]

正常的业务逻辑

- 超时分支
- 正常业务分支

没办法修改 Context

只能新建一个 Context

不建议在结构体中使用 context

errGroup ---> WaitGroup

![[Snipaste/Pasted image 20240127180940.png]]

- kratos app.go 的源代码，利用 errgroup 创建 context，然后利用 context 进行后续的控制

**errgroup 的这里没有怎么听懂**

我不知道你们是怎么回事

Context 底层源码

**double check——java**

在编程中，"Double Check"（双重检查）通常是指 "Double Check Locking"（双重检查锁定）模式，这是一种在多线程编程中使用的设计模式，用于减少同步的开销同时确保延迟初始化的线程安全。它主要用于对资源或对象进行惰性初始化，特别是在创建实例成本较高时。

双重检查锁定模式的工作原理如下：

1. **第一次检查**：首先检查资源或对象是否已经被初始化，而不加锁。如果已初始化，则直接返回对象。
2. **加锁**：如果资源或对象尚未初始化，就对初始化代码块进行加锁以确保线程安全。
3. **第二次检查**：在锁内部再次检查资源或对象是否已经被初始化。这是必要的，因为在获取锁之前，另一个线程可能已经完成了初始化。
4. **初始化**：如果资源或对象仍然未初始化，就进行初始化操作。
5. **解锁**：完成初始化后释放锁。
6. **返回对象**：返回初始化后的对象。

以下是一个简单的 Java 示例，演示了双重检查锁定模式用于单例模式的场景：

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) { // 第一次检查
            synchronized (Singleton.class) { // 加锁
                if (instance == null) { // 第二次检查
                    instance = new Singleton(); // 初始化
                }
            }
        }
        return instance;
    }
}
```

在这个示例中，`instance` 被声明为 `volatile`，这是确保双重检查锁定模式在 Java 中正确工作的关键。`volatile` 关键字保证了变量的可见性和有序性，防止指令重排。

需要注意的是，虽然双重检查锁定模式可以提高效率，但它在某些语言（尤其是早期的 Java 版本）中可能无法正确工作，因为编译器和处理器可能会对指令进行重排序。因此，在使用此模式时需要特别小心，确保它在你的编程环境中是安全的。

![[Snipaste/Pasted image 20240127182303.png]]

我真的感觉心情好 down 啊。

### Mutex

- 写多、读少 ---> 写锁
- 读多写少 ---> double check

![[Snipaste/Pasted image 20240127182842.png]]

分布式锁没有读锁的说法，因为分布式锁是很重的。

Mutex 和 RWMutex 都是不可重入的。

Java 的锁是可容入的，大多数分布式锁是可容入的。

**尽可能使用 defer 来解锁。**

Mutex 的面试要点

![[Snipaste/Pasted image 20240127190540.png]]  

**sync 的学习重点**

- double check 的写法
- 锁的模板 + 饥饿|正常模式
	- G1 效率上的优化
	- 源码没有必要

![[Snipaste/Pasted image 20240127190753.png]]  
![[Snipaste/Pasted image 20240127190816.png]]

- 四条注意事项

### sync.Pool

- byteBufferPool
- calibrating 校准机制
- sync.Pool 取代 stringBuilder

实现要点 PPT

![[Snipaste/Pasted image 20240127191603.png]]

put

![[Snipaste/Pasted image 20240127191616.png]]

![[Snipaste/Pasted image 20240127191939.png]]

- 动态计算是值得参考的

**sync.Pool 的面试要点**

![[Snipaste/Pasted image 20240127192029.png]]

TLB 解决全局锁竞争方案，GO 结合 P 解决这个问题。

sync.Pool 的内存使用量不可控的。

非常强的 Pool 的控制手段，使用 arena，自己控制内存的申请与实现。同样也可以设计缓存的结构。

**总结**

1. 使用
2. 原理 (面试)
3. Pool 与 GC
4. false sharing 内存对齐
5. bytebufferpool
	1. defaultsize
	2. maxSize
	3. 动态计算校准机制
