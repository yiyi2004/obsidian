![[Pasted image 20220309145316.png]]

# 操作系统补充
## 1. 死锁
1. 多个进程竞争资源
2. 外力
3. 死锁产生的原因：
	1. 系统资源的竞争
	2. 推进非法
4. 死锁产生的必要条件
	1. 互斥条件
	2. 不可剥夺
	3. 请求保持
	4. 循环等待（必要不充分，资源大于1）
5. 死锁处理策略
	1. 死锁预防：简单、效率低
		1. 互斥：共享、但有些不能
		2. 不可剥夺：复杂、开销、吞吐量
		3. 请求保持：一次分配、浪费
		4. 循环等待：顺序资源分配
	2. 死锁避免：复杂
		1. 安全状态、安全序列
	3. 检测解除
		1. 资源分配图
		2. 死锁定理
		3. 死锁和饥饿的区别
			1. 一个、至少两个
			2. 就绪、阻塞

## 2. 程序 | 进程 | 线程比较
1. 程序、进程、线程简述
	1. 程序：指令、数据、存储、静态
	2. 进程：描述控制程序并发执行、并发性共享性、动态、组成、单位
	3. 线程：
		1. 目的：更好多道程序并发
		2. 资源、系统
		3. 时空开销、并发性能
		4. CPU 执行的基本单元
		5. 组成：线程 ID、PC、寄存器集合和堆栈组成
		6. 调度
		7. 资源
		8. 共享
2. 程序和进程
	1. 为什么引入进程
		1. 为了描述程序动态执行时的性质。
	2. 进程如何解决问题
		1. PCB、切换、避免资源浪费、划分更小的调度单位线程提高并发度
	3. 程序和进程比较
		1. 永久、暂时：创建、撤销
		2. 静态、动态
		3. 并发性
		4. 资源分配
		5. 不一一对应
3. 进程和线程
	1. 为什么引入线程？进程存在缺陷
		1. 同一时间一件事
		2. 阻塞、其他工作无法进行
		3. 为了克服以上的缺陷
	2. 进程和线程的比较
		1. 调度
		2. 拥有资源
		3. 并发性
			1. 系统开销
		4. 地址空间和其他资源
		5. 通信方面
			1. IPC：同步互斥手段，保证数据的一致性，线程读写进程数据段
	3. 为什么线程的提出有利于提高系统并发性？

## 3. 虚拟内存管理
1. 前导知识简述
	1. 为什么要进行内存管理？为了更好支持多道程序并发执行![[Pasted image 20220310205834.png]]
	2. 链接和装入
		1. 编译：
		2. 链接：链接程序、函数库、一个完整的装入模块
			1. 静态链接：程序运行前
			2. 装入时动态链接：边装入边链接
			3. 运行时动态链接：需要时链接、修改更新、共享
		3. 装入：装入程序、装入内存运行
			1. 绝对装入：弹道程序环境、逻辑地址 == 物理地址、不需要转换
			2. 静态重定位：装入是一次性转换
			3. 动态重定位：运行时将逻辑地址转换为物理地址、移动
		4. 覆盖和交换：扩充内存的两种方法
		5. 覆盖和交换的区别
	3. 连续分配方式![[Pasted image 20220310211600.png]]
	4. 非连续分配方式：为了减少内部碎片和外部碎片
		1. 基本分页存储管理方式
		2. 基本分段存储管理方式
		3. 基本段页式管理方式


1. 页式虚拟内存（局部性原理、增加请求调页和页面置换、表象内存扩大）
	1. 页式虚拟内存
		1. 局部性原理：高速缓存技术，应用
			1. 时间局部性、循环
			2. 空间局部性、附近
		2. 额外硬件机构：
			1. 页表机制
			2. 缺页中断机构
			3. 地址变换机构
	2. 页表机制![[Pasted image 20220311093051.png]]
	3. 缺页中断机构
		1. 缺页中断：经历保护CPU环境、分析中断原因、转入缺页中断处理程序、恢复 CPU 环境几个阶段，但是与一般中断相比，有以下两点不同：
			1. 内部中断
			2. 一条指令，多次缺页中断
	4. 地址变换机构![[Pasted image 20220311093642.png]]
	5. 页面置换算法
		1. 最佳置换算法(OPT)：淘汰永不使用、无法实现
		2. 先进先出算法(FIFO)：Belady：物理块数、页故障数
		3. 最近最久未使用(LRU)：访问字段、寄存器和栈、堆栈类算法
		4. 时钟置换算法(CLOCK)：改进型时间置换算法
			1. CLOCK 算法
			2. 改进型 CLOCK 算法
				1. 优先级
				2. 执行步骤
			3. 改进型
				1. 首选没有改变的页
				2. 设置优先级
		5. 虚拟内存是怎样解决问题的？带来了什么问题？
			1. 换入换出、扩大内存
			2. 平均访存时间、不合适算法、性能降低
		6. 多级页表解决了什么问题？又带来了什么问题？
			1. 解决逻辑地址空间过大，页表过长的问题
			2. 多次访存，会大大增加一次访存的时间
2. **段式虚拟内存**
	1. 分页管理方式和分段管理方式的对比![[Pasted image 20220311143743.png]]
3. **段页式虚拟内存**
	1. 段页式管理方式的优缺点：段页式虚拟存储器的优点是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护。缺点是在地址变换过程中需要两次查表，系统开销较大。

## 4. IO 控制方式
1. 程序直接控制方式
	1. 简单、易实现、串行工作、速率不匹配、CPU 利用率相当低
2. 中断驱动方式
	1. 主要思想：允许 IO 设备主动打断 CPU 的运行并请求服务
	2. 痛点：存储器和 IO 控制器之间传输仍然要经过 CPU，消耗较多的 CPU 时间
	3. 关于什么是经过 CPU
3. DMA 方式
	1. 改进
		1. 基本单位是数据块，前面是一个字
		2. 设备和内存直接相连
		3. 仅在传送一个或多个数据块的开始或结束需要 CPU 干预，数据块的传送是在 DMA 控制器的控制下完成的
	2. DMA 控制器的组成
		1. 命令/状态控制器（CR)
		2. 内存地址寄存器（MAR）
		3. 数据寄存器（DR）
		4. 数据计数器（DC）
	3. DMA 控制器工作过程![[Pasted image 20220311150528.png]]
	4. 中断驱动方式和DMA方式的区别
		1. 一个字、一批数据
		2. CPU、DMA 控制器参与完成数据传送
		3. 如何进一步提高资源利用率？尽量解放 CPU
4. 通道控制方式：I/0 通道是指专门负责输入／输出的处理机。
	1. 减少 CPU 干预、CPU、通道、IO 设备三者并行工作![[Pasted image 20220311151119.png]]

## 5. 进程调度算法
1. 前导知识简述
	1. 为什么要就进行处理机调度
		1. 防止处理机资源被浪费
		2. 提高处理机的利用率
		3. 为了合理地处理计算机的软硬件资源
	2. 非抢占与抢占
		1. 非抢占式调度算法：实现简单、系统开销小、适用于大多数批处理系统、不适用于分时系统和大多数实时系统。
		2. 抢占式调度算法：但“剥夺”不是一种任意的行为，必须遵循一定的原则，主要有优先权、段进程优先和时间片原则等。
	3. 调度的基本评价准则
		1. CPU 利用率
		2. 系统吞吐率
		3. 周转时间
		4. 等待时间
		5. 响应时间
2. **FCFS**
3. SPF
	1. SPF 存在不容忽视的缺点
		1. 该算法对长作业不利，饥饿问题
		2. 未考虑紧迫程度
		3. 用户估计时间，不一定真正做到短作业优先
	2. SPF 的平均等待时间、平均周转时间最少
4. 优先级调度算法
	1. 分类
		1. 抢占式优先级调度算法
		2. 非抢占式优先级调度算法
		3. 静态优先级
		4. 动态优先级
	2. 优先级设置原则
		1. 系统进程 > 用户进程
		2. 交互式进程 > 非交互式进程
		3. IO 型进程 > 计算（CPU）型进程
5. 时间片轮转
	1. 分时系统
	2. 时间片大小选择要适当
	3. 时间片长短通常受以下因素影响
		1. 系统的响应时间
		2. 就绪队列中的进程数目
		3. 系统的处理能力
6. 高响应比优先调度：响应比＝(等待时间＋要求服务时间)/要求服务时间
	1. 等待时间相同
	2. 要求服务时间相同
	3. 长作业：克服饥饿，兼顾长作业
7. 多级反馈队列：时间片轮转算法、优先级调度算法

**现在不想学了，等有时间补一补吧。**

有时间好好准备一下
1. 数据结构
2. 计算机组成原理

合不合理对我来说不重要，重要的是开始做，再去改进。

好好读书，充实自己，这样才能摆脱表面的相似。
