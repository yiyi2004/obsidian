## 本节重点介绍

- 时序统计的结构体对象
- 时序统计结构体的管理者
- metrics 结果打点方法

## 时序统计的结构体对象

- 位置 counter\counter.go

```go
package counter

import "sync"

// 统计实体
type PointCounter struct {
	sync.RWMutex
	Count           int64   // 日志条数计数
	Sum             float64 // 正则数字的sum
	Max             float64 // 正则数字的Max
	Min             float64 // 正则数字的Min
	Ts              int64   // 时间戳
	MetricsName     string  // metrics name
	LogFunc         string  // 计算的方法 ，cnt/max/min
	SortLabelString string  //标签排序的结果
	LabelMap        map[string]string
}

func NewPointCounter(metricsName string, sortLabelString string, logFunc string, labelMap map[string]string) *PointCounter {
	pc := &PointCounter{
		MetricsName:     metricsName,
		LogFunc:         logFunc,
		SortLabelString: sortLabelString,
		LabelMap:        labelMap,
	}
	return pc
}


```

### 计算方法

```go
func (pc *PointCounter) Update(value float64) {
	pc.Lock()
	defer pc.RUnlock()
	pc.Sum = pc.Sum + value
	if math.IsNaN(pc.Max) || value > pc.Max {
		pc.Max = value
	}
	if math.IsNaN(pc.Min) || value < pc.Min {
		pc.Min = value
	}
	pc.Count += 1
	pc.Ts = time.Now().Unix()
}

```

## 时序统计结构体的管理者

```go
type PointCounterManager struct {
	sync.RWMutex
	CounterQueue chan *consumer.AnalysPoint
	// key 是标签排序后的string
	TagStringMap map[string]*PointCounter
	MetricsMap   map[string]*prometheus.GaugeVec
}

func NewPointCounterManager(cq chan *consumer.AnalysPoint, m map[string]*prometheus.GaugeVec) *PointCounterManager {
	pm := &PointCounterManager{
		CounterQueue: cq,
		TagStringMap: make(map[string]*PointCounter),
		MetricsMap:   m,
	}
	return pm

}
```

### 初始化方法

- 传入 metrics map 和分析结果的 chan

### 更新和获取统计实体的方法

```go
func (pm *PointCounterManager) GetPcByUniqueName(seriesId string, ) *PointCounter {
	pm.RLock()
	defer pm.RUnlock()
	return pm.TagStringMap[seriesId]
}

func (pm *PointCounterManager) SetPc(seriesId string, pc *PointCounter) {
	pm.Lock()
	defer pm.Unlock()
	pm.TagStringMap[seriesId] = pc
}
```

### 更新的 Manager 方法

- 通过分析 chan 接收 分析的结果
- 根据 metric 名字 + 有序标签字符串作为 key 获取统计的实体对象
- 如果没有就新建一个
- 然后调用 update 进行计算

## Metrics 结果打点方法

- 遍历 metrics map，获取 metrics 对象和它对应的统计实体
- 根据统计的方法，调用统计实体的字段进行打点

```go
// 打点的方法
func (pm *PointCounterManager) SetMetrics() {
	pm.Lock()
	defer pm.Unlock()
	for _, pc := range pm.TagStringMap {
		pc := pc
		metric, loaded := pm.MetricsMap[pc.MetricsName]
		if !loaded {
			logger.Errorf("[metrics.notfound][name:%v]", pc.MetricsName)
			continue
		}
		logger.Infof("[PointCounterManager.SetMetrics][pc:%+v]", pc)
		var value float64
		switch pc.LogFunc {
		case common.LogFuncCnt:
			value = float64(pc.Count)
		case common.LogFuncSum:
			value = float64(pc.Sum)
		case common.LogFuncMax:
			value = float64(pc.Max)
		case common.LogFuncMin:
			value = float64(pc.Min)
		case common.LogFuncAvg:
			value = float64(pc.Sum) / float64(pc.Count)
		}
		metric.With(prometheus.Labels(pc.LabelMap)).Set(value)

	}
}

```

### 打点的 Manager

```go
func (pm *PointCounterManager) SetMetricsManager(ctx context.Context) error {
	ticker := time.NewTicker(10 * time.Second)
	defer ticker.Stop()
	for {
		select {
		case <-ctx.Done():
			logger.Infof("PointCounterManager.SetMetricsManager.receive_quit_signal_and_quit")
			return nil
		case <-ticker.C:
			pm.SetMetrics()

		}

	}
}
```

## main.go 中启动这些 Manager

### 先初始化对应的对象

```go
	// 统计指标的同步queue
	cq := make(chan *consumer.AnalysPoint, common.CounterQueueSize)
	// 统计指标的管理器
	pm := counter.NewPointCounterManager(cq, metricsMap)
	// 日志job管理器
	logJobManager := logjob.NewLogJobManager(cq)
	// 把配置文件中的logjob传入
	logJobsyncChan := make(chan []*logjob.LogJob, 1)
	jobs := make([]*logjob.LogJob, 0)
	for _, i := range sConfig.LogStrategies {
		i := i
		j := &logjob.LogJob{Stra: i}
		jobs = append(jobs, j)

	}
	logJobsyncChan <- jobs
```

### oklog.run 启动任务

```go
	if sConfig.EnableLogJob {
		{

			// logJobManager 增量同步策略，任务的函数
			g.Add(func() error {
				err := logJobManager.SyncManager(ctxAll, logJobsyncChan)
				if err != nil {
					level.Error(logger).Log("msg", "TickerInfoCollectAndReport.error", "err", err)
					return err
				}
				return err

			}, func(err error) {
				cancelAll()
			},
			)
		}

		{
			// 统计计数的实体的管理器，接收ap 处理
			g.Add(func() error {
				err := pm.UpdateManager(ctxAll)
				if err != nil {
					level.Error(logger).Log("msg", "PointCounterManager.UpdateManager.error", "err", err)
					return err
				}
				return err

			}, func(err error) {
				cancelAll()
			},
			)
		}
		{
			// 统计任务实体转换为prometheus的metrics的任务
			g.Add(func() error {
				err := pm.SetMetricsManager(ctxAll)
				if err != nil {
					level.Error(logger).Log("msg", "PointCounterManager.SetMetricsManager.error", "err", err)
					return err
				}
				return err

			}, func(err error) {
				cancelAll()
			},
			)
		}

		{
			// logjob 结果的metrics http server
			g.Add(func() error {
				errChan := make(chan error, 1)
				go func() {
					errChan <- metrics.StartMetricWeb(sConfig.HttpAddr)
				}()
				select {
				case err := <-errChan:
					level.Error(logger).Log("msg", "logjob.metrics.web.server.error", "err", err)
					return err
				case <-ctxAll.Done():
					level.Info(logger).Log("msg", "receive_quit_signal_web_server_exit")
					return nil
				}

			}, func(err error) {
				cancelAll()
			},
			)
		}

	}

```

## 启动 Metrics 的 Http

- 因为 srv.ListenAndServe 方法不便于使用 ctx 控制，所以通过一个 errChan 接收它的错误

## 本节重点总结

- 时序统计的结构体对象
- 时序统计结构体的管理者
- metrics 结果打点方法
