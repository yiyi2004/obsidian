- 原则是穷尽算法的所有知识点和解法

## 哈希

### 1. 两数之和

- target - cur_num 是否在 map 中存在

### 49. 字母异位词分组

- sort.Slice 对 []byte 进行排序
- 使用 map 接收

### 128. 最长连续序列

- 使用 map 记录数值是否存在
- 记录 maxlong

## 双指针

### 283. 移动零

- make([]int, len(nums)) + 赋值

### 11. 盛最多水的容器

> 双指针的解题思路是什么
> 1. 当满足某一条件的时候，移动一个指针
> 2. 只遍历一次数组  
> 解题技巧
> 3. 可以夸大化数据，比如长板为 999999，短板为 10. 这样大概率就知道移动那个板子了。

- 移动短板

### 15. 三数之和

- 固定一个位置，然后使用双指针。
- 处理特殊情况 000 —— 似乎只有这一种情况。

### 42. 接雨水

- 这道题有多种解法：技巧、动态规划、双指针方法。

解法一：更偏向于技巧

- 前后遍历两次数组，由这两个最大值数组找到**封顶数组**。
- 用封顶数组减去原始数组中墙的高度。

## 滑动窗口

- 滑动窗口本质上也是双指针，不过是同向还是双向的区别。—— 我的理解是这样的。

### 3. 无重复字符的最长子串

- 要区分子序列和子串的概念。
- 右指针不断向右移动，检查 set 中是否存在当前右指针指向的字符，如果不存在，放入 set。
- 如果存在，弹出左指针指向的字符，直到右指针指向的字符在 set 中不存在。
- 将右指针指向的字符添加进 set。

### 438. 找到字符串中所有字母异位词

- 参数可能无限大也可能无限小 —— 做这样的假定，然后考虑时间和空间复杂度。
- 26 个字母是可固定的空间，所以类似 bitmap 那种处理方案。只要包含的字符相同，就是“异位词”。

## 子串

### 560. 和为 K 的子数组

- 脑子开始不转了，去做点其他事情吧。

### 239. 滑动窗口最大值

- `pre[i] - pre[j] = k`
- 如果 `pre[cur - k]` 存在，那么 `pre[cur] - pre[cur - k] == k`
- 滚动数组 + 前缀数组
- pre 记录到当前为止数组中所有数据的和
- map 记录某一个前缀和是否存在

### 76. 最小覆盖子串

- 滑动窗口 + 26 位数组对比

## 普通数组

### 53. 最大子数组和

条件判断的动态规划

- 动态规划 + 重复利用子数字
- 需要考虑初始化的问题
- 不是严格意义上的动态规

### 56. 合并区间

- 排序 + 分类讨论
- 最后位置即 intervals[len(intervals) - 1] 需要进行特殊讨论

### 189. 轮转数组

- 通过模运算操作 + helpArray

### 238. 除自身以外数组的乘积

- 0 的个数 2 个 | 1 个
- 比较简单，关键在于考虑是否完备

### 41. 缺失的第一个正数

- 通过 map 解决，但是性能很差
- 排序 + 二分查找
- 置换的算法 O(N) O(1)
- 原来的方法相等的时候会陷入无限的循环
- 因此判断条件应该是 nums[i] != nums[nums[i]-1] 先对 nums[i] 进行范围判断

## 矩阵

### 73. 矩阵置零

- 方法一：用 hash 表记录行列是否存在 0
- 优化方法二：用第一行和第一列标记矩阵右下侧 0 的位置

---

- 实现还是挺简单的
- 但是方法一确实有更好的效果啊。

### 54. 螺旋矩阵

- [一入循环深似海 | LeetCode：59.螺旋矩阵II_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1SL4y1N7mV/?spm_id_from=333.337.search-card.all.click&vd_source=25509bb582bc4a25d86d871d5cdffca3)

---

难点：处理的边界条件比较多

- 循环不变量
- 可是使用 offset 进行优化
- top, bottom, left, right 去解决

### 48. 旋转图像

- 左上角位单位，一次翻转 4 个位置
- n / 2 和 (n+1)/2 保证不重复和不漏掉元素

### 240. 搜索二维矩阵 II

- 遍历 + 二分查找

## 链表

### 160. 相交链表

- 通过哈希表解决
- 通过双指针解决

### 206. 反转链表

- 原地反转，并没有什么困难的

### 141. 环形链表

- 通过快慢指针解决问题

### 142. 环形链表 II

- 可以通过快慢指针解决，但是感觉没有必要。
- 我是通过哈希表实现的。

### 21. 合并两个有序链表

- 通过迭代实现

### 2. 两数相加

- 通过模拟实现，要注意一个链比较长的情况。

### 19. 删除链表的倒数第 N 个结点

- 方法一：计算长度，然后删除对应节点
- **快慢指针**到底是什么方法，为什么这么多链表的问题都能解决。

### 24. 两两交换链表中的节点

- 通过模拟的方式实现的 | 在于让别人信任你。

### 25. K 个一组翻转链表

- 困难
- 方法一：模拟 + reverse + 处理特殊情况

### 138. 随机链表的复制（忘记了，未完全解决）

- 深拷贝重新构建，可以通过 map 去记录 random 的节点，然后重新构建。

### 148. 排序链表

- 归并排序排序链表，不要投机取巧用数组排序。
- 但是问题出在哪里了呢？head.Next = nil 去掉后面的节点，方便归并排序的时候进行判断。

### 23. 合并 K 个升序链表

- 归并排序的策略，先合并两个。

### 146. LRU 缓存

- 代码封装的很好
- initDLinkedNode
- addToHead
- removeNode
- moveToHead
- removeTail

## 二叉树

### 94. 二叉树的中序遍历

- 递归实现

### 104. 二叉树的最大深度

- 递归实现，二叉 DP 问题

### 26. 翻转二叉树

- 递归实现，先交换再递归

### 101. 对称二叉树

- 深度优先遍历
- `return dfs(left.Left, right.Right) && dfs(left.Right, right.Left)`

### 543. 二叉树的直径

- 二叉 dp 问题，套路解决

### 102. 二叉树的层序遍历

- 封装队列数据结构，然后很轻松就能解决问题
- **队列中的节点就是上一层中所有的节点。**

### 108. 将有序数组转换为二叉搜索树

- 递归构建，并没有什么困难的。

### 98. 验证二叉搜索树

- **套路解决**，递归实现

### 230. 二叉搜索树中第 K 小的元素

- **中序遍历**解决问题

### 199. 二叉树的右视图

- dfs 解决
- 右侧优先
- 从 0 开始找到 depth == 1 ---> depth == n 的节点，用数组收集值，用数组的长度作为 depth 的判定条件

```go
func rightSideView(root *TreeNode) []int {

    if root == nil {

        return nil

    }

    // 层序遍历中每一层最后一个元素

    var dfs func(node *TreeNode, depth int)

    res := make([]int, 0)

    dfs = func(node *TreeNode, depth int) {

        if node == nil {

            return

        }

        if depth == len(res) {

            res = append(res, node.Val)

        }

        dfs(node.Right, depth+1)

        dfs(node.Left, depth+1)

    }

    dfs(root, 0)

    return res

}
```

### 114. 二叉树展开为链表

- 我的解法：先序遍历收集值，然后重新构建 (时间和空间复杂度都不理想)
- **将右子树迁移到左子树上面**
- 这道题的解法和**二叉 dp 的题目有些类似**，都是假设左子树和右子树已经处理好了，然后进行进一步的处理。

### 105. 从前序与中序遍历序列构造二叉树

- 通过**下标**的方式计算实在是**太傻了**
- **递归**实现的代码非常简洁，**缩小规模**很重要

### 437. 路径总和 III

- 定义两个函数
	- 从 root 出发，路径和为 target 的路径总数
	- root 节点下的路径和总数 ---> 题目中定义的函数

### 236. 二叉树的最近公共祖先

- 一个节点如果能**找到左节点和右节点**，那么这个节点就是最近公共祖先

### 124. 二叉树中的最大路径和

- 方法一：二叉 dp 递归套路

## 图论

### 200. 岛屿数量

- 每次用 ‘2’ 标记岛屿

### 994. 腐烂的橘子

- 每次腐烂周围的橘子，并且进行特殊标记，作为隔离，防止一直腐烂下去。

### 207. 课程表

- 依赖关系是拓扑排序比较明显的特征
- 一个记录依赖课程的总数
- 一个记录后继的课程
- 用一个队列不断添加课程，然后学习
- 拓扑排序确实使用对垒实现的

### 208. 实现 Trie (前缀树)

- 哥们已经没有耐心了

## 回溯

### 46. 全排列

- 回溯算法 + onPath map[i]bool

### 78. 子集

- 注意是子集，不是全排列。
- 解决的思路是是否放当前元素。

### 17. 电话号码的字母组合

- 循环 + 深度优先遍历
- 已经汗流浃背了，今天已经做的很好了，明天再开始吧。

### 39. 组合总和

- 利用 index 控制去重，不会回头走，用 target 和 index 共同判断是否可以添加到结果集合里面。

### 22. 括号生成

- 字符串 []byte 数组
- dfs 前一个字段 index 确认位置，后面的一个往往是判断条件

### 79. 单词搜索

- 记录 + 标记 + 恢复的过程
- 回溯算法

### 131. 分割回文串

- [带你学透回溯算法-分割回文串（对应力扣题目：131.分割回文串）| 回溯法精讲！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1c54y1e7k6/?spm_id_from=333.337.search-card.all.click&vd_source=25509bb582bc4a25d86d871d5cdffca3)
- 回溯算法套路
	- 递归得参数和返回值
	- 确定终止条件
	- 确定一层得处理逻辑
- 切割和组合的思路是类似的
- 判断回文串的思路和代码是简单的
- 要搞清楚字符串是如何切割的

### 51. N 皇后

```c++
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<string> cur(n, string(n, '.'));
        backtracking(cur, 0, n);
        return res;

    }
    void backtracking(vector<string>& cur, int level, int n) {
        if (level == n) {
            res.push_back(cur);
            return;
        }
        for (int j = 0; j < n; j++) {
            if(isValid(cur, level, j)) {
                cur[level][j] = 'Q';
                backtracking(cur, level + 1, n);
                cur[level][j] = '.';
            }
        }
    }
    bool isValid(const vector<string>& cur, int i, int j) {
        int n = cur.size();
        for (int a = 0; a < n; a++) { // 上
            if (cur[a][j] == 'Q') return false;
        }
        for (int a = i, b = j; a >= 0 && b >= 0; a--, b--) { // 左上
            if (cur[a][b] == 'Q') return false;
        }
        for (int a = i, b = j; a >= 0 && b < n; a--, b++) { // 右上
            if (cur[a][b] == 'Q') return false;
        }
        return true; // 其他方向都是未放过皇后的，不可能为false
    }
private:
    vector<vector<string>> res;
};
```

```go
func solveNQueens(n int) (res [][]string) {
	if n == 0 {
		return nil
	}
	tmp := make([]byte, n)
	for i := 0; i < n; i++ {
		tmp[i] = '.'
	}
	var dfs func(level int, preQueens []string)
	dfs = func(level int, preQueens []string) {
		if level == n {
			res = append(res, append([]string{}, preQueens...))
			return
		}
		for i := 0; i < n; i++ {
			t := make([]byte, n)
			copy(t, tmp)
			t[i] = 'Q'
			preQueens = append(preQueens, string(t))
			if isValid(preQueens, level, i) {
				dfs(level+1, preQueens)
			}
			preQueens = preQueens[:len(preQueens)-1]
		}
	}
	dfs(0, []string{})
	return res
}

func isValid(nowQueens []string, level, n int) bool {
	for i := level - 1; i >= 0; i-- {
		if nowQueens[i][n] == 'Q' {
			return false
		}
	}
	for i, j := level-1, n-1; i >= 0 && j >= 0; i, j = i-1, j-1 {
		if nowQueens[i][j] == 'Q' {
			return false
		}
	}
	for i, j := level-1, n+1; i >= 0 && j >= 0 && i < len(nowQueens) && j < len(nowQueens[0]); i, j = i-1, j+1 {
		if nowQueens[i][j] == 'Q' {
			return false
		}
	}
	return true
}
```

- golang 时刻注意值拷贝的问题
- isValid 函数
- 利用回溯算法解决问题

## 二分查找

### 35. 搜索插入位置

- 简单的二分查找，可以通过剪枝实现更高的执行效率。

### 74. 搜索二维矩阵

- 二叉搜索

### 34. 在排序数组中查找元素的第一个和最后一个位置

- 二分查找
- 仅仅是一个用递归实现，一个用非递归实现

### 33. 搜索旋转排序数组

- 划分为有序的部分和无序的部分，然后针对有序的部分进行操作
- 未解决的问题：`nums[mid] >= nums[l]` **为什么是这样的操作**

### 153. 寻找旋转排序数组中的最小值

- 仍然是二叉搜索，**但是我想知道为什么是以下的代码**

```go
func findMin(nums []int) int {
	low, high := 0, len(nums)-1
	for low < high {
		pivot := low + (high-low)/2
		if nums[pivot] < nums[high] {
			high = pivot
		} else {
			// 这里为什么
			low = pivot+1
		}
	}
	return nums[low]
}
```

### 4. 寻找两个正序数组的中位数

- 方法一：简单一点的，遍历 O(m + n)
- 方法二：不断的去掉 k / 2 的元素，下面是注意事项
	- 注意 k 是第 k 个，不是数组的下标
	- 注意下标的问题：举几个例子
	- 注意不要越界
	- 不断修改 k 的值

## 栈

### 20. 有效的括号

- 用栈实现，可以用 map 表示 pairs

### 155. 最小栈

- 维护两个栈，一个用来存储数据，一个用来维护当前栈中的最小值。

### 394. 字符串解码

- 用栈分别处理，数字、字母、`[` 和 `]`。

### 739. 每日温度

- 通过单调栈解决问题，< == > 三种情况
- 存储下标
- 单调递增栈，找到第一个比 index 元素大的元素
- 单调递减栈，找到第一个比 index 元素小 的元素

### 84. 柱状图中最大的矩形

- 单调递减栈栈顶元素的下一个元素就是左边第一个比他小的元素
- 这样右边第一个比栈顶元素小的和左边第一个比栈顶元素小的元素都能被找到
- 注意处理相等元素

## 堆

### 215. 数组中的第 K 个最大元素

- 利用快排每次都会确定一个元素位置的特性，可以找到第 k 大的数字。
- quickSelect 方法解决问题

### 347. 前 K 个高频元素

- 用堆实现为什么时间比排序算法还要差。
- 用库里面自带的排序算法反而快一点。

### 295. 数据流的中位数

- **通过里那个堆实现的，虽然但是，我没有看懂捏。**

## 贪心算法

### 121. 买卖股票的最佳时机

## 动态规划

## 多维动态规划

## 技巧
