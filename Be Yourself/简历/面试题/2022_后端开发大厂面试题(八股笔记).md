每个 OS 的线程都有⼀个固定⼤⼩的栈内存，通常是 2MB，栈内存⽤于保存在其他函数调⽤期间哪些正在执⾏或者  
临时暂停的函数的局部变量。这个固定的栈⼤⼩，如果对于 goroutine 来说，可能是⼀种巨⼤的浪费。作为对⽐  
goroutine 在⽣命周期开始只有⼀个很⼩的栈，典型情况是 2KB, 在 go 程序中，⼀次创建⼗万左右的 goroutine 也不  
罕⻅（2KB*100,000=200MB）。⽽且 goroutine 的栈不是固定⼤⼩，它可以按需增⼤和缩⼩，最⼤限制可以到  
1GB。

goroutine 没有特殊的标识

在⼤部分⽀持多线程的操作系统和编程语⾔中，线程有⼀个独特的标识，通常是⼀个整数或者指针，这个特性可以  
让我们构建⼀个线程的局部存储，本质是⼀个全局的 map，以线程的标识作为键，这样每个线程可以独⽴使⽤这个  
map 存储和获取值，不受其他线程⼲扰。  
goroutine 中没有可供程序员访问的标识，原因是⼀种纯函数的理念，不希望滥⽤线程局部存储导致⼀个不健康的  
超距作⽤，即函数的⾏为不仅取决于它的参数，还取决于运⾏它的线程标识。

---

atmoc.Value

sync.Map 方法学习和使用。

---

```go
go test -race mypkg // 测试包
go run -race mysrc.go // 编译和运⾏程序
go build -race mycmd // 构建程序
go install -race mypkg // 安装程序
```

---

switch case 检查变量类型

---

使⽤ new 函数来分配空间  
传递给 new 函数的是⼀个类型，⽽不是⼀个值  
返回值是指向这个新⾮配的地址的指针

new 是分配一个空间，然后返回这个空间的地址

---

要复制⼀个 Slice，最好使⽤ Copy 函数。

---

Golang 中 map 的底层实现是⼀个散列表，因此实现 map 的过程实际上就是实现散表的过程。在这个散列表中，主要出现的结构体有两个，⼀个叫 hmap(a header for a go map)，⼀个叫 bmap(a bucket for a Go map，通常叫其 bucket)。

装载因⼦：count/2^B

触发条件：

1. 装填因⼦是否⼤于 6.5
2. overflow bucket 是否太多

解决⽅法：

1. 双倍扩容：扩容采取了⼀种称为“渐进式”地⽅式，原有的 key 并不会⼀次性搬迁完毕，每次最多只会搬迁 2 个 bucket
2. 等量扩容：重新排列，极端情况下，重新排列也解决不了，map 成了链表，性能⼤⼤降低，此时哈希种⼦

hash0 的设置，可以降低此类极端场景的发⽣。

[[../../../Coding/Go/深入理解go/Go Map 原理|Go Map 原理]]

Go 语⾔中 map 采⽤的是哈希查找表，由⼀个 key 通过哈希函数得到哈希值，64 位系统中就⽣成⼀个 64bit 的哈希  
值，由这个哈希值将 key 对应到不同的桶  

bucket）中，当有多个哈希映射到相同的的桶中时，使⽤链表解决哈希冲突。key 经过 hash 后共 64 位，根  
据 hmap 中 B 的值，计算它到底要落在哪个桶时，桶的数量为 2^B，如 B=5，那么⽤ 64 位最后 5 位表示第⼏号  
桶，在⽤ hash 值的⾼ 8 位确定在 bucket 中的存储位置，当前 bmap 中的 bucket 未找到，则查询对应的  
overflow bucket，对应位置有数据则对⽐完整的哈希值，确定是否是要查找的数据。  

如果两个不同的 key 落在的同⼀个桶上，hash 冲突使⽤链表法接近，遍历 bucket 中的 key 如果当前处于 map 进  
⾏了扩容，处于数据搬移状态，则优先从 oldbuckets 查找。

---

![[Snipaste/Pasted image 20240413153945.png]]

- golang 的底层的解释

---

```go
type W struct {
 b int32
 c int64
}

func main() {
 var w *W = new(W)
 //这时w的变量打印出来都是默认值0，0
 fmt.Println(w.b,w.c)

 //现在我们通过指针运算给b变量赋值为10
 b := unsafe.Pointer(uintptr(unsafe.Pointer(w)) + unsafe.Offsetof(w.b))
 *((*int)(b)) = 10
 //此时结果就变成了10，0
 fmt.Println(w.b,w.c)
}
```
