# 本节重点介绍 :

- 日志正则消费分析对象
- 日志消费者组存在的意义和对应的方法
- 定义正则分析结果对象AnalysPoint
- 编写正则处理方法

日志消费组和日志正则处理对象AnalysPoint

# 日志正则消费分析对象

## consumer对象

- 位置 consumer\consumer.go

```go
package consumer

import (
	"open-devops/src/models"
)
//单个 consumer对象
type Consumer struct {
	FilePath     string
	Stream       chan string         // 接收生产者的chan
	Stra         *models.LogStrategy // 策略
	Mark         string              // worker的名字，方便后续排查问题
	Close        chan struct{}
	CounterQueue chan *AnalysPoint
	//	 统计的字段
	Analyzing bool // 正在分析日志
}

```

## 启动和停止

```go
func (c *Consumer) Start() {
	go func() {
		c.Work()
	}()
}

func (c *Consumer) Stop() {
	close(c.Close)
}

```

## 核心的work方法

- 启动一个  统计的任务协程
- 核心方法为，从c.Stream接收每行的日志，然后调用 analysis方法进行分析

```go
func (c *Consumer) Work() {
	logger.Infof("[Consumer:%v]starting...{}", c.Mark)
	var anaCnt, anaSwp int64
	analysClose := make(chan struct{})

	go func() {
		for {

			select {
			case <-analysClose:
				return
			case <-time.After(time.Second * 10):

			}
			a := anaCnt
			logger.Infof("[Consumer:%v][analysis %d line in last 10s]", c.Mark, a-anaSwp)
			anaSwp = a
		}
	}()

	for {
		select {
		case line := <-c.Stream:
			anaCnt++
			c.Analyzing = true
			c.analysis(line)
			c.Analyzing = false

		case <-c.Close:
			analysClose <- struct{}{}
			return
		}
	}

}

```

## 日志正则处理函数 analysis

- 可以先使用简单的日志打印代替，如果能打印说明流程没问题

```go
func (c *Consumer) analysis(line string) {
	logger.Infof("[Consumer:%v][analysis.line:%s ]", c.Mark, line)
}

```

# 日志消费者组

## 作用

- 因为正则匹配比较消耗资源，速度较慢
- 所以一个消费者不够用，所以要抽象消费者组容纳多个消费者

## 代码

- 位置 consumer\group.go

```go
package consumer

import (
	"fmt"
	"open-devops/src/modules/agent/config"
	"github.com/toolkits/pkg/logger"
)

// 定义消费者组
type ConsumerGroup struct {
	Consumers   []*Consumer
	ConsumerNum int
}

// TODO 缺analyPoint
func NewConsumerGroup(filePath string, stream chan string, stra *config.LogStrategy) *ConsumerGroup {
	cNum := 10
	cg := &ConsumerGroup{
		Consumers:   make([]*Consumer, 0),
		ConsumerNum: cNum,
	}
	logger.Infof("[NewConsumerGroup  ][file:%s][num:%d]", filePath, cNum)
	for i := 0; i < cNum; i++ {
		mark := fmt.Sprintf("[log.consumer][file:%s][num:%d/%d]", filePath, i+1, cNum)
		c := &Consumer{
			FilePath: filePath,
			Stream:   stream,
			Stra:     stra,
			Mark:     mark,
			Close:    make(chan struct{}),
		}
		cg.Consumers = append(cg.Consumers, c)
	}
	return cg

}

func (cg *ConsumerGroup) Start() {
	for i := 0; i < cg.ConsumerNum; i++ {
		cg.Consumers[i].Start()
	}
}

func (cg *ConsumerGroup) Stop() {
	for i := 0; i < cg.ConsumerNum; i++ {
		cg.Consumers[i].Stop()
	}
}

```

#### 解读一下

- 根据配置的组中消费者数量，创建消费者
- stream是接收日志reader信息的chan
- cq是分析结果后传输 结果的chan，对象是AnalysPoint

# 初始化job

- 位置logjob\perjob.go

```go
package logjob

import (
	"crypto/md5"
	"encoding/hex"
	"open-devops/src/common"
	"open-devops/src/modules/agent/config"
	"open-devops/src/modules/agent/consumer"
	"open-devops/src/modules/agent/reader"
	"github.com/toolkits/pkg/logger"
)

type LogJob struct {
	r    *reader.Reader          // 读取日志
	c    *consumer.ConsumerGroup // 代表我们的消费者组
	Stra *config.LogStrategy     // 策略

}

func (lj *LogJob) hash() string {
	md5obj := md5.New()
	md5obj.Write([]byte(lj.Stra.MetricName))
	md5obj.Write([]byte(lj.Stra.FilePath))
	return hex.EncodeToString(md5obj.Sum(nil))
}

func (lj *LogJob) start() {

	fPath := lj.Stra.FilePath
	// stream
	stream := make(chan string, common.LogQueueSize)
	// new reader
	r, err := reader.NewReader(fPath, stream)
	if err != nil {
		return
	}
	lj.r = r
	// new consumer
	cg := consumer.NewConsumerGroup(fPath, stream, lj.Stra)
	lj.c = cg
	// 启动 r 和c
	// 先消费者
	lj.c.Start()
	// 后生产者
	go r.Start()
	logger.Infof("[create.LogJob.success][fPath:%v][metric_name:%d]", fPath, lj.Stra.MetricName)

}
// 先停生成者，后消费者
func (lj *LogJob) stop() {
	lj.r.Stop()
	lj.c.Stop()
}

```

# 定义正则分析结果对象

- 位置 consumer\consumer.go

```go
// 从consumer 往计算部分推的point
type AnalysPoint struct {
	Value           float64 // 数字的正则结果， cnt 计数的时候就是NaN
	MetricsName     string  // metrics name
	LogFunc         string  // 计算的方法 ，cnt/max/min
	SortLabelString string  //标签排序的结果
	LabelMap        map[string]string
}
```

# 编写正则处理方法

## 处理日志主正则

- patternReg.FindStringSubmatch(line) 的结果v
- len=0 说明 正则没匹配中，应该丢弃这行
- len=1 说明 正则匹配中了，但是小括号分组没匹配到
- len>1 说明 正则匹配中了，小括号分组也匹配到

```go
	var (
		patternReg = c.Stra.PatternReg
		value      = math.NaN()
		vString    string // 非cnt的正则 数字分组
	)
	//	处理日志主正则
	v := patternReg.FindStringSubmatch(line)

	/*
		## 处理日志主正则
		- patternReg.FindStringSubmatch(line) 的结果v
		- len=0 说明 正则没匹配中，应该丢弃这行
		- len=1 说明 正则匹配中了，但是小括号分组没匹配到
		- len>1 说明 正则匹配中了，小括号分组也匹配到
	*/
	if len(v) == 0 {
		//	 正则没匹配中，应该丢弃这行
		return
	}
	logger.Infof("[mark:%v][line:%v][reg_res:%v]", c.Mark, line, v)

	if len(v) > 1 {
		// len>1 说明 正则匹配中了，小括号分组也匹配到
		vString = v[1]
	}
	// 如果value能被解析成float ，说明配置的 正则分组 应该是 code=200
	value, _ = strconv.ParseFloat(vString, 64)

```

## 设置value

- 将正则匹配的结果做float64转行，如果失败就设置一个NaN

## 处理标签的正则

```go
	// 处理tag的正则
	labelMap := map[string]string{}
	for key, regTag := range c.Stra.TagRegs {

		labelMap[key] = ""
		t := regTag.FindStringSubmatch(line)
		if t != nil && len(t) > 1 {
			labelMap[key] = t[1]
		}

	}
```

- code=404 和code=200 是两个series，因为标签不一致
- 所以需要一个标签排序的方法
- ```
  func SortedTags(tags map[string]string) string {
  	if tags == nil {
  		return ""
  	}

  	size := len(tags)
  	if size == 0 {
  		return ""
  	}

  	ret := new(bytes.Buffer)

  	if size == 1 {
  		for k, v := range tags {
  			ret.WriteString(k)
  			ret.WriteString("=")
  			ret.WriteString(v)
  		}
  		return ret.String()
  	}

  	keys := make([]string, size)
  	i := 0
  	for k := range tags {
  		keys[i] = k
  		i++
  	}
  	sort.Strings(keys)

  	for j, key := range keys {
  		ret.WriteString(key)
  		ret.WriteString("=")
  		ret.WriteString(tags[key])
  		if j != size-1 {
  			ret.WriteString(",")
  		}
  	}

  	return ret.String()
  }

  ```

## 构造正则分析的结果，塞入chan中

```go
	ret := &AnalysPoint{
		Value:           value,
		MetricsName:     c.Stra.MetricName,
		LogFunc:         c.Stra.Func,
		SortLabelString: SortedTags(labelMap),
		LabelMap:        labelMap,
	}
	c.CounterQueue <- ret
```

# 本节重点总结 :

- 日志正则消费分析对象
- 日志消费者组存在的意义和对应的方法
- 定义正则分析结果对象AnalysPoint
- 编写正则处理方法