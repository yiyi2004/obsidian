## 多实例部署的 Session 问题

答案是 Gin 本身提供了很多的实现，包括:

- cookie：基于内存的实现
- gorm：基于 GORM 的实现
- memcached：基于 Memcached 的实现
- memstore：基于内存的实现
- mongo：基于 MongoDB 的实现
- postgres：基于 PostgreSQL 的实现
- redis：基于 Redis 的实现
- tester：用于测试的实现  

基于 Redis 实现

![[Snipaste/Pasted image 20240115162229.png]]

- **Authentication**：是指身份认证。
- **Encryption**：是指数据加密。  
- 授权：权限控制

这两者再加上授权（权限控制），就是信息安全的三个核心概念。

提供功能的时候需要考虑，**是否需要不同的实现**——面向接口编程

## 刷新 Session 的过期时间

> 举个例子：假如你设置为 10 分钟，那么用户登录了 9:59 秒之后，还能访问网站，结果过了两秒，他就被要求重新登录。

**需要在用户使用网站的时候刷新过期时间**，不然会被要求重新登录网站，体验不好。

几种策略：  

1. 用户每次访问，我都刷新。
	1. 性能差，对 Redis 之类的影响很大。
2. 快要过期了我再刷新，比如说 10 分钟过期。当用户第 9 分钟访问过来的时候，我就刷新。
	1. 万一我在第 9 分钟以后都没再访问过呢？——正好是 8.59 或者 10.01 访问呢？
3. **固定间隔时间刷新，比如说每分钟内第一次访问我都刷新。**
4. **使用长短 token。这个我们在后面接入微信登录的时候再深入讨论。**

在 Middleware 中进行刷新，登录校验的时候进行刷新。  

登录状态保持多久比较好？  
也就是，一次登录之后，要隔多久才需要继续登录？ 答案是取决于你的**产品经理**，也取决于你系统其它方面的安全措施。 简单来说，就是如果你有别的验证用户身份的机制，那么你就可以让用户长时间不需要登录。

## JWT

组成：  

- **Header**：头部，JWT 的**元数据**，也就是描述这个 token 本身的数据，一个 JSON 对象。
- **Payload**：负载，**数据内容**，一个 JSON 对象。
- **Signature**：签名，**根据 header 和 token 生成**。

```shell
go get github.com/golang-jwt/jwt/v5
```

登录过程中使用 JWT 的两步：

1. JWT 加密和解密数据
2. 登录校验

JWT 的基本使用方法

![[Snipaste/Pasted image 20240115163432.png]]

一定要进行跨域的设置

![[Snipaste/Pasted image 20240115163521.png]]

![[Snipaste/Pasted image 20240115163659.png]]

前端每次访问，携带 token  
![[Snipaste/Pasted image 20240115163738.png]]

JWT Token 的总结  

![[Snipaste/Pasted image 20240115164402.png]]

**JWT Token**

JWT（JSON Web Token）是一种开放标准（RFC 7519），用于在各方之间以 JSON 对象的形式安全地传输信息。由于其信息是数字签名的，因此可以被验证和信任。JWT 通常用于身份验证和信息交换，特别是在 Web 应用中用于实现无状态的认证机制。

JWT 的结构主要包含三个部分，它们之间以点（`.`）分隔：

1. **头部（Header）**：头部通常包含两部分信息，令牌的类型（即 "JWT"）和所使用的签名算法，如 HMAC SHA256 或 RSA。
2. **负载（Payload）**：负载部分包含所要传递的声明（Claim），声明是关于实体（通常指的是用户）和其他数据的声明。这些声明可以包含用户的身份信息、权限等，但应避免放入敏感数据，因为负载部分在客户端是可解码的。
3. **签名（Signature）**：为了创建签名部分，你必须采用编码后的头部、编码后的负载、一个密钥，使用头部中指定的算法进行签名。签名用于验证消息的发送者是谁以及消息在传输途中未被篡改。

### JWT 的使用流程大致如下

1. 用户使用用户名和密码登录。
2. 服务器验证用户的信息，如果验证成功，服务器将创建一个 JWT，然后把它发送回用户。
3. 客户端接收 JWT 并将其存储在本地，通常是在 localStorage 或 sessionStorage 中。
4. 客户端在之后的每个请求中将 JWT 发送给服务器。
5. 服务器验证 JWT 的签名，并从中提取用户信息来完成认证或其他操作。

### JWT 的优点包括

- **无状态和可扩展性**：服务器不需要保存用户的认证信息或会话状态，从而易于扩展。
- **安全性**：JWT 支持对称加密（HMAC）和非对称加密（RSA），确保了数据的安全性。
- **自包含**：JWT 包含了所有用户认证所需的信息，避免了多次查询数据库。

### 注意事项

尽管 JWT 在 Web 开发中非常流行，它也有一些潜在的安全问题，比如：

- 如果不使用 **HTTPS**，JWT **可能被拦截**。
- 一旦 JWT 被盗用，直到它过期之前，攻击者都可以使用它来访问系统资源。
- 默认情况下，JWT 的 Payload 是 Base64 编码的，而不是加密的，因此不应在 JWT 中放置任何敏感数据。

因此，使用 JWT 时需要谨慎处理安全相关的问题，确保通信渠道的安全，并合理设置 JWT 的过期时间。

---

和 Session 比起来，优点：

- 不依赖于第三方存储。
- 适合在分布式环境下使用。
- **提高性能**（因为没有 Redis 访问之类的）。  
缺点：
- **对加密依赖非常大**，比 Session 容易泄密。
- **最好不要在 JWT 里面放置敏感信息。**

**如何混用 session 和 JWT**

- 前面 JWT 限制了我们不能使用敏感数据，那么你真有类似需求的时候，就可以考虑将数据放在 “Session”里面。  
- 基本的思路就是：你在 JWT 里面存储你的 userId，然后用 userId 来组成 key，比如说 **user.info:123** 这 种 key，然后用这个 key 去 **Redis** 里面取数据，也可以考虑使用本地缓存数据。

## 初步保护系统

- 正常用户会不会搞崩你的系统？
- 如果有人攻击你的系统，你能撑住吗？  

对于中小型公司来说，第一条不会是问题。对于大公司来说，就要两条都考虑。  

冷静下来

**你今天已经很棒了**。
