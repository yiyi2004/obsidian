- 微服务基础理论
	- 微服务架构的概念
		- 分而治之
		- 模块化与微服务化
	- 微服务和 RESTful 的关系
- DDD 基础理论
	- entity
	- value object
	- repository
	- factory
	- domain event
	- domain service
- Protobuf 入门
	- 基本语法入门
		- message 定义
		- 字段类型
		- map repeat option
		- go_package
	- 编译
		- protoc 安装
		- 编译命令
		- 生成产物
- GRPC 入门
	- 生成服务端代码
	- 生成客户端代码
	- 实现服务端接口
	- 启动服务器
	- 客户端发起调用
- 微服务拆分
	- 拆分的基本方案
	- 拆分步骤
	- 验证方案
	- 回滚方案
- 拆分 webook
	- 选择模块
	- 补充测试
	- 微服务化
- 微服务拆分数据迁移方案
	- 制定数据迁移方案
	- 双写方案
	- 数据校验方案
	- 数据修复方案
	- 切换流量方案
	- 回滚方案

## 微服务基础理论

![[Snipaste/Pasted image 20240307183942.png]]

1. 功能分解、离散服务、实现解决方案的解耦
2. 每个服务可独立的进行开发、管理和迭代
3. 特点：组件化、松耦合、自治、去中心化、轻量通讯机制、部署单个或者多个机器上
4. 架构有很多种、微服务只有一种

为什么微服务（或者说分治）能降低复杂度？S > Sa + Sb

拆分带来两方面的好处

1. 总体复杂度降低
2. 单个模块复杂度变得可理解
3. 模块之间使用 API 耦合，无需了解其他模块的实现细节

![[Snipaste/Pasted image 20240307184805.png]]

1. 整合全部模块于一个单体应用，这个过程比较**复杂**
2. 从运维角度出发，**实例才是最基本的单位**，微服务化的管理力度更细
3. 微服务的独立性更强
4. 微服务更加贴近公司组织架构，减少组织之间的交流损耗

![[Snipaste/Pasted image 20240307185144.png]]

1. 底层通信
2. 调用语义
3. 服务注册与发现
4. 负载均衡
5. 服务治理 (可用性)

一个近似的话题，微服务网关。

![[Snipaste/Pasted image 20240307185412.png]]

1. 基于 TCP 的 RPC 协议 Dubbo
2. 基于 HTTP 的 RPC 协议，gRPC
3. 基于 UDP 的协议
4. 二次封装消息队列的 RPC 协议

![[Snipaste/Pasted image 20240307190205.png]]

基于 HTTP 的微服务架构甚至更好一点诶

![[Snipaste/Pasted image 20240307190324.png]]

## DDD(Domain Driven Design)

非常流行的系统设计方法论

![[Snipaste/Pasted image 20240308083758.png]]

DDD 的一些基本概念

- 限界上下文 Bounded Context
- 实体 Entry
- 值对象 Value Object
- 聚合体 Aggregate
- 工厂 Factory
- 仓库 Repository
- 实践 Domain Event
- 服务 Domain Service

#不懂

这部分需要看视频进行深入的学习

## Protobuf 入门

![[Snipaste/Pasted image 20240308084137.png]]

1. 高性能：基于 QUIC 协议，还利用了 HTTP2 的双向流特性，此外 gRPC 支持流控制和压缩，进一步提高了性能
2. 跨语言：主流的语言都有 gRPC 的实现，所以是异构系统的第一选择
3. 开源：强大的开源社区

![[Snipaste/Pasted image 20240308084530.png]]

- IDL interface description language 接口秒速语言
	- 计算机语言、跨平台开发的基础
	- 平台无关、通过一个编译过程、生成各个语言的代码
- protobuf 是 google 开发的数据序列化协议，是 gRPC 选择的 IDL 的落地实现。

![[Snipaste/Pasted image 20240308085600.png]]

1. 高性能
2. 跨平台和语言无关性
3. 强大的扩展性
4. 丰富的 API 支持

`syntax= ”proto3“`  
go_package 就是指定了你对应的 Go 包名

![[Snipaste/Pasted image 20240308095505.png]]

字段数据类型

![[Snipaste/Pasted image 20240308095619.png]]

- int
- bytes
- float double
- fixed sfixed 固定长度的数字类型
- bool
- string

![[Snipaste/Pasted image 20240308095823.png]]

- map<string, string>
- repeated string nickname = 1
- optional 可选字段

![[Snipaste/Pasted image 20240308095937.png]]

- 标记多个字段只有一个字段有值

枚举类型

![[Snipaste/Pasted image 20240308100138.png]]

- 我咋感觉我不怎么使用枚举类型呢

![[Snipaste/Pasted image 20240308100600.png]]

- service
- rpc 方法
- message 作为输入输出

![[Snipaste/Pasted image 20240308100633.png]]

protobuf 的安装

![[Snipaste/Pasted image 20240308100801.png]]

- protoc 命令参数
	- proto_path
	- go_out
	- go_opt 设置 go 的编译选项
	- grpc_out 指定 gRPC 代码生成输出目录
	- plugin 指定代码生成插件

安装 go 和 gRPC 插件

![[Snipaste/Pasted image 20240308101011.png]]

- 当你需要把 Protobuf 编译成 Go 和 gRPC 的时候，你需要安装对应的插件。
	- protoc-gen-go
	- protoc-gen-go-grpc

编译——重要解释，我终于知道为什么这么写了

![[Snipaste/Pasted image 20240308101236.png]]

![[Snipaste/Pasted image 20240308101252.png]]

- user.pb.go 是 Go 代码，不含 gRPC 的内容，主要是结构体定义
- user_grpc.pb.go 是生成的 gRPC 代码

UserServiceClient

![[Snipaste/Pasted image 20240308102142.png]]

UserServiceServer

![[Snipaste/Pasted image 20240308102458.png]]

- 不懂为什么兼容性

![[Snipaste/Pasted image 20240308102547.png]]

![[Snipaste/Pasted image 20240308102817.png]]

1. 先创建一个 gRPC Server
2. 在创建一个 UserServiceServer 实现的实例
3. 调用 RegisterUserServiceServer 注册，这个函数是 Protobuf 生成的
4. 创建一个监听网络端口的 Listener
5. 调用 gRPC Server 上的 Serve 方法

![[Snipaste/Pasted image 20240308103101.png]]

客户端发起调用

1. 初始化一个连接池
2. 用连接池初始化一个客户端
3. 利用客户端发起调用

生产环境要使用 HTTPS 协议

## 面试要点

![[Snipaste/Pasted image 20240308103212.png]]  
#不懂

---

下面是课程内容，需要看课程了。

## 微服务拆分

## 拆分 Webook

## 微服务拆分的数据迁移方案

1. 制定数据迁移方案
2. 数据校验方案
3. 数据修复方案
4. 双鞋方案
5. 切换流量方案
6. 回滚方案

![[Snipaste/Pasted image 20240308103644.png]]

#面试

- 面试要点可以不要
