- 原则是穷尽算法的所有知识点和解法

## 哈希

### 1. 两数之和

- target - cur_num 是否在 map 中存在

### 49. 字母异位词分组

- sort.Slice 对 []byte 进行排序
- 使用 map 接收

### 128. 最长连续序列

- 使用 map 记录数值是否存在
- 记录 maxlong

## 双指针

### 283. 移动零

- make([]int, len(nums)) + 赋值

### 11. 盛最多水的容器

> 双指针的解题思路是什么
> 1. 当满足某一条件的时候，移动一个指针
> 2. 只遍历一次数组  
> 解题技巧
> 3. 可以夸大化数据，比如长板为 999999，短板为 10. 这样大概率就知道移动那个板子了。

- 移动短板

### 15. 三数之和

- 固定一个位置，然后使用双指针。
- 处理特殊情况 000 —— 似乎只有这一种情况。

### 42. 接雨水

- 这道题有多种解法：技巧、动态规划、双指针方法。

解法一：更偏向于技巧

- 前后遍历两次数组，由这两个最大值数组找到**封顶数组**。
- 用封顶数组减去原始数组中墙的高度。

## 滑动窗口

- 滑动窗口本质上也是双指针，不过是同向还是双向的区别。—— 我的理解是这样的。

### 3. 无重复字符的最长子串

- 要区分子序列和子串的概念。
- 右指针不断向右移动，检查 set 中是否存在当前右指针指向的字符，如果不存在，放入 set。
- 如果存在，弹出左指针指向的字符，直到右指针指向的字符在 set 中不存在。
- 将右指针指向的字符添加进 set。

### 438. 找到字符串中所有字母异位词

- 参数可能无限大也可能无限小 —— 做这样的假定，然后考虑时间和空间复杂度。
- 26 个字母是可固定的空间，所以类似 bitmap 那种处理方案。只要包含的字符相同，就是“异位词”。

## 子串

### 560. 和为 K 的子数组

- 脑子开始不转了，去做点其他事情吧。

### 239. 滑动窗口最大值

- `pre[i] - pre[j] = k`
- 如果 `pre[cur - k]` 存在，那么 `pre[cur] - pre[cur - k] == k`
- 滚动数组 + 前缀数组
- pre 记录到当前为止数组中所有数据的和
- map 记录某一个前缀和是否存在

### 76. 最小覆盖子串

## 普通数组

## 矩阵

## 链表

## 二叉树

## 图论

## 回溯

## 二分查找

## 栈

### 739. 每日温度

- 通过单调栈解决问题，< == > 三种情况

## 堆

## 贪心算法

## 动态规划

## 多维动态规划

## 技巧
