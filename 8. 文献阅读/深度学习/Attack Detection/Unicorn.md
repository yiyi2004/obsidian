- [论文源码](https://github.com/crimson-unicorn/analyzer)
# Unicorn
- 针对APT攻击特性提出一种基于Provenance的异常检测系统。
- 引入一种新的基于概要的（sketch-based）、时间加权的（time-weighted）溯源编码，该编码非常紧凑且可处理长时间的溯源图。
- 通过模拟和真实的APT攻击来评估UNICORN，证明其能高精度检测APT活动。
- 实现代码开源。

预定义的边匹配规则过于敏感，很难检测到APT攻击中的0-Day漏洞；
溯源图的近邻约束导致其只能提供局部上下文信息（而非whole-system），然而这会影响相关异常检测精度；
系统行为模型难以检测APT：静态模型无法捕获长期运行的系统的行为；动态模型容易遭受中毒攻击；
溯源图的存储与计算都是在内存中，在执行长期检测上有局限性。

>深度学习模型中毒攻击与防御综述
>[(138条消息) 深度学习模型的中毒攻击与防御综述_数据派THU的博客-CSDN博客](https://blog.csdn.net/tMb8Z9Vdm66wH68VX1/article/details/113009497)

- 数据收集框架的完整性是UNICORN正确性的核心，因此我们假定所使用的CamFlow中，LSM完整性是可信的。同时，本文假设内核、溯源数据和分析引擎的正确性，我们重点关注UNICORN的分析能力。

- [CamFlow: practical whole-system provenance for Linux](https://camflow.org/)：这个东西需要跑一下试试

本文基于一维WL同构检验，采用了线性时间的、快速的Weisfeiler-Lehman（WL）子树图核算法。该算法的使用依赖于构造的顶点直方图的能力，需要直方图能捕捉每个顶点周围的结构信息。根据扩充的顶点标签对顶点进行分类，这些标签完全描述了顶点的领域，并且通过迭代的标签传播来构造这些扩展的顶点标签。


## 全系统追踪溯源
全系统溯源运行在操作系统层面，捕获的是所有系统行为和它们之间的交互。通过捕获信息流和因果关系，即使攻击者通过操作内核对象来隐藏自己的行踪也无济于事。

本文使用CamFlow，采用了Linux安全模块（Linux Security Modules，LSM）框架来确保高效可靠的信息流记录。LSM可以消除race condition。

CamFlow：溯源搜集系统，参考官网 https://camflow.org/。

**UNICORN可以解决如上问题，其本质是把APT检测问题看成大规模、带有属性的实时溯源图异常检测问题。在任何时间，从系统启动到其当前状态捕获的溯源图都将与已知正常行为的溯源图进行比较。如果有明显差别，那么就认为该系统正在遭受攻击。**

## Unicorn 基本流程
![[Pasted image 20221018144511.png]]
1. 以一个带标签的流式溯源图作为输入。**该图由CamFlow生成**，每条边是带属性的。溯源系统构建一个具有偏序关系的DAG溯源图，能实现有效的流式计算和上下文分析。
2. 建立一个运行时的内存直方图。UNICORN有效构建一个流式直方图，该直方图表示系统执行的历史，如果有新边产生则实时更新直方图的计数结果。通过迭代的探索大规模图的近邻关系，发现了在上下文环境中系统实体的因果关系。该工作是 UNICORN 的第一步，具体来说，**直方图中每个元素描述了图中唯一的一个子结构**，同时考虑了子结构中的顶点与边上的异构标签，以及这些边的时间顺序。APT攻击缓慢的渗透攻击目标系统，希望基于的异常检测方法最终忘记这一行为，把其当成正常的系统行为，**但是APT攻击并不能破坏攻击成功的相关信息流依赖关系**。
3. 定期计算固定大小的概要图（graph sketch）。**在纯流式环境**，当UNICORN对整个溯源进行汇总时，唯一直方图元素的数量可能会任意增长。这种动态变化导致两个直方图之间的相似计算变得非常有挑战，从而使得基于直方图相似计算的建模以及检测算法变的不可行。UNICORN采用**相似度保存的hash技术**把直方图转换成概要图。概要图可以增量维护，也意味着UNICORN并不需要将整个溯源图都保存在内存中。另外，**概要图保存了两个直方图之间的jaccard相似性**，这在后续**图聚类分析**中特别有效。
4. 将简略图聚类为模型。UNICORN 可以在没有攻击知识的前提下实现 APT 攻击检测。与传统的聚类方法不同，**UNICORN 利用它的流处理能力生成一个动态演化模型**。该模型通过在其运行的各个阶段对系统活动进行聚类捕获单个执行中的行为改变，但是UNICORN无法在攻击者破坏系统时动态实时修改模型。因此，它更适合APT攻击这类长期运行的攻击。

- 爬虫也是需要解决的问题呢。

## 构建图直方图
- 本文方法的目标是有效对溯源图进行比较分析，同时容忍正常执行中的微小变化。

**本文基于一维WL同构检验，采用了线性时间的、快速的Weisfeiler-Lehman（WL）子树图核算法**。该算法的使用依赖于构造的顶点直方图的能力，需要直方图能捕捉每个顶点周围的结构信息。根据扩充的顶点标签对顶点进行分类，这些标签完全描述了顶点的领域，并且通过迭代的标签传播来构造这些扩展的顶点标签。

![[Pasted image 20221017095544.png]]

## 图概要
一个直观的方法来解决流式直方图相似度分析问题就是预先枚举所有可能的直方图元素。显示这是不现实的。这里采用局部敏感hash方法-HistoSketch，该方法是一种基于一致加权采样的方法，且时间得性是常数。

## 学习演化模型
聚类是识别异常值的常用的数据挖掘方法 data mining。

## 实现
本文实现使用图形处理框架 GraphChi，在C++中实现了UNICORN的图形处理算法，在Python中实现了数据解析和建模组件。

GraphChi是一个基于磁盘的系统，它可以在一台计算机上高效地计算具有数十亿条边的大型图。使用GraphChi，UNICORN可以在不需要将整个起源图存储在内存中的情况下获得高效的分析性能。UNICORN依赖于GraphChi的两个重要特性：
1. GraphChi使用一个并行滑动窗口（PSW）算法将形分割成碎片，每个碎片中的边数大致相同；它并行计算每个碎片。该算法只需少量的非顺序磁盘访问，就可以快速更新磁盘的顶点和边。这允许UNICORN独立于内存约束来分析整个起源图。
2. UNICORN利用GraphChi对流图的高效计算。

UNICORN在训练过程中创建了一个时序的概要。然后，使用著名的K-medods算法从单个服务器对该概要序列进行聚类，使用轮廓系数确定最佳值。聚类代表系统执行的“元状态”，例如启动、初始化、稳态行为。然后，UNICORN使用所有聚类中概要的时间顺序和每个聚类的统计数据来生成系统演化的模型。算法2描述了进化模型的构建。每个概要$S(t)$属于一个索引的簇k。演化E是一个有序的簇索引列表，其顺序由时间序列概要$S(t)$决定。

![[Pasted image 20221017100249.png]]

对于每个训练实例，UNICORN创建一个模型，该模型捕获系统运行时执行状态的更新。直观地说，这类似于跟踪系统执行状态的自动机。最终的模型由训练数据中所有种源图的多个子模型组成。

- 直方图是由流式溯源图

在部署期间，异常检测遵循前面章节中描述的相同流模式。UNICORN周期性地创建图概要，**因为直方图从流式溯源图演变而来**。给定一个图概要，UNICORN将该概要与建模期间学习的所有子模型进行比较，将其拟合到每个子模型中的一个聚类中。UNICORN假设监视从系统启动开始，并跟踪每个子模型中的系统状态转换。要在任何子模型中为有效，概要必须适合当前状态或下一个状态；否则，被视为异常。因此，**我们检测到两种形式的异常行为：不适合现有聚类的概要和聚类之间的无效转换。**

# Camflow
我的建议是直接看官方文档：
- https://camflow.org/
- https://getfedora.org/en/workstation/download/

![[Pasted image 20221017095338.png]]

- 确实，你就不该在宿舍学习，

# 演讲
- 当溯源图远离已经构建好额模型的时候，
- we first streamed a graph into a vertex centric graph processing framework where we iterate over each labelled vertex to build a in-memory 

# Reference
- [(138条消息) 论文解读-UNICORN: Runtime Provenance-Based Detector for Advanced Persistent Threats_进阶白帽子的博客-CSDN博客_camflow 溯源](https://blog.csdn.net/xjxtx1985/article/details/106473928)